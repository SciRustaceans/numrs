warning: unexpected `cfg` condition value: `bench`
   --> src/airy.rs:717:7
    |
717 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `std::mem`
 --> src/bandec.rs:1:5
  |
1 | use std::mem;
  |     ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `approx::assert_abs_diff_eq`
 --> src/bcuint.rs:2:5
  |
2 | use approx::assert_abs_diff_eq;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts`
 --> src/bessel_I1.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_j1.rs:423:7
    |
423 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `PI`
 --> src/bessel_j1.rs:1:24
  |
1 | use std::f64::consts::{PI, FRAC_PI_4};
  |                        ^^

warning: unnecessary parentheses around assigned value
   --> src/bessel_jy.rs:172:14
    |
172 |         p /= (i_f64 - xmu);
    |              ^           ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
172 -         p /= (i_f64 - xmu);
172 +         p /= i_f64 - xmu ;
    |

warning: unnecessary parentheses around assigned value
   --> src/bessel_jy.rs:173:14
    |
173 |         q /= (i_f64 + xmu);
    |              ^           ^
    |
help: remove these parentheses
    |
173 -         q /= (i_f64 + xmu);
173 +         q /= i_f64 + xmu ;
    |

warning: unexpected `cfg` condition value: `parallel`
   --> src/bessel_k0.rs:323:7
    |
323 | #[cfg(feature = "parallel")]
    |       ^^^^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `parallel` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `std::f64::consts`
 --> src/bessel_k0.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts`
 --> src/bessel_k1.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_y1.rs:550:7
    |
550 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `PI`
 --> src/bessel_y1.rs:1:24
  |
1 | use std::f64::consts::{PI, FRAC_PI_4};
  |                        ^^

warning: unused import: `super::*`
 --> src/bessel_y1.rs:9:9
  |
9 |     use super::*;
  |         ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_yn.rs:583:7
    |
583 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `super::*`
 --> src/bessel_yn.rs:7:9
  |
7 |     use super::*;
  |         ^^^^^^^^

warning: unused import: `super::*`
  --> src/bessel_yn.rs:67:9
   |
67 |     use super::*;
   |         ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessik.rs:471:7
    |
471 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `FRAC_PI_2`
 --> src/bessik.rs:1:28
  |
1 | use std::f64::consts::{PI, FRAC_PI_2};
  |                            ^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessj0.rs:390:7
    |
390 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/bessy0.rs:515:7
    |
515 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/beta.rs:184:7
    |
184 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `std::f32::consts::LN_2`
 --> src/beta.rs:1:5
  |
1 | use std::f32::consts::LN_2;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
 --> src/beta.rs:2:5
  |
2 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^

warning: unused import: `std::sync::OnceLock`
 --> src/Carlson_elliptic_integral_first.rs:4:5
  |
4 | use std::sync::OnceLock;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ptr`
 --> src/chebpc.rs:1:5
  |
1 | use std::ptr;
  |     ^^^^^^^^

warning: unused import: `std::f64::consts::PI`
 --> src/Convolve.rs:2:5
  |
2 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `SQRT_2`
 --> src/dawson_integral.rs:3:28
  |
3 | use std::f64::consts::{PI, SQRT_2};
  |                            ^^^^^^

warning: unused import: `Arc`
 --> src/ddpoly.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/ei.rs:315:7
    |
315 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/error_functions.rs:440:7
    |
440 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `SQRT_2`
 --> src/error_functions.rs:1:28
  |
1 | use std::f32::consts::{PI, SQRT_2};
  |                            ^^^^^^

warning: unused doc comment
  --> src/eulsum.rs:92:1
   |
92 | /// Thread-local Euler summation for better performance in single-threaded contexts
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion
   = note: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Arc`
 --> src/eulsum.rs:1:17
  |
1 | use std::sync::{Arc, Mutex, RwLock};
  |                 ^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/exponential_integral.rs:313:7
    |
313 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `SeekFrom` and `Seek`
 --> src/Four_FS.rs:2:15
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |               ^^^^  ^^^^^^^^

warning: unused imports: `Arc` and `Mutex`
 --> src/Four_FS.rs:6:17
  |
6 | use std::sync::{Arc, Mutex};
  |                 ^^^  ^^^^^

warning: unused imports: `SeekFrom` and `Seek`
 --> src/Fourn.rs:2:15
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |               ^^^^  ^^^^^^^^

warning: unused imports: `Arc` and `Mutex`
 --> src/Fourn.rs:6:17
  |
6 | use std::sync::{Arc, Mutex};
  |                 ^^^  ^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/gamma_continued_funciton.rs:335:7
    |
335 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/gamma_continued_funciton.rs:1:24
  |
1 | use std::f32::consts::{E, PI};
  |                        ^

warning: unexpected `cfg` condition value: `bench`
   --> src/gamma_series.rs:329:7
    |
329 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `E` and `LN_2`
 --> src/gamma_series.rs:1:24
  |
1 | use std::f32::consts::{E, LN_2, PI};
  |                        ^  ^^^^

warning: unused doc comment
  --> src/gammln.rs:23:1
   |
23 | /// Thread-local cache for frequently computed values
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused import: `crate::gammln`
 --> src/gaujac.rs:1:5
  |
1 | use crate::gammln;
  |     ^^^^^^^^^^^^^

warning: unused import: `crate::gammln`
 --> src/gaulag.rs:1:5
  |
1 | use crate::gammln;
  |     ^^^^^^^^^^^^^

warning: unused import: `std::mem`
 --> src/gaussjdcp.rs:1:5
  |
1 | use std::mem;
  |     ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/inc_beta_func.rs:398:7
    |
398 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/inc_beta_func.rs:1:24
  |
1 | use std::f64::consts::{E, PI};
  |                        ^

warning: unexpected `cfg` condition value: `bench`
   --> src/incomplete_gamma.rs:326:7
    |
326 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/incomplete_gamma.rs:1:24
  |
1 | use std::f32::consts::{E, PI};
  |                        ^

warning: unused import: `std::f64::consts::FRAC_1_PI`
 --> src/Jacobian_elliptical.rs:2:5
  |
2 | use std::f64::consts::FRAC_1_PI;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Array1`
 --> src/orthog.rs:1:23
  |
1 | use ndarray::{Array2, Array1};
  |                       ^^^^^^

warning: unused imports: `ArrayView1` and `ArrayView2`
 --> src/pade.rs:2:31
  |
2 | use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
  |                               ^^^^^^^^^^  ^^^^^^^^^^

warning: unused import: `Arc`
 --> src/pade.rs:3:17
  |
3 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `std::ptr`
 --> src/pccheb.rs:2:5
  |
2 | use std::ptr;
  |     ^^^^^^^^

warning: unused imports: `Array1` and `ArrayView1`
 --> src/polcof.rs:3:15
  |
3 | use ndarray::{Array1, ArrayView1};
  |               ^^^^^^  ^^^^^^^^^^

warning: unused import: `Arc`
 --> src/polydiv.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused imports: `ArrayView1` and `ArrayViewMut1`
 --> src/polydiv.rs:4:23
  |
4 | use ndarray::{Array1, ArrayView1, ArrayViewMut1};
  |                       ^^^^^^^^^^  ^^^^^^^^^^^^^

warning: unused import: `std::f64`
 --> src/qrdcmp.rs:3:5
  |
3 | use std::f64;
  |     ^^^^^^^^

warning: unused import: `rayon::prelude::*`
 --> src/quad3d.rs:1:5
  |
1 | use rayon::prelude::*;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Mutex`
 --> src/quad3d.rs:2:22
  |
2 | use std::sync::{Arc, Mutex};
  |                      ^^^^^

warning: unused import: `std::f64::consts::PI`
 --> src/quad3d.rs:3:5
  |
3 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Arc`
 --> src/random_0.rs:3:17
  |
3 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_0.rs:141:11
    |
141 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_1.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_1.rs:3:5
  |
3 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_1.rs:213:11
    |
213 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_2.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_2.rs:3:5
  |
3 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_2.rs:281:11
    |
281 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_3.rs:1:17
  |
1 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_3.rs:2:5
  |
2 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_3.rs:259:11
    |
259 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `ArrayView1` and `ArrayView2`
 --> src/ratlsq.rs:2:31
  |
2 | use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
  |                               ^^^^^^^^^^  ^^^^^^^^^^

warning: unused import: `ArrayView1`
 --> src/ratval.rs:4:23
  |
4 | use ndarray::{Array1, ArrayView1};
  |                       ^^^^^^^^^^

warning: unused imports: `Array1` and `Array2`
 --> src/Recursive_Stratified_Sampling.rs:4:15
  |
4 | use ndarray::{Array1, Array2};
  |               ^^^^^^  ^^^^^^

warning: unused import: `std::f64::consts`
 --> src/Recursive_Stratified_Sampling.rs:7:5
  |
7 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `approx::assert_abs_diff_eq`
 --> src/splie2.rs:1:5
  |
1 | use approx::assert_abs_diff_eq;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `approx::assert_abs_diff_eq`
 --> src/splin2.rs:3:5
  |
3 | use approx::assert_abs_diff_eq;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CsVec`
 --> src/sprspm.rs:1:19
  |
1 | use sprs::{CsMat, CsVec};
  |                   ^^^^^

warning: unused import: `std::f64::consts::*`
   --> src/lib.rs:191:13
    |
191 |     pub use std::f64::consts::*;
    |             ^^^^^^^^^^^^^^^^^^^

error[E0432]: unresolved import `special`
   --> src/gaulag.rs:316:9
    |
316 |     use special::Gamma;
    |         ^^^^^^^ use of unresolved module or unlinked crate `special`
    |
    = help: if you wanted to use a crate named `special`, use `cargo add special` to add it to your `Cargo.toml`

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_i.rs:195:10
     |
 195 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 153 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_i.rs:300:10
     |
 300 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 266 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_I1.rs:179:10
     |
 179 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 147 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_j.rs:314:10
     |
 314 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 282 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: cannot multiply `i32` by `f64`
  --> src/bessel_jy.rs:51:25
   |
51 |     let mut rjl = isign * FPMIN;
   |                         ^ no implementation for `i32 * f64`
   |
   = help: the trait `Mul<f64>` is not implemented for `i32`
   = help: the following other types implement trait `Mul<Rhs>`:
             `&i32` implements `Mul<&num_complex::Complex<i32>>`
             `&i32` implements `Mul<&num_complex::Complex<i32>>`
             `&i32` implements `Mul<i32>`
             `&i32` implements `Mul<num_complex::Complex<i32>>`
             `&i32` implements `Mul<num_complex::Complex<i32>>`
             `&i32` implements `Mul`
             `i32` implements `Mul<&ArrayBase<S, D>>`
             `i32` implements `Mul<&i32>`
           and 7 others

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_jy.rs:327:10
     |
 327 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `(T, T, T, T)` to implement `Debug`
     = note: 3 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<(T, T, T, T)>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 294 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

warning: unused import: `approx::assert_relative_eq`
   --> src/Cos_FT.rs:144:9
    |
144 |     use approx::assert_relative_eq;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `LN_2`
 --> src/gamma_series.rs:1:27
  |
1 | use std::f32::consts::{E, LN_2, PI};
  |                           ^^^^

warning: unused import: `approx::assert_abs_diff_eq`
   --> src/hunt.rs:201:9
    |
201 |     use approx::assert_abs_diff_eq;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0369]: cannot multiply `T` by `T`
  --> src/bessel_k0.rs:61:55
   |
61 |     coeffs.iter().rev().fold(T::zero(), |acc, &c| acc * x + c)
   |                                                   --- ^ - T
   |                                                   |
   |                                                   T
   |
help: consider further restricting type parameter `T` with trait `Mul`
   |
60 | fn polynomial_eval<T: BesselFloat + std::ops::Mul>(x: T, coeffs: &[T]) -> T {
   |                                   +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
  --> src/bessel_k0.rs:76:19
   |
76 |         let y = x * x / T::from_f64(4.0);
   |                 - ^ - T
   |                 |
   |                 T
   |
help: consider further restricting type parameter `T` with trait `Mul`
   |
68 |     T: BesselFloat + std::ops::Mul,
   |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
  --> src/bessel_k0.rs:94:14
   |
94 |         -((x / T::from_f64(2.0)).ln() * i0) + poly
   |            - ^ ---------------- T
   |            |
   |            T
   |
help: consider further restricting type parameter `T` with trait `Div`
   |
68 |     T: BesselFloat + std::ops::Div,
   |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
  --> src/bessel_k0.rs:97:34
   |
97 |         let y = T::from_f64(2.0) / x;
   |                 ---------------- ^ - T
   |                 |
   |                 T
   |
help: consider further restricting type parameter `T` with trait `Div`
   |
68 |     T: BesselFloat + std::ops::Div,
   |                    +++++++++++++++

warning: unused import: `approx::assert_abs_diff_eq`
   --> src/locate.rs:158:9
    |
158 |     use approx::assert_abs_diff_eq;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0600]: cannot apply unary operator `-` to type `T`
   --> src/bessel_k0.rs:113:9
    |
113 |         (-x).exp() / x.sqrt() * poly
    |         ^^^^ cannot apply unary operator `-`
    |
help: consider further restricting type parameter `T` with trait `Neg`
    |
 68 |     T: BesselFloat + std::ops::Neg,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:125:20
    |
125 |         let y = (x / T::from_f64(3.75)).powi(2);
    |                  - ^ ----------------- T
    |                  |
    |                  T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
120 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:139:35
    |
139 |         let y = T::from_f64(3.75) / ax;
    |                 ----------------- ^ -- T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
120 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:165:20
    |
165 |         let y = (x / T::from_f64(3.75)).powi(2);
    |                  - ^ ----------------- T
    |                  |
    |                  T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
160 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:179:35
    |
179 |         let y = T::from_f64(3.75) / ax;
    |                 ----------------- ^ -- T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
160 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
   --> src/bessel_k0.rs:213:19
    |
213 |         let y = x * x / T::from_f64(4.0);
    |                 - ^ - T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Mul`
    |
206 |     T: BesselFloat + std::ops::Mul,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:229:12
    |
229 |         (x / T::from_f64(2.0)).ln() * i1 + (T::one() / x) * poly
    |          - ^ ---------------- T
    |          |
    |          T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:229:54
    |
229 |         (x / T::from_f64(2.0)).ln() * i1 + (T::one() / x) * poly
    |                                             -------- ^ - T
    |                                             |
    |                                             T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:231:34
    |
231 |         let y = T::from_f64(2.0) / x;
    |                 ---------------- ^ - T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0600]: cannot apply unary operator `-` to type `T`
   --> src/bessel_k0.rs:246:9
    |
246 |         (-x).exp() / x.sqrt() * poly
    |         ^^^^ cannot apply unary operator `-`
    |
help: consider further restricting type parameter `T` with trait `Neg`
    |
206 |     T: BesselFloat + std::ops::Neg,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:267:40
    |
267 |             let tox = T::from_f64(2.0) / x;
    |                       ---------------- ^ - T
    |                       |
    |                       T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
253 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
   --> src/bessel_k0.rs:272:54
    |
272 |                 let bkp = bkm + T::from_i32(k) * tox * bk;
    |                                 -------------------- ^ -- T
    |                                 |
    |                                 T
    |
help: consider further restricting type parameter `T` with trait `Mul`
    |
253 |     T: BesselFloat + std::ops::Mul,
    |                    +++++++++++++++

warning: unused import: `ArrayView1`
 --> src/polcof.rs:3:23
  |
3 | use ndarray::{Array1, ArrayView1};
  |                       ^^^^^^^^^^

warning: unnecessary parentheses around assigned value
   --> src/spherical_bessel.rs:420:25
    |
420 |         let jp0_exact = (1.0f64.cos() / 1.0 - 1.0f64.sin() / (1.0 * 1.0));
    |                         ^                                               ^
    |
help: remove these parentheses
    |
420 -         let jp0_exact = (1.0f64.cos() / 1.0 - 1.0f64.sin() / (1.0 * 1.0));
420 +         let jp0_exact = 1.0f64.cos() / 1.0 - 1.0f64.sin() / (1.0 * 1.0) ;
    |

warning: unnecessary parentheses around assigned value
   --> src/spherical_bessel.rs:421:25
    |
421 |         let yp0_exact = (1.0f64.sin() / 1.0 + 1.0f64.cos() / (1.0 * 1.0));
    |                         ^                                               ^
    |
help: remove these parentheses
    |
421 -         let yp0_exact = (1.0f64.sin() / 1.0 + 1.0f64.cos() / (1.0 * 1.0));
421 +         let yp0_exact = 1.0f64.sin() / 1.0 + 1.0f64.cos() / (1.0 * 1.0) ;
    |

warning: unused import: `std::f64`
   --> src/utils.rs:270:9
    |
270 |     use std::f64;
    |         ^^^^^^^^

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_k1.rs:260:10
     |
 260 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 228 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0599]: the method `get` exists for struct `std::sync::MutexGuard<'_, HashMap<f64, f64>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:114:42
    |
114 |             if let Some(&result) = cache.get(&x) {
    |                                          ^^^ method cannot be called on `std::sync::MutexGuard<'_, HashMap<f64, f64>>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            `f64: Hash`

error[E0599]: the method `insert` exists for struct `std::sync::MutexGuard<'_, HashMap<f64, f64>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:124:19
    |
124 |             cache.insert(x, result);
    |                   ^^^^^^
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            `f64: Hash`

error[E0599]: the method `entry` exists for struct `MutexGuard<'_, HashMap<(f64, f64, usize), Arc<...>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:227:15
    |
227 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64, usize): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64, usize): Hash`
    = note: the full name for the type has been written to '/home/archdabe/Documents/Numerical-recipies/Rust/numrs/target/debug/deps/num_rs-75eecc34265e6ee7.long-type-11767845056558386598.txt'
    = note: consider using `--verbose` to print the full type name to the console

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), Arc<ChebyshevOperator>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_calc.rs:293:15
    |
293 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), Arc<ChebyshevOperator>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_calc.rs:306:15
    |
306 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0599]: no method named `par_chunks_mut` found for mutable reference `&mut ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` in the current scope
  --> src/Convolve.rs:46:10
   |
45 | /     respns_padded
46 | |         .par_chunks_mut(1)
   | |_________-^^^^^^^^^^^^^^
   |
help: there is a method `exact_chunks_mut` with a similar name
   |
46 -         .par_chunks_mut(1)
46 +         .exact_chunks_mut(1)
   |

error[E0599]: no method named `par_chunks_mut` found for struct `ArrayBase<S, D>` in the current scope
   --> src/Convolve.rs:101:10
    |
100 | /     ans_fft
101 | |         .par_chunks_mut(2)
    | |_________-^^^^^^^^^^^^^^
    |
help: there is a method `exact_chunks_mut` with a similar name
    |
101 -         .par_chunks_mut(2)
101 +         .exact_chunks_mut(2)
    |

error[E0599]: no method named `par_chunks` found for reference `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` in the current scope
   --> src/Convolve.rs:102:23
    |
102 |         .zip(data_fft.par_chunks(2))
    |                       ^^^^^^^^^^
    |
help: there is a method `exact_chunks` with a similar name
    |
102 -         .zip(data_fft.par_chunks(2))
102 +         .zip(data_fft.exact_chunks(2))
    |

error[E0599]: no method named `par_chunks` found for reference `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` in the current scope
   --> src/Convolve.rs:103:25
    |
103 |         .zip(respns_fft.par_chunks(2))
    |                         ^^^^^^^^^^
    |
help: there is a method `exact_chunks` with a similar name
    |
103 -         .zip(respns_fft.par_chunks(2))
103 +         .zip(respns_fft.exact_chunks(2))
    |

error[E0599]: no method named `par_chunks_mut` found for struct `ArrayBase<S, D>` in the current scope
  --> src/Correlation.rs:79:10
   |
78 | /     ans_fft
79 | |         .par_chunks_mut(2)
   | |_________-^^^^^^^^^^^^^^
   |
help: there is a method `exact_chunks_mut` with a similar name
   |
79 -         .par_chunks_mut(2)
79 +         .exact_chunks_mut(2)
   |

error[E0599]: no method named `par_chunks` found for reference `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` in the current scope
  --> src/Correlation.rs:80:19
   |
80 |         .zip(fft1.par_chunks(2))
   |                   ^^^^^^^^^^
   |
help: there is a method `exact_chunks` with a similar name
   |
80 -         .zip(fft1.par_chunks(2))
80 +         .zip(fft1.exact_chunks(2))
   |

error[E0599]: no method named `par_chunks` found for reference `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` in the current scope
  --> src/Correlation.rs:81:19
   |
81 |         .zip(fft2.par_chunks(2))
   |                   ^^^^^^^^^^
   |
help: there is a method `exact_chunks` with a similar name
   |
81 -         .zip(fft2.par_chunks(2))
81 +         .zip(fft2.exact_chunks(2))
   |

error[E0061]: this function takes 2 arguments but 4 arguments were supplied
   --> src/Correlation.rs:199:38
    |
199 |       let (mean1, mean2, std1, std2) = rayon::join(
    |                                        ^^^^^^^^^^^
...
202 | /         || {
203 | |             let mean1 = data1.iter().sum::<f64>() / n as f64;
204 | |             (data1.iter().map(|&x| (x - mean1).powi(2)).sum::<f64>() / n as f64).sqrt()
205 | |         },
    | |_________- unexpected argument #3 of type `{closure@src/Correlation.rs:202:9: 202:11}`
206 | /         || {
207 | |             let mean2 = data2.iter().sum::<f64>() / n as f64;
208 | |             (data2.iter().map(|&x| (x - mean2).powi(2)).sum::<f64>() / n as f64).sqrt()
209 | |         },
    | |_________- unexpected argument #4 of type `{closure@src/Correlation.rs:206:9: 206:11}`
    |
note: function defined here
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-core-1.13.0/src/join/mod.rs:93:8
    |
 93 | pub fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)
    |        ^^^^
help: remove the extra arguments
    |
201 -         || data2.iter().sum::<f64>() / n as f64,
202 -         || {
203 -             let mean1 = data1.iter().sum::<f64>() / n as f64;
204 -             (data1.iter().map(|&x| (x - mean1).powi(2)).sum::<f64>() / n as f64).sqrt()
205 -         },
201 +         || data2.iter().sum::<f64>() / n as f64,
    |

error[E0308]: mismatched types
   --> src/Correlation.rs:199:9
    |
199 |       let (mean1, mean2, std1, std2) = rayon::join(
    |  _________^^^^^^^^^^^^^^^^^^^^^^^^^^___-
    | |         |
    | |         expected a tuple with 2 elements, found one with 4 elements
200 | |         || data1.iter().sum::<f64>() / n as f64,
201 | |         || data2.iter().sum::<f64>() / n as f64,
202 | |         || {
...   |
209 | |         },
210 | |     );
    | |_____- this expression has type `(f64, f64)`
    |
    = note: expected tuple `(f64, f64)`
               found tuple `(_, _, _, _)`

error[E0599]: the method `zip` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
  --> src/Cos_FT.rs:38:10
   |
36 |       let partial_sums: Vec<f64> = (2..=half_n)
   |  __________________________________-
37 | |         .into_par_iter()
38 | |         .zip(rotation_factors.par_iter())
   | |_________-^^^
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
   |
45 |   pub struct Iter<T> {
   |   ------------------ doesn't satisfy `_: IndexedParallelIterator` or `rayon::range_inclusive::Iter<usize>: Iterator`
   |
   = note: the following trait bounds were not satisfied:
           `usize: range_inclusive::private::IndexedRangeInteger`
           which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`
           `rayon::range_inclusive::Iter<usize>: Iterator`
           which is required by `&mut rayon::range_inclusive::Iter<usize>: Iterator`

error[E0599]: the method `chunks` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
  --> src/Cos_FT.rs:97:32
   |
97 |     (2..=n>>1).into_par_iter().chunks(chunk_size).for_each(|chunk| {
   |                                ^^^^^^ method cannot be called on `rayon::range_inclusive::Iter<usize>` due to unsatisfied trait bounds
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
   |
45 | pub struct Iter<T> {
   | ------------------ doesn't satisfy `_: IndexedParallelIterator`
   |
   = note: the following trait bounds were not satisfied:
           `usize: range_inclusive::private::IndexedRangeInteger`
           which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`

error[E0689]: can't call method `to_bits` on ambiguous numeric type `{float}`
   --> src/Cos_FT.rs:123:40
    |
123 |         let local_sum_bits = local_sum.to_bits();
    |                                        ^^^^^^^
    |
help: you must specify a type for this binding, like `f32`
    |
100 |         let mut local_sum: f32 = 0.0;
    |                          +++++

error[E0599]: the method `into_par_iter` exists for struct `std::iter::StepBy<std::ops::RangeInclusive<usize>>`, but its trait bounds were not satisfied
  --> src/Cos_FT2.rs:66:10
   |
65 | /     (3..=n).step_by(2)
66 | |         .into_par_iter()
   | |_________-^^^^^^^^^^^^^
   |
  ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:16:1
   |
16 |   pub struct StepBy<I> {
   |   -------------------- doesn't satisfy `_: IntoParallelIterator` or `_: ParallelIterator`
   |
   = note: the following trait bounds were not satisfied:
           `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
           `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
           `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`

error[E0599]: the method `into_par_iter` exists for struct `std::iter::StepBy<std::ops::RangeInclusive<usize>>`, but its trait bounds were not satisfied
   --> src/Cos_FT2.rs:120:10
    |
119 | /     (3..=n).step_by(2)
120 | |         .into_par_iter()
    | |_________-^^^^^^^^^^^^^
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:16:1
    |
 16 |   pub struct StepBy<I> {
    |   -------------------- doesn't satisfy `_: IntoParallelIterator` or `_: ParallelIterator`
    |
    = note: the following trait bounds were not satisfied:
            `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
            `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
            `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`

error[E0599]: the method `chunks` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
   --> src/Cos_FT2.rs:142:34
    |
142 |     (1..=half_n).into_par_iter().chunks(chunk_size).for_each(|chunk| {
    |                                  ^^^^^^ method cannot be called on `rayon::range_inclusive::Iter<usize>` due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
    |
 45 | pub struct Iter<T> {
    | ------------------ doesn't satisfy `_: IndexedParallelIterator`
    |
    = note: the following trait bounds were not satisfied:
            `usize: range_inclusive::private::IndexedRangeInteger`
            which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`

error[E0600]: cannot apply unary operator `-` to type `usize`
  --> src/Cosine_Sine_Integrals.rs:79:17
   |
79 |         let a = -((i - 1) * (i - 1)) as f64;
   |                 ^^^^^^^^^^^^^^^^^^^^ cannot apply unary operator `-`
   |
   = note: unsigned values cannot be negated

error[E0599]: no method named `abs_diff` found for type `f64` in the current scope
   --> src/Cosine_Sine_Integrals.rs:274:22
    |
274 |         if del.abs().abs_diff(1.0) < EPS {
    |                      ^^^^^^^^ method not found in `f64`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<Vec<f64>, PolynomialDifferentiator>>`, but its trait bounds were not satisfied
   --> src/ddpoly.rs:171:15
    |
171 |         cache.entry(key.clone())
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<f64>: Hash` or `Vec<f64>: std::cmp::Eq`
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `Vec<f64>: std::cmp::Eq`
            `f64: Hash`
            which is required by `Vec<f64>: Hash`

error[E0599]: the method `get` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), (f64, f64)>>`, but its trait bounds were not satisfied
   --> src/dfridr.rs:122:42
    |
122 |             if let Some(&result) = cache.get(&key) {
    |                                          ^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0599]: the method `insert` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), (f64, f64)>>`, but its trait bounds were not satisfied
   --> src/dfridr.rs:133:19
    |
133 |             cache.insert(key, result);
    |                   ^^^^^^
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0277]: `F` cannot be shared between threads safely
   --> src/dfridr.rs:209:28
    |
209 |     let estimated = dfridr(func, x, h, &mut err);
    |                     ------ ^^^^ `F` cannot be shared between threads safely
    |                     |
    |                     required by a bound introduced by this call
    |
note: required by a bound in `dfridr`
   --> src/dfridr.rs:24:25
    |
 22 | pub fn dfridr<F>(func: F, x: f64, h: f64, err: &mut f64) -> f64 
    |        ------ required by a bound in this function
 23 | where
 24 |     F: Fn(f64) -> f64 + Sync + Send,
    |                         ^^^^ required by this bound in `dfridr`
help: use parentheses to call this type parameter
    |
209 |     let estimated = dfridr(func(/* f64 */), x, h, &mut err);
    |                                +++++++++++
help: consider further restricting type parameter `F` with trait `Sync`
    |
205 |     F: Fn(f64) -> f64 + std::marker::Sync,
    |                       +++++++++++++++++++

error[E0277]: `F` cannot be sent between threads safely
   --> src/dfridr.rs:209:28
    |
209 |     let estimated = dfridr(func, x, h, &mut err);
    |                     ------ ^^^^ `F` cannot be sent between threads safely
    |                     |
    |                     required by a bound introduced by this call
    |
note: required by a bound in `dfridr`
   --> src/dfridr.rs:24:32
    |
 22 | pub fn dfridr<F>(func: F, x: f64, h: f64, err: &mut f64) -> f64 
    |        ------ required by a bound in this function
 23 | where
 24 |     F: Fn(f64) -> f64 + Sync + Send,
    |                                ^^^^ required by this bound in `dfridr`
help: use parentheses to call this type parameter
    |
209 |     let estimated = dfridr(func(/* f64 */), x, h, &mut err);
    |                                +++++++++++
help: consider further restricting type parameter `F` with trait `Send`
    |
205 |     F: Fn(f64) -> f64 + std::marker::Send,
    |                       +++++++++++++++++++

error[E0277]: `*mut f64` cannot be shared between threads safely
   --> src/FFT_2.rs:105:41
    |
105 |       (1..max_k).into_par_iter().for_each(|k| {
    |                                  -------- ^--
    |                                  |        |
    |  ________________________________|________within this `{closure@src/FFT_2.rs:105:41: 105:44}`
    | |                                |
    | |                                required by a bound introduced by this call
106 | |         let j = 2 * k;
107 | |         if j >= n + 2 {
108 | |             return;
...   |
131 | |     });
    | |_____^ `*mut f64` cannot be shared between threads safely
    |
    = help: within `{closure@src/FFT_2.rs:105:41: 105:44}`, the trait `Sync` is not implemented for `*mut f64`
    = note: required because it appears within the type `&*mut f64`
note: required because it's used within this closure
   --> src/FFT_2.rs:105:41
    |
105 |     (1..max_k).into_par_iter().for_each(|k| {
    |                                         ^^^
note: required by a bound in `rayon::iter::ParallelIterator::for_each`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/iter/mod.rs:375:30
    |
373 |     fn for_each<OP>(self, op: OP)
    |        -------- required by a bound in this associated function
374 |     where
375 |         OP: Fn(Self::Item) + Sync + Send,
    |                              ^^^^ required by this bound in `ParallelIterator::for_each`

error[E0308]: arguments to this method are incorrect
   --> src/FFT_2.rs:262:18
    |
262 |             self.process(data1, data2, fft1, fft2);
    |                  ^^^^^^^               ----  ---- types differ in mutability
    |                                        |
    |                                        types differ in mutability
    |
    = note: expected mutable reference `&mut _`
                       found reference `&&mut _`
    = note: expected mutable reference `&mut _`
                       found reference `&&mut _`
note: method defined here
   --> src/FFT_2.rs:245:12
    |
245 |     pub fn process(&self, data1: &[f64], data2: &[f64], fft1: &mut [f64], fft2: &mut [f64]) {
    |            ^^^^^^^                                      ----------------  ----------------

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:279:32
    |
279 |         let amu0 = (alf + 1.0).gamma();
    |                                ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:298:60
    |
298 |         let amu0 = 2.0f64.powf(alfbet + 1.0) * (alf + 1.0).gamma() * (bet + 1.0).gamma() / 
    |                                                            ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:298:82
    |
298 |         let amu0 = 2.0f64.powf(alfbet + 1.0) * (alf + 1.0).gamma() * (bet + 1.0).gamma() / 
    |                                                                                  ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:299:35
    |
299 |                    (alfbet + 2.0).gamma();
    |                                   ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0599]: no method named `gammaln` found for type `f64` in the current scope
  --> src/gaujac.rs:98:40
   |
98 |         let log_num = (alf + n as f64).gammaln().0 + (bet + n as f64).gammaln().0;
   |                                        ^^^^^^^ method not found in `f64`

error[E0599]: no method named `gammaln` found for type `f64` in the current scope
  --> src/gaujac.rs:98:71
   |
98 |         let log_num = (alf + n as f64).gammaln().0 + (bet + n as f64).gammaln().0;
   |                                                                       ^^^^^^^ method not found in `f64`

error[E0599]: no method named `gammaln` found for type `f64` in the current scope
  --> src/gaujac.rs:99:40
   |
99 |         let log_den = (n as f64 + 1.0).gammaln().0 + (n as f64 + alfbet + 1.0).gammaln().0;
   |                                        ^^^^^^^ method not found in `f64`

error[E0599]: no method named `gammaln` found for type `f64` in the current scope
  --> src/gaujac.rs:99:80
   |
99 |         let log_den = (n as f64 + 1.0).gammaln().0 + (n as f64 + alfbet + 1.0).gammaln().0;
   |                                                                                ^^^^^^^ method not found in `f64`

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:194:44
    |
194 |             let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
    |                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:194:76
    |
194 |             let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
    |                                                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:195:44
    |
195 |             let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
    |                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:195:85
    |
195 |             let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
    |                                                                                     ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0599]: no method named `gammaln` found for type `f64` in the current scope
  --> src/gaulag.rs:82:43
   |
82 |         let log_weight = (alf + n as f64).gammaln().0 - (n as f64).gammaln().0;
   |                                           ^^^^^^^ method not found in `f64`

error[E0599]: no method named `gammaln` found for type `f64` in the current scope
  --> src/gaulag.rs:82:68
   |
82 |         let log_weight = (alf + n as f64).gammaln().0 - (n as f64).gammaln().0;
   |                                                                    ^^^^^^^ method not found in `f64`

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaulag.rs:152:47
    |
152 |             let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
    |                                               ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaulag.rs:152:73
    |
152 |             let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
    |                                                                         ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_i.rs:195:10
     |
 195 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `std::sync::Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 153 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_i.rs:300:10
     |
 300 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `std::sync::Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 266 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0600]: cannot apply unary operator `-` to type `usize`
   --> src/incomplete_gamma.rs:127:14
    |
127 |         an = -i as f32 * (i as f32 - a);
    |              ^^ cannot apply unary operator `-`
    |
    = note: unsigned values cannot be negated

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_I1.rs:179:10
     |
 179 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `std::sync::Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 147 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: cannot add `[{float}; 14]` to `{float}`
  --> src/Jacobian_elliptical.rs:34:27
   |
34 |         let mut c = 0.5*(a+em);
   |                           ^ no implementation for `{float} + [{float}; 14]`
   |
   = help: the trait `Add<[{float}; 14]>` is not implemented for `{float}`
   = help: the following other types implement trait `Add<Rhs>`:
             `&f128` implements `Add<f128>`
             `&f128` implements `Add`
             `&f16` implements `Add<f16>`
             `&f16` implements `Add`
             `&f32` implements `Add<&num_complex::Complex<f32>>`
             `&f32` implements `Add<&num_complex::Complex<f32>>`
             `&f32` implements `Add<f32>`
             `&f32` implements `Add<num_complex::Complex<f32>>`
           and 208 others

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_j.rs:314:10
     |
 314 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `std::sync::Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 282 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0689]: can't call method `max` on ambiguous numeric type `{float}`
   --> src/pade.rs:145:23
    |
145 |             big = big.max(a[[i, j]].abs());
    |                       ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
143 |         let mut big: f32 = 0.0;
    |                    +++++

error[E0689]: can't call method `max` on ambiguous numeric type `{float}`
   --> src/pade.rs:402:31
    |
402 |         max_error = max_error.max(error);
    |                               ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
380 |     let mut max_error: f32 = 0.0;
    |                      +++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_jy.rs:327:10
     |
 327 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `(T, T, T, T)` to implement `Debug`
     = note: 3 redundant requirements hidden
     = note: required for `std::sync::Arc<std::sync::Mutex<Vec<(T, T, T, T)>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 294 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0600]: cannot apply unary operator `!` to type `f64`
  --> src/polydiv.rs:19:13
   |
19 |     assert!(!v[0].abs() < f64::EPSILON, "Divisor leading coefficient cannot be zero");
   |             ^^^^^^^^^^^ cannot apply unary operator `!`

error[E0600]: cannot apply unary operator `!` to type `f64`
  --> src/polydiv.rs:54:13
   |
54 |     assert!(!v[0].abs() < f64::EPSILON, "Divisor leading coefficient cannot be zero");
   |             ^^^^^^^^^^^ cannot apply unary operator `!`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<Vec<f64>, PolynomialDivider>>`, but its trait bounds were not satisfied
   --> src/polydiv.rs:179:15
    |
179 |         cache.entry(key.clone())
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<f64>: Hash` or `Vec<f64>: std::cmp::Eq`
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `Vec<f64>: std::cmp::Eq`
            `f64: Hash`
            which is required by `Vec<f64>: Hash`

error[E0599]: no method named `clone` found for type parameter `F` in the current scope
   --> src/qgaus.rs:132:51
    |
109 | fn adaptive_recursive<F>(
    |                       - method `clone` not found for this type parameter
...
132 |         let left_result = adaptive_recursive(func.clone(), a, mid, left, tol, max_depth, depth + 1);
    |                                                   ^^^^^ method not found in `F`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use parentheses to call this type parameter
    |
132 |         let left_result = adaptive_recursive(func(/* f64 */).clone(), a, mid, left, tol, max_depth, depth + 1);
    |                                                  +++++++++++
help: the following trait defines an item `clone`, perhaps you need to restrict type parameter `F` with it:
    |
119 |     F: Fn(f64) -> f64 + Clone,
    |                       +++++++

error[E0277]: the trait bound `&F: Function3D` is not satisfied
   --> src/quad3d.rs:172:13
    |
171 |         return quad3d(
    |                ------ required by a bound introduced by this call
172 |             func.as_ref(),
    |             ^^^^^^^^^^^^^ the trait `Fn(f64, f64, f64)` is not implemented for `F`
    |
    = note: required for `&F` to implement `FnOnce(f64, f64, f64)`
note: required for `&F` to implement `Function3D`
   --> src/quad3d.rs:11:9
    |
 11 | impl<F> Function3D for F
    |         ^^^^^^^^^^     ^
 12 | where
 13 |     F: Fn(f64, f64, f64) -> f64 + Sync + Send,
    |                             --- unsatisfied trait bound introduced here
note: required by a bound in `quad3d`
   --> src/quad3d.rs:80:8
    |
 70 | pub fn quad3d<F, Y1, Y2, Z1, Z2>(
    |        ------ required by a bound in this function
...
 80 |     F: Function3D,
    |        ^^^^^^^^^^ required by this bound in `quad3d`
help: consider further restricting type parameter `F` with trait `Fn`
    |
163 |     F: Function3D + Fn(f64, f64, f64),
    |                   +++++++++++++++++++

error[E0599]: the method `take` exists for struct `rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>`, but its trait bounds were not satisfied
  --> src/random_0.rs:83:10
   |
78 | /     seeds.par_iter()
79 | |         .flat_map(|&s| {
80 | |             let mut rng = Ran0::new(s);
81 | |             rng.generate(chunk_size.min(n))
82 | |         })
83 | |         .take(n)
   | |_________-^^^^
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/iter/flat_map.rs:12:1
   |
12 |   pub struct FlatMap<I, F> {
   |   ------------------------ doesn't satisfy `_: Iterator`
   |
   = note: the following trait bounds were not satisfied:
           `rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>: Iterator`
           which is required by `&mut rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>: Iterator`

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_k1.rs:260:10
     |
 260 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `std::sync::Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 228 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0308]: mismatched types
    --> src/ratlsq.rs:199:38
     |
 199 |             best_cof.copy_from_slice(&coff);
     |                      --------------- ^^^^^ expected `&[{float}]`, found `&ArrayBase<OwnedRepr<f64>, ...>`
     |                      |
     |                      arguments to this method are incorrect
     |
     = note: expected reference `&[{float}]`
                found reference `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>`
note: method defined here
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3855:18
     |
3855 |     pub const fn copy_from_slice(&mut self, src: &[T])
     |                  ^^^^^^^^^^^^^^^

error[E0599]: no method named `get_unchecked` found for reference `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` in the current scope
   --> src/ratlsq.rs:346:39
    |
346 |     let mut numerator = unsafe { *cof.get_unchecked(mm) };
    |                                       ^^^^^^^^^^^^^
    |
help: there is a method `to_subset_unchecked` with a similar name, but with different arguments
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/alga-0.9.3/src/general/subset.rs:81:5
    |
 81 |     unsafe fn to_subset_unchecked(&self) -> T;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_unchecked` found for reference `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` in the current scope
   --> src/ratlsq.rs:348:51
    |
348 |         numerator = numerator * x + unsafe { *cof.get_unchecked(j) };
    |                                                   ^^^^^^^^^^^^^
    |
help: there is a method `to_subset_unchecked` with a similar name, but with different arguments
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/alga-0.9.3/src/general/subset.rs:81:5
    |
 81 |     unsafe fn to_subset_unchecked(&self) -> T;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_unchecked` found for reference `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` in the current scope
   --> src/ratlsq.rs:354:55
    |
354 |         denominator = denominator * x + unsafe { *cof.get_unchecked(j) };
    |                                                       ^^^^^^^^^^^^^
    |
help: there is a method `to_subset_unchecked` with a similar name, but with different arguments
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/alga-0.9.3/src/general/subset.rs:81:5
    |
 81 |     unsafe fn to_subset_unchecked(&self) -> T;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0423]: expected function, tuple struct or tuple variant, found module `Fourn`
  --> src/Real_FT3.rs:35:9
   |
35 |         Fourn(&mut flat_data, &nn, 3, isign);
   |         ^^^^^ not a function, tuple struct or tuple variant

error[E0423]: expected function, tuple struct or tuple variant, found module `Fourn`
   --> src/Real_FT3.rs:133:9
    |
133 |         Fourn(&mut flat_data, &nn, 3, isign);
    |         ^^^^^ not a function, tuple struct or tuple variant

error[E0423]: expected function, tuple struct or tuple variant, found module `Fourn`
   --> src/Real_FT3.rs:168:9
    |
168 |         Fourn(data, &[nn1, nn2, nn3_half], 3, isign);
    |         ^^^^^ not a function, tuple struct or tuple variant

error[E0423]: expected function, tuple struct or tuple variant, found module `Fourn`
   --> src/Real_FT3.rs:256:9
    |
256 |         Fourn(data, &[nn1, nn2, nn3_half], 3, isign);
    |         ^^^^^ not a function, tuple struct or tuple variant

error[E0015]: cannot call non-const method `std::f64::<impl f64>::sqrt` in constants
 --> src/spherical_bessel.rs:5:31
  |
5 | const RTPIO2: f64 = FRAC_PI_2.sqrt(); // √(π/2) ≈ 1.253314137
  |                               ^^^^^^
  |
  = note: calls in constants are limited to constant functions, tuple structs and tuple variants

error[E0308]: arguments to this function are incorrect
   --> src/splin2.rs:50:5
    |
 50 |     splint(x1a, &ytmp, &y2tmp, x1)
    |     ^^^^^^
    |
note: expected `ArrayBase<ViewRepr<&f64>, ...>`, found `&ArrayBase<OwnedRepr<f64>, ...>`
   --> src/splin2.rs:50:17
    |
 50 |     splint(x1a, &ytmp, &y2tmp, x1)
    |                 ^^^^^
    = note: expected struct `ArrayBase<ViewRepr<&f64>, _>`
            found reference `&ArrayBase<OwnedRepr<f64>, _>`
note: expected `ArrayBase<ViewRepr<&f64>, ...>`, found `&ArrayBase<OwnedRepr<f64>, ...>`
   --> src/splin2.rs:50:24
    |
 50 |     splint(x1a, &ytmp, &y2tmp, x1)
    |                        ^^^^^^
    = note: expected struct `ArrayBase<ViewRepr<&f64>, _>`
            found reference `&ArrayBase<OwnedRepr<f64>, _>`
note: function defined here
   --> src/splin2.rs:109:4
    |
109 | fn splint(
    |    ^^^^^^
110 |     x: &[f64],
111 |     y: ArrayView1<f64>,
    |     ------------------
112 |     y2: ArrayView1<f64>,
    |     -------------------
help: call `Into::into` on this expression to convert `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` into `ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>`
    |
 50 |     splint(x1a, (&ytmp).into(), &y2tmp, x1)
    |                 +     ++++++++
help: call `Into::into` on this expression to convert `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` into `ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>`
    |
 50 |     splint(x1a, &ytmp, (&y2tmp).into(), x1)
    |                        +      ++++++++

error[E0308]: arguments to this function are incorrect
   --> src/splin2.rs:218:5
    |
218 |     splint(x1, &ytmp, &y2tmp, x1_val)
    |     ^^^^^^
    |
note: expected `ArrayBase<ViewRepr<&f64>, ...>`, found `&ArrayBase<OwnedRepr<f64>, ...>`
   --> src/splin2.rs:218:16
    |
218 |     splint(x1, &ytmp, &y2tmp, x1_val)
    |                ^^^^^
    = note: expected struct `ArrayBase<ViewRepr<&f64>, _>`
            found reference `&ArrayBase<OwnedRepr<f64>, _>`
note: expected `ArrayBase<ViewRepr<&f64>, ...>`, found `&ArrayBase<OwnedRepr<f64>, ...>`
   --> src/splin2.rs:218:23
    |
218 |     splint(x1, &ytmp, &y2tmp, x1_val)
    |                       ^^^^^^
    = note: expected struct `ArrayBase<ViewRepr<&f64>, _>`
            found reference `&ArrayBase<OwnedRepr<f64>, _>`
note: function defined here
   --> src/splin2.rs:109:4
    |
109 | fn splint(
    |    ^^^^^^
110 |     x: &[f64],
111 |     y: ArrayView1<f64>,
    |     ------------------
112 |     y2: ArrayView1<f64>,
    |     -------------------
help: call `Into::into` on this expression to convert `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` into `ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>`
    |
218 |     splint(x1, (&ytmp).into(), &y2tmp, x1_val)
    |                +     ++++++++
help: call `Into::into` on this expression to convert `&ArrayBase<OwnedRepr<f64>, Dim<[usize; 1]>>` into `ArrayBase<ViewRepr<&f64>, Dim<[usize; 1]>>`
    |
218 |     splint(x1, &ytmp, (&y2tmp).into(), x1_val)
    |                       +      ++++++++

error[E0599]: no method named `to_vec` found for struct `IndPtrBase<Iptr, Storage>` in the current scope
  --> src/sprspm.rs:59:37
   |
59 |     let (mut ijc, sc) = (c.indptr().to_vec(), c.data().to_vec());
   |                                     ^^^^^^ method not found in `IndPtrBase<usize, &[usize]>`

error[E0282]: type annotations needed
  --> src/sprspm.rs:60:9
   |
60 |     ijc.insert(0, n);
   |         ^^^^^^ cannot infer type

warning: unused import: `Read`
 --> src/Four_FS.rs:2:31
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                               ^^^^

warning: unused import: `Write`
 --> src/Four_FS.rs:2:37
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                                     ^^^^^

warning: unused import: `Read`
 --> src/Fourn.rs:2:31
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                               ^^^^

warning: unused import: `Write`
 --> src/Fourn.rs:2:37
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                                     ^^^^^

warning: variable does not need to be mutable
   --> src/airy.rs:150:13
    |
150 |         let mut x = x - 1.0;
    |             ----^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `rj2`
   --> src/airy.rs:322:14
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |              ^^^
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
    |
322 |         let (_rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (constants::CBRT_EPSILON, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `ry2`
   --> src/airy.rs:322:19
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                   ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, _ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                   +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, constants::CBRT_EPSILON, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `rjp2`
   --> src/airy.rs:322:24
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                        ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, ry2, _rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, ry2, constants::CBRT_EPSILON, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `ryp2`
   --> src/airy.rs:322:30
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                              ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, ry2, rjp2, _ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, ry2, rjp2, constants::CBRT_EPSILON) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `u3`
   --> src/bcucof.rs:176:9
    |
176 |     let u3 = u2 * u;
    |         ^^
    |
help: if this is intentional, prefix it with an underscore
    |
176 |     let _u3 = u2 * u;
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
176 -     let u3 = u2 * u;
176 +     let constants::CBRT_EPSILON = u2 * u;
    |

error[E0599]: the method `entry` exists for struct `MutexGuard<'_, HashMap<(f64, f64, usize), Arc<...>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:227:15
    |
227 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64, usize): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64, usize): Hash`
    = note: the full name for the type has been written to '/home/archdabe/Documents/Numerical-recipies/Rust/numrs/target/debug/deps/num_rs-4326a34b13ba5736.long-type-6629107396749209997.txt'
    = note: consider using `--verbose` to print the full type name to the console

warning: unused variable: `x4`
  --> src/beschd.rs:91:9
   |
91 |     let x4 = x2 * x2;
   |         ^^ help: if this is intentional, prefix it with an underscore: `_x4`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), std::sync::Arc<ChebyshevOperator>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_calc.rs:293:15
    |
293 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), std::sync::Arc<ChebyshevOperator>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_calc.rs:306:15
    |
306 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

warning: unused variable: `x`
   --> src/bessel_jy.rs:282:11
    |
282 | fn beschd(x: f64) -> (f64, f64, f64, f64) {
    |           ^
    |
help: if this is intentional, prefix it with an underscore
    |
282 | fn beschd(_x: f64) -> (f64, f64, f64, f64) {
    |           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
282 - fn beschd(x: f64) -> (f64, f64, f64, f64) {
282 + fn beschd(constants::CBRT_EPSILON: f64) -> (f64, f64, f64, f64) {
    |

error[E0308]: mismatched types
   --> src/chebyshev_calc.rs:490:51
    |
490 |         assert!(verify_derivative(a, b, &c, sine, sine_deriv, 5, 1e-8));
    |                 -----------------           ----  ^^^^^^^^^^ expected fn item, found a different fn item
    |                 |                           |
    |                 |                           expected some other arguments to be a fn item type to match the type of this parameter
    |                 arguments to this function are incorrect
    |
    = note: expected fn item `fn(_) -> _ {chebyshev_calc::tests::sine}`
               found fn item `fn(_) -> _ {chebyshev_calc::tests::sine_deriv}`
    = note: different fn items have unique types, even if their signatures are the same
note: function defined here
   --> src/chebyshev_calc.rs:244:8
    |
244 | pub fn verify_derivative<F>(a: f64, b: f64, c: &[f64], func: F, deriv_func: F, n_test: usize, tol: f64) -> bool
    |        ^^^^^^^^^^^^^^^^^ -                             -------  ------------- this parameter needs to match the fn item type of `func`
    |                          |                             |
    |                          |                             `deriv_func` needs to match the fn item type of this parameter
    |                          `func` and `deriv_func` both reference this parameter `F`
    = help: consider casting both fn items to fn pointers using `as fn(f64) -> f64`

error[E0689]: can't call method `cos` on ambiguous numeric type `{float}`
   --> src/chebyshev_calc.rs:533:31
    |
533 |         let exact_deriv = 0.5.cos() - 0.5.sin(); // derivative of sin(x) + cos(x)
    |                               ^^^
    |
help: you must specify a concrete type for this numeric value, like `f32`
    |
533 |         let exact_deriv = 0.5_f32.cos() - 0.5.sin(); // derivative of sin(x) + cos(x)
    |                              ++++

error[E0689]: can't call method `sin` on ambiguous numeric type `{float}`
   --> src/chebyshev_calc.rs:533:43
    |
533 |         let exact_deriv = 0.5.cos() - 0.5.sin(); // derivative of sin(x) + cos(x)
    |                                           ^^^
    |
help: you must specify a concrete type for this numeric value, like `f32`
    |
533 |         let exact_deriv = 0.5.cos() - 0.5_f32.sin(); // derivative of sin(x) + cos(x)
    |                                          ++++

warning: unused variable: `expected`
   --> src/bessel_yn.rs:391:9
    |
391 |     let expected = 2.0 / (PI * x);
    |         ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
391 |     let _expected = 2.0 / (PI * x);
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
391 -     let expected = 2.0 / (PI * x);
391 +     let constants::CBRT_EPSILON = 2.0 / (PI * x);
    |

warning: unused variable: `i`
  --> src/bessik.rs:51:9
   |
51 |     for i in 1..=MAXIT {
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
51 |     for _i in 1..=MAXIT {
   |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
51 -     for i in 1..=MAXIT {
51 +     for constants::MAX_ITERATIONS in 1..=MAXIT {
   |

warning: unused variable: `x`
  --> src/bessik.rs:41:30
   |
41 | fn bessik_continued_fraction(x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |                              ^
   |
help: if this is intentional, prefix it with an underscore
   |
41 | fn bessik_continued_fraction(_x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
41 - fn bessik_continued_fraction(x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
41 + fn bessik_continued_fraction(constants::CBRT_EPSILON: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |

error[E0689]: can't call method `sqrt` on ambiguous numeric type `{float}`
   --> src/cholesky.rs:180:48
    |
180 |         assert_abs_diff_eq!(p[1], (5.0 - 0.25).sqrt(), epsilon = 1e-6);
    |                                                ^^^^

warning: variable does not need to be mutable
  --> src/bessik.rs:59:17
   |
59 |             let mut ril = FPMIN;
   |                 ----^^^
   |                 |
   |                 help: remove this `mut`

warning: variable does not need to be mutable
  --> src/bessik.rs:60:17
   |
60 |             let mut ripl = h * ril;
   |                 ----^^^^
   |                 |
   |                 help: remove this `mut`

warning: unused variable: `l`
   --> src/bessik.rs:176:9
    |
176 |     for l in (1..=nl).rev() {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
176 |     for _l in (1..=nl).rev() {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
    |
176 -     for l in (1..=nl).rev() {
176 +     for bessel_jy::MAXIT in (1..=nl).rev() {
    |

warning: variable does not need to be mutable
   --> src/bessik.rs:223:9
    |
223 |     let mut gam1 = chebyshev_eval(xx, &coef1);
    |         ----^^^^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/bessik.rs:224:9
    |
224 |     let mut gam2 = chebyshev_eval(xx, &coef2);
    |         ----^^^^
    |         |
    |         help: remove this `mut`

error[E0689]: can't call method `sqrt` on ambiguous numeric type `{float}`
   --> src/cholesky.rs:230:40
    |
230 |         let p = vec![2.0, (5.0 - 0.25).sqrt()];
    |                                        ^^^^

warning: variable does not need to be mutable
  --> src/beta.rs:29:9
   |
29 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `y`
   --> src/bico.rs:106:13
    |
106 |     let mut y = x;
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
106 |     let mut _y = x;
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
106 -     let mut y = x;
106 +     let mut constants::CBRT_EPSILON = x;
    |

warning: variable does not need to be mutable
   --> src/bico.rs:106:9
    |
106 |     let mut y = x;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: unused variable: `x`
   --> src/Carlson_elliptic_integral_third.rs:155:11
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |           ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Carlson_elliptic_integral_third.rs:155:19
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                   ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |                   +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Carlson_elliptic_integral_third.rs:155:27
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                           ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `func`
   --> src/chebyshev_calc.rs:244:56
    |
244 | pub fn verify_derivative<F>(a: f64, b: f64, c: &[f64], func: F, deriv_func: F, n_test: usize, tol: f64) -> bool
    |                                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_func`

warning: unused variable: `sum_prod`
   --> src/Correlation.rs:236:40
    |
236 |     let (sum1, sum2, sum_sq1, sum_sq2, sum_prod) = data1.iter().zip(data2.iter()).fold(
    |                                        ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
236 |     let (sum1, sum2, sum_sq1, sum_sq2, _sum_prod) = data1.iter().zip(data2.iter()).fold(
    |                                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
236 -     let (sum1, sum2, sum_sq1, sum_sq2, sum_prod) = data1.iter().zip(data2.iter()).fold(
236 +     let (sum1, sum2, sum_sq1, sum_sq2, constants::CBRT_EPSILON) = data1.iter().zip(data2.iter()).fold(
    |

warning: unused variable: `data`
  --> src/Cos_FT.rs:71:11
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |           ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `n`
  --> src/Cos_FT.rs:71:29
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |                             ^
   |
help: if this is intentional, prefix it with an underscore
   |
71 | fn realft(data: &mut [f64], _n: usize, isign: i32) {
   |                             +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
71 - fn realft(data: &mut [f64], n: usize, isign: i32) {
71 + fn realft(data: &mut [f64], constants::MAX_ITERATIONS: usize, isign: i32) {
   |

warning: unused variable: `isign`
  --> src/Cos_FT.rs:71:39
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |                                       ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
71 | fn realft(data: &mut [f64], n: usize, _isign: i32) {
   |                                       +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
71 - fn realft(data: &mut [f64], n: usize, isign: i32) {
71 + fn realft(data: &mut [f64], n: usize, bessel_jy::MAXIT: i32) {
   |

warning: unused variable: `data`
   --> src/Cos_FT2.rs:194:11
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |           ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `n`
   --> src/Cos_FT2.rs:194:29
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |                             ^
    |
help: if this is intentional, prefix it with an underscore
    |
194 | fn realft(data: &mut [f64], _n: usize, isign: i32) {
    |                             +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
194 - fn realft(data: &mut [f64], n: usize, isign: i32) {
194 + fn realft(data: &mut [f64], constants::MAX_ITERATIONS: usize, isign: i32) {
    |

warning: unused variable: `isign`
   --> src/Cos_FT2.rs:194:39
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |                                       ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
194 | fn realft(data: &mut [f64], n: usize, _isign: i32) {
    |                                       +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
    |
194 - fn realft(data: &mut [f64], n: usize, isign: i32) {
194 + fn realft(data: &mut [f64], n: usize, bessel_jy::MAXIT: i32) {
    |

warning: unused variable: `theta_vec`
   --> src/Cos_FT2.rs:209:13
    |
209 |         let theta_vec = _mm256_set1_pd(theta);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_theta_vec`

warning[E0133]: call to function `std::arch::x86_64::_mm256_set1_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:200:25
    |
200 |             let x_vec = _mm256_set1_pd(x);
    |                         ^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx
note: an unsafe function restricts its caller, but its body is safe by default
   --> src/ddpoly.rs:184:1
    |
184 | pub unsafe fn ddpoly_simd(c: &[f64], x: f64, nd: usize) -> Vec<f64> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(unsafe_op_in_unsafe_fn)]` (part of `#[warn(rust_2024_compatibility)]`) on by default

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:204:28
    |
204 |                 let pd_j = _mm256_loadu_pd(pd.as_ptr().add(j - 3));
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::const_ptr::<impl *const T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:204:44
    |
204 |                 let pd_j = _mm256_loadu_pd(pd.as_ptr().add(j - 3));
    |                                            ^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:205:36
    |
205 |                 let pd_j_minus_1 = _mm256_loadu_pd(pd.as_ptr().add(j - 4));
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::const_ptr::<impl *const T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:205:52
    |
205 |                 let pd_j_minus_1 = _mm256_loadu_pd(pd.as_ptr().add(j - 4));
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to function `std::arch::x86_64::_mm256_mul_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:207:31
    |
207 |                 let product = _mm256_mul_pd(pd_j, x_vec);
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx

warning[E0133]: call to function `std::arch::x86_64::_mm256_add_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:208:30
    |
208 |                 let result = _mm256_add_pd(product, pd_j_minus_1);
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_storeu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:210:17
    |
210 |                 _mm256_storeu_pd(pd.as_mut_ptr().add(j - 3), result);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::mut_ptr::<impl *mut T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:210:34
    |
210 |                 _mm256_storeu_pd(pd.as_mut_ptr().add(j - 3), result);
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning: variable `factorial` is assigned to, but never used
   --> src/ei.rs:137:13
    |
137 |     let mut factorial = 1.0;
    |             ^^^^^^^^^
    |
    = note: consider using `_factorial` instead
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
137 -     let mut factorial = 1.0;
137 +     let mut constants::CBRT_EPSILON = 1.0;
    |

warning: unused variable: `k_prime`
   --> src/Elliptical_Legendre_First.rs:172:9
    |
172 |     let k_prime = (1.0 - k * k).sqrt();
    |         ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
172 |     let _k_prime = (1.0 - k * k).sqrt();
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
172 -     let k_prime = (1.0 - k * k).sqrt();
172 +     let constants::CBRT_EPSILON = (1.0 - k * k).sqrt();
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_First.rs:222:7
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_First.rs:222:15
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_First.rs:222:23
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_Second.rs:232:7
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_Second.rs:232:15
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_Second.rs:232:23
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_Second.rs:238:7
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_Second.rs:238:15
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_Second.rs:238:23
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: variable does not need to be mutable
   --> src/error_functions.rs:110:9
    |
110 |     let mut x = x - 1.0;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/eulsum.rs:158:21
    |
158 |                 let mut euler = instance.lock().unwrap();
    |                     ----^^^^^
    |                     |
    |                     help: remove this `mut`

warning: variable does not need to be mutable
   --> src/exponential_integral.rs:175:9
    |
175 |     let mut result = (-x).exp() / x;
    |         ----^^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `y`
   --> src/factrl.rs:212:13
    |
212 |     let mut y = x;
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
212 |     let mut _y = x;
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
212 -     let mut y = x;
212 +     let mut constants::CBRT_EPSILON = x;
    |

warning: variable does not need to be mutable
   --> src/factrl.rs:212:9
    |
212 |     let mut y = x;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: unused variable: `isign`
  --> src/FFT_1.rs:47:100
   |
47 | fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                                                    ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
47 | fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, _isign: i32) {
   |                                                                                                    +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
47 - fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
47 + fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, bessel_jy::MAXIT: i32) {
   |

warning: unused variable: `wpr`
  --> src/FFT_1.rs:75:78
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                              ^^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, _wpr: f64, wpi: f64, isign: i32) {
   |                                                                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 - fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
75 + fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, constants::CBRT_EPSILON: f64, wpi: f64, isign: i32) {
   |

warning: unused variable: `wpi`
  --> src/FFT_1.rs:75:88
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                                        ^^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, _wpi: f64, isign: i32) {
   |                                                                                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 - fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
75 + fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, constants::CBRT_EPSILON: f64, isign: i32) {
   |

error[E0596]: cannot borrow `*fft1` as mutable, as it is a captured variable in a `Fn` closure
  --> src/FFT_2.rs:44:28
   |
44 |             let fft1_ptr = fft1.as_mut_ptr();
   |                            ^^^^ cannot borrow as mutable

warning: unused variable: `state`
  --> src/Four_FS.rs:78:9
   |
78 |         state: &mut FFTState,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `file_state`
  --> src/Four_FS.rs:79:9
   |
79 |         file_state: &mut FileState,
   |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_file_state`

warning: unused variable: `isign`
  --> src/Four_FS.rs:80:9
   |
80 |         isign: i32,
   |         ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
80 |         _isign: i32,
   |         +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
80 -         isign: i32,
80 +         bessel_jy::MAXIT: i32,
   |

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/Fourn.rs:302:32
    |
302 |                 let data_vec = _mm256_loadu_pd(chunk.as_ptr());
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior
note: an unsafe function restricts its caller, but its body is safe by default
   --> src/Fourn.rs:278:1
    |
278 | pub unsafe fn fourn_simd(data: &mut [f64], nn: &[usize], ndim: usize, isign: i32) -> Result<(), Error> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_storeu_pd` is unsafe and requires unsafe block
   --> src/Fourn.rs:309:17
    |
309 |                 _mm256_storeu_pd(chunk.as_mut_ptr(), result_vec);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning: unused variable: `k`
   --> src/frenel.rs:121:9
    |
121 |     for k in 2..=MAXIT {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
121 |     for _k in 2..=MAXIT {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
121 -     for k in 2..=MAXIT {
121 +     for constants::MAX_ITERATIONS in 2..=MAXIT {
    |

warning: variable does not need to be mutable
  --> src/gamma_continued_funciton.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `gln`
   --> src/gamma_continued_funciton.rs:191:17
    |
191 |         let (p, gln) = super::gamma_series::gamma_series(a, x)?;
    |                 ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
191 |         let (p, _gln) = super::gamma_series::gamma_series(a, x)?;
    |                 +
help: you might have meant to pattern match on the similarly named constant `LARGE`
    |
191 -         let (p, gln) = super::gamma_series::gamma_series(a, x)?;
191 +         let (p, spline::LARGE) = super::gamma_series::gamma_series(a, x)?;
    |

warning: unused variable: `gln`
   --> src/gamma_continued_funciton.rs:195:17
    |
195 |         let (q, gln) = gamma_continued_fraction(a, x)?;
    |                 ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
195 |         let (q, _gln) = gamma_continued_fraction(a, x)?;
    |                 +
help: you might have meant to pattern match on the similarly named constant `LARGE`
    |
195 -         let (q, gln) = gamma_continued_fraction(a, x)?;
195 +         let (q, spline::LARGE) = gamma_continued_fraction(a, x)?;
    |

warning: variable does not need to be mutable
  --> src/gamma_series.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `n`
  --> src/gamma_series.rs:67:9
   |
67 |     for n in 1..=MAX_ITER {
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
67 |     for _n in 1..=MAX_ITER {
   |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
67 -     for n in 1..=MAX_ITER {
67 +     for constants::MAX_ITERATIONS in 1..=MAX_ITER {
   |

warning: unused variable: `n`
   --> src/gamma_series.rs:175:9
    |
175 |     for n in 1..=MAX_ITER {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
175 |     for _n in 1..=MAX_ITER {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
175 -     for n in 1..=MAX_ITER {
175 +     for constants::MAX_ITERATIONS in 1..=MAX_ITER {
    |

warning: unused variable: `y`
  --> src/gammln.rs:44:13
   |
44 |     let mut y = x;
   |             ^
   |
help: if this is intentional, prefix it with an underscore
   |
44 |     let mut _y = x;
   |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
44 -     let mut y = x;
44 +     let mut constants::CBRT_EPSILON = x;
   |

warning: variable does not need to be mutable
  --> src/gammln.rs:44:9
   |
44 |     let mut y = x;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `b`
   --> src/gaucof.rs:162:21
    |
162 |                 let b = c * e[i];
    |                     ^
    |
help: if this is intentional, prefix it with an underscore
    |
162 |                 let _b = c * e[i];
    |                     +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
162 -                 let b = c * e[i];
162 +                 let constants::CBRT_EPSILON = c * e[i];
    |

warning: variable does not need to be mutable
   --> src/gaucof.rs:129:13
    |
129 |         let mut m = l;
    |             ----^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:146:17
    |
146 |             let mut g = d[l];
    |                 ----^
    |                 |
    |                 help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:147:17
    |
147 |             let mut p = (d[m] - g) / (2.0 * e[l]);
    |                 ----^
    |                 |
    |                 help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:241:13
    |
241 |         let mut a = vec![0.0; n];
    |             ----^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:255:13
    |
255 |         let mut a = vec![0.0; n];
    |             ----^
    |             |
    |             help: remove this `mut`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<Vec<f64>, ddpoly::PolynomialDifferentiator>>`, but its trait bounds were not satisfied
   --> src/ddpoly.rs:171:15
    |
171 |         cache.entry(key.clone())
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<f64>: Hash` or `Vec<f64>: std::cmp::Eq`
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `Vec<f64>: std::cmp::Eq`
            `f64: Hash`
            which is required by `Vec<f64>: Hash`

warning: value assigned to `pp` is never read
  --> src/gauher.rs:56:17
   |
56 |         let mut pp = 0.0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p1`
  --> src/gauher.rs:75:14
   |
75 |         let (p1, pp) = hermite_polynomial(n, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 |         let (_p1, pp) = hermite_polynomial(n, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 -         let (p1, pp) = hermite_polynomial(n, z);
75 +         let (constants::CBRT_EPSILON, pp) = hermite_polynomial(n, z);
   |

warning: value assigned to `pp` is never read
   --> src/gauher.rs:129:17
    |
129 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p1`
   --> src/gauher.rs:145:18
    |
145 |             let (p1, pp) = hermite_polynomial(n, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
145 |             let (_p1, pp) = hermite_polynomial(n, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
145 -             let (p1, pp) = hermite_polynomial(n, z);
145 +             let (constants::CBRT_EPSILON, pp) = hermite_polynomial(n, z);
    |

warning: unused variable: `x`
   --> src/gauher.rs:268:24
    |
268 |     pub fn constant_fn(x: f64) -> f64 {
    |                        ^
    |
help: if this is intentional, prefix it with an underscore
    |
268 |     pub fn constant_fn(_x: f64) -> f64 {
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
268 -     pub fn constant_fn(x: f64) -> f64 {
268 +     pub fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: value assigned to `pp` is never read
   --> src/gaujac.rs:177:17
    |
177 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
   --> src/gaujac.rs:180:22
    |
180 |             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |                      ^^
    |
help: if this is intentional, prefix it with an underscore
    |
180 |             let (p1, _p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
180 -             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
180 +             let (p1, constants::CBRT_EPSILON, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |

warning: unused variable: `p1`
   --> src/gaujac.rs:193:18
    |
193 |             let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
193 |             let (_p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
193 -             let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
193 +             let (constants::CBRT_EPSILON, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |

warning: value assigned to `pp` is never read
   --> src/gaulag.rs:135:17
    |
135 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
   --> src/gaulag.rs:138:22
    |
138 |             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
    |                      ^^
    |
help: if this is intentional, prefix it with an underscore
    |
138 |             let (p1, _p2, new_pp) = laguerre_polynomial(n, alf, z);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
138 -             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
138 +             let (p1, constants::CBRT_EPSILON, new_pp) = laguerre_polynomial(n, alf, z);
    |

warning: unused variable: `p1`
   --> src/gaulag.rs:151:18
    |
151 |             let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
151 |             let (_p1, p2, pp) = laguerre_polynomial(n, alf, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
151 -             let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
151 +             let (constants::CBRT_EPSILON, p2, pp) = laguerre_polynomial(n, alf, z);
    |

warning: unused variable: `key`
   --> src/gaulag.rs:182:13
    |
182 |         let key = (n, alf.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `key`
   --> src/gaulag.rs:198:13
    |
198 |         let key = (n, alf.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `x`
   --> src/gaulag.rs:291:24
    |
291 |     pub fn constant_fn(x: f64) -> f64 {
    |                        ^
    |
help: if this is intentional, prefix it with an underscore
    |
291 |     pub fn constant_fn(_x: f64) -> f64 {
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
291 -     pub fn constant_fn(x: f64) -> f64 {
291 +     pub fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `p1`
  --> src/gauleg.rs:67:14
   |
67 |         let (p1, pp) = legendre_polynomial(n, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
67 |         let (_p1, pp) = legendre_polynomial(n, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
67 -         let (p1, pp) = legendre_polynomial(n, z);
67 +         let (constants::CBRT_EPSILON, pp) = legendre_polynomial(n, z);
   |

warning: unused variable: `p1`
   --> src/gauleg.rs:126:18
    |
126 |             let (p1, pp) = legendre_polynomial(n, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
126 |             let (_p1, pp) = legendre_polynomial(n, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
126 -             let (p1, pp) = legendre_polynomial(n, z);
126 +             let (constants::CBRT_EPSILON, pp) = legendre_polynomial(n, z);
    |

warning: unused variable: `key`
   --> src/gauleg.rs:158:13
    |
158 |         let key = (n, x1.to_bits(), x2.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

error[E0277]: `F` cannot be shared between threads safely
   --> src/dfridr.rs:209:28
    |
209 |     let estimated = dfridr(func, x, h, &mut err);
    |                     ------ ^^^^ `F` cannot be shared between threads safely
    |                     |
    |                     required by a bound introduced by this call
    |
note: required by a bound in `dfridr::dfridr`
   --> src/dfridr.rs:24:25
    |
 22 | pub fn dfridr<F>(func: F, x: f64, h: f64, err: &mut f64) -> f64 
    |        ------ required by a bound in this function
 23 | where
 24 |     F: Fn(f64) -> f64 + Sync + Send,
    |                         ^^^^ required by this bound in `dfridr`
help: use parentheses to call this type parameter
    |
209 |     let estimated = dfridr(func(/* f64 */), x, h, &mut err);
    |                                +++++++++++
help: consider further restricting type parameter `F` with trait `Sync`
    |
205 |     F: Fn(f64) -> f64 + std::marker::Sync,
    |                       +++++++++++++++++++

warning: unused variable: `key`
   --> src/gauleg.rs:173:13
    |
173 |         let key = (n, x1.to_bits(), x2.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

error[E0277]: `F` cannot be sent between threads safely
   --> src/dfridr.rs:209:28
    |
209 |     let estimated = dfridr(func, x, h, &mut err);
    |                     ------ ^^^^ `F` cannot be sent between threads safely
    |                     |
    |                     required by a bound introduced by this call
    |
note: required by a bound in `dfridr::dfridr`
   --> src/dfridr.rs:24:32
    |
 22 | pub fn dfridr<F>(func: F, x: f64, h: f64, err: &mut f64) -> f64 
    |        ------ required by a bound in this function
 23 | where
 24 |     F: Fn(f64) -> f64 + Sync + Send,
    |                                ^^^^ required by this bound in `dfridr`
help: use parentheses to call this type parameter
    |
209 |     let estimated = dfridr(func(/* f64 */), x, h, &mut err);
    |                                +++++++++++
help: consider further restricting type parameter `F` with trait `Send`
    |
205 |     F: Fn(f64) -> f64 + std::marker::Send,
    |                       +++++++++++++++++++

warning: variable does not need to be mutable
  --> src/inc_beta_func.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

error[E0689]: can't call method `ln` on ambiguous numeric type `{float}`
   --> src/ei.rs:196:57
    |
196 |         assert_relative_eq!(ei(1e-10).unwrap(), (1e-10).ln() + E, epsilon = 1e-6);
    |                                                         ^^
    |
help: you must specify a concrete type for this numeric value, like `f32`
    |
196 |         assert_relative_eq!(ei(1e-10).unwrap(), (1e-10_f32).ln() + E, epsilon = 1e-6);
    |                                                       ++++

warning: variable does not need to be mutable
  --> src/incomplete_gamma.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

error[E0689]: can't call method `ln` on ambiguous numeric type `{float}`
   --> src/ei.rs:197:55
    |
197 |         assert_relative_eq!(ei(1e-5).unwrap(), (1e-5).ln() + E, epsilon = 1e-6);
    |                                                       ^^
    |
help: you must specify a concrete type for this numeric value, like `f32`
    |
197 |         assert_relative_eq!(ei(1e-5).unwrap(), (1e-5_f32).ln() + E, epsilon = 1e-6);
    |                                                     ++++

warning: variable does not need to be mutable
   --> src/Jacobian_elliptical.rs:175:17
    |
175 |             let mut u_scaled = u * self.c;
    |                 ----^^^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: value assigned to `err` is never read
  --> src/linbcg.rs:57:13
   |
57 |     let mut err = 0.0;
   |             ^^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `zm1nrm` is never read
  --> src/linbcg.rs:85:13
   |
85 |     let mut zm1nrm = 0.0;
   |             ^^^^^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `current_result` is never read
   --> src/midsqu.rs:114:13
    |
114 |     let mut current_result = 0.0;
    |             ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `d`
  --> src/pade.rs:54:9
   |
54 |     let d = ludcmp(&mut qlu, &mut indx);
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
54 |     let _d = ludcmp(&mut qlu, &mut indx);
   |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
54 -     let d = ludcmp(&mut qlu, &mut indx);
54 +     let constants::CBRT_EPSILON = ludcmp(&mut qlu, &mut indx);
   |

warning: unused variable: `d`
   --> src/pade.rs:332:9
    |
332 |     let d = ludcmp(&mut ws.qlu, &mut ws.indx);
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
332 |     let _d = ludcmp(&mut ws.qlu, &mut ws.indx);
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
332 -     let d = ludcmp(&mut ws.qlu, &mut ws.indx);
332 +     let constants::CBRT_EPSILON = ludcmp(&mut ws.qlu, &mut ws.indx);
    |

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:205:22
    |
205 |         let qk_vec = unsafe { _mm256_set1_pd(q[k]) };
    |                      ^^^^^^ unnecessary `unsafe` block
    |
    = note: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:212:27
    |
212 |             let product = unsafe { _mm256_mul_pd(qk_vec, v_vec) };
    |                           ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:213:26
    |
213 |             let result = unsafe { _mm256_sub_pd(r_vec, product) };
    |                          ^^^^^^ unnecessary `unsafe` block

error[E0689]: can't call method `exp` on ambiguous numeric type `{float}`
   --> src/exponential_integral.rs:222:61
    |
222 |         assert_relative_eq!(expint(0, 1.0).unwrap(), (-1.0).exp() / 1.0, epsilon = 1e-10);
    |                                                             ^^^

warning: variable `sum` is assigned to, but never used
   --> src/qromo.rs:192:17
    |
192 |         let mut sum = 0.0;
    |                 ^^^
    |
    = note: consider using `_sum` instead
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
192 -         let mut sum = 0.0;
192 +         let mut constants::CBRT_EPSILON = 0.0;
    |

warning: value assigned to `iy` is never read
  --> src/random_1.rs:32:17
   |
32 |         let mut iy = 0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `iy` is never read
  --> src/random_2.rs:39:17
   |
39 |         let mut iy = 0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: variable does not need to be mutable
  --> src/random_2.rs:37:13
   |
37 |         let mut idum2 = idum1;
   |             ----^^^^^
   |             |
   |             help: remove this `mut`

warning: unused variable: `k`
  --> src/random_3.rs:39:17
   |
39 |             for k in 1..=4 {
   |                 ^
   |
help: if this is intentional, prefix it with an underscore
   |
39 |             for _k in 1..=4 {
   |                 +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
39 -             for k in 1..=4 {
39 +             for bessel_jy::MAXIT in 1..=4 {
   |

warning: unused variable: `ndim`
   --> src/spherical_bessel.rs:317:9
    |
317 |     let ndim = 1.0 / (x * x);
    |         ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
317 |     let _ndim = 1.0 / (x * x);
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
317 -     let ndim = 1.0 / (x * x);
317 +     let constants::CBRT_EPSILON = 1.0 / (x * x);
    |

warning: variable does not need to be mutable
  --> src/splie2.rs:33:13
   |
33 |         let mut y2_row = y2a.row_mut(j);
   |             ----^^^^^^
   |             |
   |             help: remove this `mut`

warning: unused variable: `m`
   --> src/splie2.rs:131:9
    |
131 |     let m = x1a.len();
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
131 |     let _m = x1a.len();
    |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
131 -     let m = x1a.len();
131 +     let constants::MAX_ITERATIONS = x1a.len();
    |

warning: unused variable: `m`
  --> src/splin2.rs:79:9
   |
79 |     let m = x1a.len();
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
79 |     let _m = x1a.len();
   |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
79 -     let m = x1a.len();
79 +     let constants::MAX_ITERATIONS = x1a.len();
   |

warning: unused variable: `n`
  --> src/splin2.rs:80:9
   |
80 |     let n = x2a.len();
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
80 |     let _n = x2a.len();
   |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
80 -     let n = x2a.len();
80 +     let constants::MAX_ITERATIONS = x2a.len();
   |

error[E0308]: mismatched types
   --> src/gamma_series.rs:248:36
    |
248 |         let result1 = gamma_series(2, 1.0).unwrap().0;
    |                       ------------ ^ expected `f32`, found integer
    |                       |
    |                       arguments to this function are incorrect
    |
note: function defined here
   --> src/gamma_series.rs:45:8
    |
 45 | pub fn gamma_series(a: f32, x: f32) -> Result<(f32, f32), String> {
    |        ^^^^^^^^^^^^ ------
help: use a float literal
    |
248 |         let result1 = gamma_series(2.0, 1.0).unwrap().0;
    |                                     ++

error[E0689]: can't call method `ln` on ambiguous numeric type `{float}`
   --> src/gammln.rs:382:61
    |
382 |         assert_abs_diff_eq!(gammln(3.0), 0.6931471805599453.ln(), epsilon = 1e-10);
    |                                                             ^^
    |
help: you must specify a concrete type for this numeric value, like `f32`
    |
382 |         assert_abs_diff_eq!(gammln(3.0), 0.6931471805599453_f32.ln(), epsilon = 1e-10);
    |                                                            ++++

Some errors have detailed explanations: E0015, E0061, E0133, E0277, E0282, E0308, E0369, E0423, E0596...
For more information about an error, try `rustc --explain E0015`.
error: could not compile `num_rs` (lib) due to 92 previous errors; 204 warnings emitted
error[E0658]: use of unstable library feature `float_gamma`
   --> src/gauher.rs:395:39
    |
395 |                 (degree as f64 + 1.0).gamma() / 2.0f64.powf(degree as f64 / 2.0 + 0.5) * std::f64::consts::PI.sqrt()
    |                                       ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:420:71
    |
420 |             let expected = 2.0f64.powf(alf + bet + 1.0) * (alf + 1.0).gamma() * (bet + 1.0).gamma()
    |                                                                       ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:420:93
    |
420 |             let expected = 2.0f64.powf(alf + bet + 1.0) * (alf + 1.0).gamma() * (bet + 1.0).gamma()
    |                                                                                             ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:421:37
    |
421 |                 / (alf + bet + 2.0).gamma();
    |                                     ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0689]: can't call method `gamma` on ambiguous numeric type `{float}`
   --> src/gaujac.rs:510:69
    |
510 |         let expected = 2.0f64.powf(-0.5 - 0.5 + 1.0) * (-0.5 + 1.0).gamma() * (-0.5 + 1.0).gamma()
    |                                                                     ^^^^^

error[E0689]: can't call method `gamma` on ambiguous numeric type `{float}`
   --> src/gaujac.rs:510:92
    |
510 |         let expected = 2.0f64.powf(-0.5 - 0.5 + 1.0) * (-0.5 + 1.0).gamma() * (-0.5 + 1.0).gamma()
    |                                                                                            ^^^^^

error[E0689]: can't call method `gamma` on ambiguous numeric type `{float}`
   --> src/gaujac.rs:511:34
    |
511 |             / (-0.5 - 0.5 + 2.0).gamma();
    |                                  ^^^^^

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaulag.rs:402:40
    |
402 |             let expected = (alf + 1.0).gamma();
    |                                        ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaulag.rs:423:41
    |
423 |             let exact = (degree as f64).gamma();
    |                                         ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0689]: can't call method `gamma` on ambiguous numeric type `{float}`
   --> src/gaulag.rs:459:37
    |
459 |         let expected = (-0.5 + 1.0).gamma();
    |                                     ^^^^^

error[E0689]: can't call method `ln_gamma` on ambiguous numeric type `{float}`
   --> src/gaulag.rs:477:28
    |
477 |         let ln_gamma = 2.5.ln_gamma().0;
    |                            ^^^^^^^^
    |
help: you must specify a concrete type for this numeric value, like `f32`
    |
477 |         let ln_gamma = 2.5_f32.ln_gamma().0;
    |                           ++++

error[E0282]: type annotations needed for `Vec<_>`
   --> src/linbcg.rs:369:13
    |
369 |         let mut residuals = Vec::new();
    |             ^^^^^^^^^^^^^   ---------- type must be known at this point
    |
help: consider giving `residuals` an explicit type, where the type for type parameter `T` is specified
    |
369 |         let mut residuals: Vec<T> = Vec::new();
    |                          ++++++++

error[E0308]: arguments to this function are incorrect
   --> src/polcof.rs:255:23
    |
255 |         let cof_par = polcof_parallel(xa_arc, ya_arc);
    |                       ^^^^^^^^^^^^^^^
    |
note: expected `Arc<[f64]>`, found `Arc<Vec<f64>>`
   --> src/polcof.rs:255:39
    |
255 |         let cof_par = polcof_parallel(xa_arc, ya_arc);
    |                                       ^^^^^^
    = note: expected struct `std::sync::Arc<[f64]>`
               found struct `std::sync::Arc<Vec<f64>>`
note: expected `Arc<[f64]>`, found `Arc<Vec<f64>>`
   --> src/polcof.rs:255:47
    |
255 |         let cof_par = polcof_parallel(xa_arc, ya_arc);
    |                                               ^^^^^^
    = note: expected struct `std::sync::Arc<[f64]>`
               found struct `std::sync::Arc<Vec<f64>>`
note: function defined here
   --> src/polcof.rs:96:8
    |
 96 | pub fn polcof_parallel(xa: Arc<[f64]>, ya: Arc<[f64]>) -> Vec<f64> {
    |        ^^^^^^^^^^^^^^^ --------------  --------------

error[E0308]: arguments to this function are incorrect
   --> src/polcof.rs:271:19
    |
271 |         let cof = polcof_parallel(xa_arc, ya_arc);
    |                   ^^^^^^^^^^^^^^^
    |
note: expected `Arc<[f64]>`, found `Arc<Vec<f64>>`
   --> src/polcof.rs:271:35
    |
271 |         let cof = polcof_parallel(xa_arc, ya_arc);
    |                                   ^^^^^^
    = note: expected struct `std::sync::Arc<[f64]>`
               found struct `std::sync::Arc<Vec<f64>>`
note: expected `Arc<[f64]>`, found `Arc<Vec<f64>>`
   --> src/polcof.rs:271:43
    |
271 |         let cof = polcof_parallel(xa_arc, ya_arc);
    |                                           ^^^^^^
    = note: expected struct `std::sync::Arc<[f64]>`
               found struct `std::sync::Arc<Vec<f64>>`
note: function defined here
   --> src/polcof.rs:96:8
    |
 96 | pub fn polcof_parallel(xa: Arc<[f64]>, ya: Arc<[f64]>) -> Vec<f64> {
    |        ^^^^^^^^^^^^^^^ --------------  --------------

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<Vec<f64>, polydiv::PolynomialDivider>>`, but its trait bounds were not satisfied
   --> src/polydiv.rs:179:15
    |
179 |         cache.entry(key.clone())
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<f64>: Hash` or `Vec<f64>: std::cmp::Eq`
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `Vec<f64>: std::cmp::Eq`
            `f64: Hash`
            which is required by `Vec<f64>: Hash`

error[E0599]: no method named `relative` found for struct `AbsDiff<A, B>` in the current scope
   --> src/polydiv.rs:434:41
    |
434 |         assert_abs_diff_eq!(q[0], 1e20, relative = 1e-10);
    |                                         ^^^^^^^^ method not found in `AbsDiff<_, _>`

error[E0599]: no method named `relative` found for struct `AbsDiff<A, B>` in the current scope
   --> src/polydiv.rs:435:41
    |
435 |         assert_abs_diff_eq!(q[1], 1e20, relative = 1e-10);
    |                                         ^^^^^^^^ method not found in `AbsDiff<_, _>`

error[E0308]: mismatched types
   --> src/qromo.rs:316:14
    |
316 |             (linear_fn, 0.0, 1.0, 0.5),
    |              ^^^^^^^^^ expected fn item, found a different fn item
    |
    = note: expected fn item `fn(_) -> _ {qromo::tests::constant_fn}`
               found fn item `fn(_) -> _ {qromo::tests::linear_fn}`
    = note: different fn items have unique types, even if their signatures are the same
    = help: consider casting both fn items to fn pointers using `as fn(f64) -> f64`

error[E0308]: mismatched types
   --> src/qromo.rs:317:14
    |
317 |             (quadratic_fn, 0.0, 1.0, 1.0/3.0),
    |              ^^^^^^^^^^^^ expected fn item, found a different fn item
    |
    = note: expected fn item `fn(_) -> _ {qromo::tests::constant_fn}`
               found fn item `fn(_) -> _ {qromo::tests::quadratic_fn}`
    = note: different fn items have unique types, even if their signatures are the same
    = help: consider casting both fn items to fn pointers using `as fn(f64) -> f64`

error[E0308]: mismatched types
   --> src/qromo.rs:318:14
    |
318 |             (sine_fn, 0.0, std::f64::consts::PI, 2.0),
    |              ^^^^^^^ expected fn item, found a different fn item
    |
    = note: expected fn item `fn(_) -> _ {qromo::tests::constant_fn}`
               found fn item `fn(_) -> _ {qromo::tests::sine_fn}`
    = note: different fn items have unique types, even if their signatures are the same
    = help: consider casting both fn items to fn pointers using `as fn(f64) -> f64`

error[E0277]: the trait bound `&F: Function3D` is not satisfied
   --> src/quad3d.rs:172:13
    |
171 |         return quad3d(
    |                ------ required by a bound introduced by this call
172 |             func.as_ref(),
    |             ^^^^^^^^^^^^^ the trait `Fn(f64, f64, f64)` is not implemented for `F`
    |
    = note: required for `&F` to implement `FnOnce(f64, f64, f64)`
note: required for `&F` to implement `Function3D`
   --> src/quad3d.rs:11:9
    |
 11 | impl<F> Function3D for F
    |         ^^^^^^^^^^     ^
 12 | where
 13 |     F: Fn(f64, f64, f64) -> f64 + Sync + Send,
    |                             --- unsatisfied trait bound introduced here
note: required by a bound in `quad3d::quad3d`
   --> src/quad3d.rs:80:8
    |
 70 | pub fn quad3d<F, Y1, Y2, Z1, Z2>(
    |        ------ required by a bound in this function
...
 80 |     F: Function3D,
    |        ^^^^^^^^^^ required by this bound in `quad3d`
help: consider further restricting type parameter `F` with trait `Fn`
    |
163 |     F: Function3D + Fn(f64, f64, f64),
    |                   +++++++++++++++++++

error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`
   --> src/spherical_bessel.rs:432:43
    |
432 |         let j1_exact = 1.0f64.sin() / 1.0.powi(2) - 1.0f64.cos() / 1.0;
    |                                           ^^^^
    |
help: you must specify a concrete type for this numeric value, like `f32`
    |
432 |         let j1_exact = 1.0f64.sin() / 1.0_f32.powi(2) - 1.0f64.cos() / 1.0;
    |                                          ++++

error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`
   --> src/spherical_bessel.rs:436:44
    |
436 |         let y1_exact = -1.0f64.cos() / 1.0.powi(2) - 1.0f64.sin() / 1.0;
    |                                            ^^^^
    |
help: you must specify a concrete type for this numeric value, like `f32`
    |
436 |         let y1_exact = -1.0f64.cos() / 1.0_f32.powi(2) - 1.0f64.sin() / 1.0;
    |                                           ++++

error[E0277]: the trait bound `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>: AbsDiffEq<_>` is not satisfied
    --> src/splie2.rs:324:9
     |
 324 |         assert_abs_diff_eq!(y2a_seq, y2a_par, epsilon = 1e-10);
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------^^^^^^^^^
     |         |                                     |
     |         |                                     required by a bound introduced by this call
     |         the trait `AbsDiffEq<_>` is not implemented for `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>`
     |
note: there are multiple different versions of crate `approx` in the dependency graph
    --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/abs_diff_eq.rs:6:1
     |
   6 | pub trait AbsDiffEq<Rhs = Self>: PartialEq<Rhs>
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
     |
    ::: src/airy.rs:572:9
     |
 572 |     use approx::assert_relative_eq;
     |         ------ one version of crate `approx` used here, as a direct dependency of the current crate
     |
    ::: src/sprspm.rs:1:5
     |
   1 | use sprs::{CsMat, CsVec};
     |     ---- one version of crate `approx` used here, as a dependency of crate `alga`
     |
    ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ndarray-0.15.6/src/lib.rs:1268:1
     |
1268 | pub struct ArrayBase<S, D>
     | -------------------------- this type doesn't implement the required trait
     |
    ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.3.2/src/abs_diff_eq.rs:8:1
     |
   8 | pub trait AbsDiffEq<Rhs = Self>: PartialEq<Rhs>
     | ----------------------------------------------- this is the found trait
     = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `AbsDiff::<A, B>::epsilon`
    --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/lib.rs:213:8
     |
 213 |     A: AbsDiffEq<B> + ?Sized,
     |        ^^^^^^^^^^^^ required by this bound in `AbsDiff::<A, B>::epsilon`
...
 218 |     pub fn epsilon(self, epsilon: A::Epsilon) -> AbsDiff<A, B> {
     |            ------- required by a bound in this associated function

error[E0277]: the trait bound `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>: AbsDiffEq<_>` is not satisfied in `AbsDiff<ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>, _>`
    --> src/splie2.rs:324:9
     |
 324 |         assert_abs_diff_eq!(y2a_seq, y2a_par, epsilon = 1e-10);
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound
     |
     = help: within `AbsDiff<ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>, _>`, the trait `AbsDiffEq<_>` is not implemented for `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>`
note: there are multiple different versions of crate `approx` in the dependency graph
    --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/abs_diff_eq.rs:6:1
     |
   6 | pub trait AbsDiffEq<Rhs = Self>: PartialEq<Rhs>
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
     |
    ::: src/airy.rs:572:9
     |
 572 |     use approx::assert_relative_eq;
     |         ------ one version of crate `approx` used here, as a direct dependency of the current crate
     |
    ::: src/sprspm.rs:1:5
     |
   1 | use sprs::{CsMat, CsVec};
     |     ---- one version of crate `approx` used here, as a dependency of crate `alga`
     |
    ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ndarray-0.15.6/src/lib.rs:1268:1
     |
1268 | pub struct ArrayBase<S, D>
     | -------------------------- this type doesn't implement the required trait
     |
    ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.3.2/src/abs_diff_eq.rs:8:1
     |
   8 | pub trait AbsDiffEq<Rhs = Self>: PartialEq<Rhs>
     | ----------------------------------------------- this is the found trait
     = help: you can use `cargo tree` to explore your dependency tree
note: required because it appears within the type `AbsDiff<ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>, _>`
    --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/lib.rs:189:12
     |
 189 | pub struct AbsDiff<A, B = A>
     |            ^^^^^^^
note: required by a bound in `default`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/default.rs:107:26
     |
 107 | pub const trait Default: Sized {
     |                          ^^^^^ required by this bound in `Default::default`
...
 139 |     fn default() -> Self;
     |        ------- required by a bound in this associated function
     = note: this error originates in the macro `abs_diff_eq` which comes from the expansion of the macro `assert_abs_diff_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>: AbsDiffEq<_>` is not satisfied
    --> src/splie2.rs:324:9
     |
 324 |         assert_abs_diff_eq!(y2a_seq, y2a_par, epsilon = 1e-10);
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `AbsDiffEq<_>` is not implemented for `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>`
     |
note: there are multiple different versions of crate `approx` in the dependency graph
    --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/abs_diff_eq.rs:6:1
     |
   6 | pub trait AbsDiffEq<Rhs = Self>: PartialEq<Rhs>
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
     |
    ::: src/airy.rs:572:9
     |
 572 |     use approx::assert_relative_eq;
     |         ------ one version of crate `approx` used here, as a direct dependency of the current crate
     |
    ::: src/sprspm.rs:1:5
     |
   1 | use sprs::{CsMat, CsVec};
     |     ---- one version of crate `approx` used here, as a dependency of crate `alga`
     |
    ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ndarray-0.15.6/src/lib.rs:1268:1
     |
1268 | pub struct ArrayBase<S, D>
     | -------------------------- this type doesn't implement the required trait
     |
    ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.3.2/src/abs_diff_eq.rs:8:1
     |
   8 | pub trait AbsDiffEq<Rhs = Self>: PartialEq<Rhs>
     | ----------------------------------------------- this is the found trait
     = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `AbsDiff::<A, B>::eq`
    --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/lib.rs:213:8
     |
 213 |     A: AbsDiffEq<B> + ?Sized,
     |        ^^^^^^^^^^^^ required by this bound in `AbsDiff::<A, B>::eq`
...
 225 |     pub fn eq(self, lhs: &A, rhs: &B) -> bool {
     |            -- required by a bound in this associated function
     = note: this error originates in the macro `abs_diff_eq` which comes from the expansion of the macro `assert_abs_diff_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>: AbsDiffEq` is not satisfied in `AbsDiff<ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>>`
    --> src/splie2.rs:324:9
     |
 324 |         assert_abs_diff_eq!(y2a_seq, y2a_par, epsilon = 1e-10);
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound
     |
     = help: within `AbsDiff<ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>>`, the trait `AbsDiffEq` is not implemented for `ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>`
note: there are multiple different versions of crate `approx` in the dependency graph
    --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/abs_diff_eq.rs:6:1
     |
   6 | pub trait AbsDiffEq<Rhs = Self>: PartialEq<Rhs>
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
     |
    ::: src/airy.rs:572:9
     |
 572 |     use approx::assert_relative_eq;
     |         ------ one version of crate `approx` used here, as a direct dependency of the current crate
     |
    ::: src/sprspm.rs:1:5
     |
   1 | use sprs::{CsMat, CsVec};
     |     ---- one version of crate `approx` used here, as a dependency of crate `alga`
     |
    ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ndarray-0.15.6/src/lib.rs:1268:1
     |
1268 | pub struct ArrayBase<S, D>
     | -------------------------- this type doesn't implement the required trait
     |
    ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.3.2/src/abs_diff_eq.rs:8:1
     |
   8 | pub trait AbsDiffEq<Rhs = Self>: PartialEq<Rhs>
     | ----------------------------------------------- this is the found trait
     = help: you can use `cargo tree` to explore your dependency tree
note: required because it appears within the type `AbsDiff<ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>>>`
    --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/lib.rs:189:12
     |
 189 | pub struct AbsDiff<A, B = A>
     |            ^^^^^^^
     = note: the return type of a function must have a statically known size
     = note: this error originates in the macro `abs_diff_eq` which comes from the expansion of the macro `assert_abs_diff_eq` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`
   --> src/spline.rs:262:49
    |
262 |         let y: Vec<f32> = x.iter().map(|&xi| xi.powi(3)).collect(); // x^3
    |                                          --     ^^^^
    |                                          |
    |                                          you must specify a type for this binding, like `f32`

error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`
   --> src/vander.rs:276:55
    |
276 |         let q: Vec<f64> = x.iter().map(|&xi| 2.0 * xi.powi(3) - 3.0 * xi.powi(2) + 4.0 * xi - 1.0).collect();
    |                                          --           ^^^^
    |                                          |
    |                                          you must specify a type for this binding, like `f32`

error[E0689]: can't call method `powi` on ambiguous numeric type `{float}`
   --> src/vander.rs:276:74
    |
276 |         let q: Vec<f64> = x.iter().map(|&xi| 2.0 * xi.powi(3) - 3.0 * xi.powi(2) + 4.0 * xi - 1.0).collect();
    |                                          --                              ^^^^
    |                                          |
    |                                          you must specify a type for this binding, like `f32`

error[E0689]: can't call method `abs` on ambiguous numeric type `{float}`
   --> src/vander.rs:304:32
    |
304 |             if (x[i] - x[i-1]).abs() < 1e-10 {
    |                                ^^^

warning: unused import: `rayon::prelude`
 --> src/quad3d.rs:1:5
  |
1 | use rayon::prelude::*;
  |     ^^^^^^^^^^^^^^

warning: unused variable: `aip_asym`
   --> src/airy.rs:668:32
    |
668 |         let (ai_asym, bi_asym, aip_asym, bip_asym) = airy_asymptotic_large_positive(10.0);
    |                                ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
668 |         let (ai_asym, bi_asym, _aip_asym, bip_asym) = airy_asymptotic_large_positive(10.0);
    |                                +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
668 -         let (ai_asym, bi_asym, aip_asym, bip_asym) = airy_asymptotic_large_positive(10.0);
668 +         let (ai_asym, bi_asym, constants::CBRT_EPSILON, bip_asym) = airy_asymptotic_large_positive(10.0);
    |

warning: unused variable: `bip_asym`
   --> src/airy.rs:668:42
    |
668 |         let (ai_asym, bi_asym, aip_asym, bip_asym) = airy_asymptotic_large_positive(10.0);
    |                                          ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
668 |         let (ai_asym, bi_asym, aip_asym, _bip_asym) = airy_asymptotic_large_positive(10.0);
    |                                          +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
668 -         let (ai_asym, bi_asym, aip_asym, bip_asym) = airy_asymptotic_large_positive(10.0);
668 +         let (ai_asym, bi_asym, aip_asym, constants::CBRT_EPSILON) = airy_asymptotic_large_positive(10.0);
    |

warning: unused variable: `aip_exact`
   --> src/airy.rs:669:34
    |
669 |         let (ai_exact, bi_exact, aip_exact, bip_exact) = airy(10.0).unwrap();
    |                                  ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
669 |         let (ai_exact, bi_exact, _aip_exact, bip_exact) = airy(10.0).unwrap();
    |                                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
669 -         let (ai_exact, bi_exact, aip_exact, bip_exact) = airy(10.0).unwrap();
669 +         let (ai_exact, bi_exact, constants::CBRT_EPSILON, bip_exact) = airy(10.0).unwrap();
    |

warning: unused variable: `bip_exact`
   --> src/airy.rs:669:45
    |
669 |         let (ai_exact, bi_exact, aip_exact, bip_exact) = airy(10.0).unwrap();
    |                                             ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
669 |         let (ai_exact, bi_exact, aip_exact, _bip_exact) = airy(10.0).unwrap();
    |                                             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
669 -         let (ai_exact, bi_exact, aip_exact, bip_exact) = airy(10.0).unwrap();
669 +         let (ai_exact, bi_exact, aip_exact, constants::CBRT_EPSILON) = airy(10.0).unwrap();
    |

warning: unused variable: `aip_asym_neg`
   --> src/airy.rs:675:40
    |
675 |         let (ai_asym_neg, bi_asym_neg, aip_asym_neg, bip_asym_neg) = airy_asymptotic_large_negative(-10.0);
    |                                        ^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
675 |         let (ai_asym_neg, bi_asym_neg, _aip_asym_neg, bip_asym_neg) = airy_asymptotic_large_negative(-10.0);
    |                                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
675 -         let (ai_asym_neg, bi_asym_neg, aip_asym_neg, bip_asym_neg) = airy_asymptotic_large_negative(-10.0);
675 +         let (ai_asym_neg, bi_asym_neg, constants::CBRT_EPSILON, bip_asym_neg) = airy_asymptotic_large_negative(-10.0);
    |

warning: unused variable: `bip_asym_neg`
   --> src/airy.rs:675:54
    |
675 |         let (ai_asym_neg, bi_asym_neg, aip_asym_neg, bip_asym_neg) = airy_asymptotic_large_negative(-10.0);
    |                                                      ^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
675 |         let (ai_asym_neg, bi_asym_neg, aip_asym_neg, _bip_asym_neg) = airy_asymptotic_large_negative(-10.0);
    |                                                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
675 -         let (ai_asym_neg, bi_asym_neg, aip_asym_neg, bip_asym_neg) = airy_asymptotic_large_negative(-10.0);
675 +         let (ai_asym_neg, bi_asym_neg, aip_asym_neg, constants::CBRT_EPSILON) = airy_asymptotic_large_negative(-10.0);
    |

warning: unused variable: `aip_exact_neg`
   --> src/airy.rs:676:42
    |
676 |         let (ai_exact_neg, bi_exact_neg, aip_exact_neg, bip_exact_neg) = airy(-10.0).unwrap();
    |                                          ^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
676 |         let (ai_exact_neg, bi_exact_neg, _aip_exact_neg, bip_exact_neg) = airy(-10.0).unwrap();
    |                                          +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
676 -         let (ai_exact_neg, bi_exact_neg, aip_exact_neg, bip_exact_neg) = airy(-10.0).unwrap();
676 +         let (ai_exact_neg, bi_exact_neg, constants::CBRT_EPSILON, bip_exact_neg) = airy(-10.0).unwrap();
    |

warning: unused variable: `bip_exact_neg`
   --> src/airy.rs:676:57
    |
676 |         let (ai_exact_neg, bi_exact_neg, aip_exact_neg, bip_exact_neg) = airy(-10.0).unwrap();
    |                                                         ^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
676 |         let (ai_exact_neg, bi_exact_neg, aip_exact_neg, _bip_exact_neg) = airy(-10.0).unwrap();
    |                                                         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
676 -         let (ai_exact_neg, bi_exact_neg, aip_exact_neg, bip_exact_neg) = airy(-10.0).unwrap();
676 +         let (ai_exact_neg, bi_exact_neg, aip_exact_neg, constants::CBRT_EPSILON) = airy(-10.0).unwrap();
    |

warning: unused variable: `aip_inf`
   --> src/airy.rs:688:30
    |
688 |         let (ai_inf, bi_inf, aip_inf, bip_inf) = airy(f64::INFINITY).unwrap();
    |                              ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
688 |         let (ai_inf, bi_inf, _aip_inf, bip_inf) = airy(f64::INFINITY).unwrap();
    |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
688 -         let (ai_inf, bi_inf, aip_inf, bip_inf) = airy(f64::INFINITY).unwrap();
688 +         let (ai_inf, bi_inf, constants::CBRT_EPSILON, bip_inf) = airy(f64::INFINITY).unwrap();
    |

warning: unused variable: `bip_inf`
   --> src/airy.rs:688:39
    |
688 |         let (ai_inf, bi_inf, aip_inf, bip_inf) = airy(f64::INFINITY).unwrap();
    |                                       ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
688 |         let (ai_inf, bi_inf, aip_inf, _bip_inf) = airy(f64::INFINITY).unwrap();
    |                                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
688 -         let (ai_inf, bi_inf, aip_inf, bip_inf) = airy(f64::INFINITY).unwrap();
688 +         let (ai_inf, bi_inf, aip_inf, constants::CBRT_EPSILON) = airy(f64::INFINITY).unwrap();
    |

warning: unused variable: `aip_neg_inf`
   --> src/airy.rs:693:38
    |
693 |         let (ai_neg_inf, bi_neg_inf, aip_neg_inf, bip_neg_inf) = airy(f64::NEG_INFINITY).unwrap();
    |                                      ^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
693 |         let (ai_neg_inf, bi_neg_inf, _aip_neg_inf, bip_neg_inf) = airy(f64::NEG_INFINITY).unwrap();
    |                                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
693 -         let (ai_neg_inf, bi_neg_inf, aip_neg_inf, bip_neg_inf) = airy(f64::NEG_INFINITY).unwrap();
693 +         let (ai_neg_inf, bi_neg_inf, constants::CBRT_EPSILON, bip_neg_inf) = airy(f64::NEG_INFINITY).unwrap();
    |

warning: unused variable: `bip_neg_inf`
   --> src/airy.rs:693:51
    |
693 |         let (ai_neg_inf, bi_neg_inf, aip_neg_inf, bip_neg_inf) = airy(f64::NEG_INFINITY).unwrap();
    |                                                   ^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
693 |         let (ai_neg_inf, bi_neg_inf, aip_neg_inf, _bip_neg_inf) = airy(f64::NEG_INFINITY).unwrap();
    |                                                   +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
693 -         let (ai_neg_inf, bi_neg_inf, aip_neg_inf, bip_neg_inf) = airy(f64::NEG_INFINITY).unwrap();
693 +         let (ai_neg_inf, bi_neg_inf, aip_neg_inf, constants::CBRT_EPSILON) = airy(f64::NEG_INFINITY).unwrap();
    |

error[E0515]: cannot return value referencing temporary value
   --> src/bcucof.rs:392:17
    |
392 | /                 (
393 | |                     [val, val, val, val].as_slice(),
394 | |                     [val * 0.1, val * 0.1, val * 0.1, val * 0.1].as_slice(),
395 | |                     [val * 0.2, val * 0.2, val * 0.2, val * 0.2].as_slice(),
396 | |                     [val * 0.3, val * 0.3, val * 0.3, val * 0.3].as_slice(),
    | |                     -------------------------------------------- temporary value created here
397 | |                 )
    | |_________________^ returns a value referencing data owned by the current function

error[E0515]: cannot return value referencing temporary value
   --> src/bcucof.rs:392:17
    |
392 | /                 (
393 | |                     [val, val, val, val].as_slice(),
394 | |                     [val * 0.1, val * 0.1, val * 0.1, val * 0.1].as_slice(),
395 | |                     [val * 0.2, val * 0.2, val * 0.2, val * 0.2].as_slice(),
    | |                     -------------------------------------------- temporary value created here
396 | |                     [val * 0.3, val * 0.3, val * 0.3, val * 0.3].as_slice(),
397 | |                 )
    | |_________________^ returns a value referencing data owned by the current function

error[E0515]: cannot return value referencing temporary value
   --> src/bcucof.rs:392:17
    |
392 | /                 (
393 | |                     [val, val, val, val].as_slice(),
394 | |                     [val * 0.1, val * 0.1, val * 0.1, val * 0.1].as_slice(),
    | |                     -------------------------------------------- temporary value created here
395 | |                     [val * 0.2, val * 0.2, val * 0.2, val * 0.2].as_slice(),
396 | |                     [val * 0.3, val * 0.3, val * 0.3, val * 0.3].as_slice(),
397 | |                 )
    | |_________________^ returns a value referencing data owned by the current function

error[E0515]: cannot return value referencing temporary value
   --> src/bcucof.rs:392:17
    |
392 | /                 (
393 | |                     [val, val, val, val].as_slice(),
    | |                     -------------------- temporary value created here
394 | |                     [val * 0.1, val * 0.1, val * 0.1, val * 0.1].as_slice(),
395 | |                     [val * 0.2, val * 0.2, val * 0.2, val * 0.2].as_slice(),
396 | |                     [val * 0.3, val * 0.3, val * 0.3, val * 0.3].as_slice(),
397 | |                 )
    | |_________________^ returns a value referencing data owned by the current function

error[E0716]: temporary value dropped while borrowed
   --> src/bcuint.rs:499:17
    |
498 |             patches.push((
    |             ------- borrow later used here
499 |                 [val, val + 1.0, val + 2.0, val + 3.0].as_slice(),
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
...
507 |             ));
    |               - temporary value is freed at the end of this statement
    |
    = note: consider using a `let` binding to create a longer lived value

error[E0716]: temporary value dropped while borrowed
   --> src/bcuint.rs:500:17
    |
498 |             patches.push((
    |             ------- borrow later used here
499 |                 [val, val + 1.0, val + 2.0, val + 3.0].as_slice(),
500 |                 [val * 0.1; 4].as_slice(),
    |                 ^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
...
507 |             ));
    |               - temporary value is freed at the end of this statement
    |
    = note: consider using a `let` binding to create a longer lived value

error[E0716]: temporary value dropped while borrowed
   --> src/bcuint.rs:501:17
    |
498 |             patches.push((
    |             ------- borrow later used here
...
501 |                 [val * 0.2; 4].as_slice(),
    |                 ^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
...
507 |             ));
    |               - temporary value is freed at the end of this statement
    |
    = note: consider using a `let` binding to create a longer lived value

error[E0716]: temporary value dropped while borrowed
   --> src/bcuint.rs:502:17
    |
498 |             patches.push((
    |             ------- borrow later used here
...
502 |                 [val * 0.3; 4].as_slice(),
    |                 ^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
...
507 |             ));
    |               - temporary value is freed at the end of this statement
    |
    = note: consider using a `let` binding to create a longer lived value

warning: unused variable: `gampl`
   --> src/beschd.rs:388:26
    |
388 |         let (gam1, gam2, gampl, gammi) = beschd_precise(x);
    |                          ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
388 |         let (gam1, gam2, _gampl, gammi) = beschd_precise(x);
    |                          +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
388 -         let (gam1, gam2, gampl, gammi) = beschd_precise(x);
388 +         let (gam1, gam2, constants::CBRT_EPSILON, gammi) = beschd_precise(x);
    |

warning: unused variable: `gammi`
   --> src/beschd.rs:388:33
    |
388 |         let (gam1, gam2, gampl, gammi) = beschd_precise(x);
    |                                 ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
388 |         let (gam1, gam2, gampl, _gammi) = beschd_precise(x);
    |                                 +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
388 -         let (gam1, gam2, gampl, gammi) = beschd_precise(x);
388 +         let (gam1, gam2, gampl, constants::CBRT_EPSILON) = beschd_precise(x);
    |

warning: unused variable: `boundary`
   --> src/bessel_I1.rs:302:13
    |
302 |         let boundary = 3.75_f64;
    |             ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
302 |         let _boundary = 3.75_f64;
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
302 -         let boundary = 3.75_f64;
302 +         let constants::CBRT_EPSILON = 3.75_f64;
    |

warning: unused variable: `jp0`
   --> src/bessel_jy.rs:400:22
    |
400 |         let (j0, y0, jp0, yp0) = bessjy(1.0_f64, 0.0);
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
400 |         let (j0, y0, _jp0, yp0) = bessjy(1.0_f64, 0.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
400 -         let (j0, y0, jp0, yp0) = bessjy(1.0_f64, 0.0);
400 +         let (j0, y0, constants::CBRT_EPSILON, yp0) = bessjy(1.0_f64, 0.0);
    |

warning: unused variable: `yp0`
   --> src/bessel_jy.rs:400:27
    |
400 |         let (j0, y0, jp0, yp0) = bessjy(1.0_f64, 0.0);
    |                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
400 |         let (j0, y0, jp0, _yp0) = bessjy(1.0_f64, 0.0);
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
400 -         let (j0, y0, jp0, yp0) = bessjy(1.0_f64, 0.0);
400 +         let (j0, y0, jp0, constants::CBRT_EPSILON) = bessjy(1.0_f64, 0.0);
    |

warning: unused variable: `jp1`
   --> src/bessel_jy.rs:404:22
    |
404 |         let (j1, y1, jp1, yp1) = bessjy(2.0_f64, 1.0);
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
404 |         let (j1, y1, _jp1, yp1) = bessjy(2.0_f64, 1.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
404 -         let (j1, y1, jp1, yp1) = bessjy(2.0_f64, 1.0);
404 +         let (j1, y1, constants::CBRT_EPSILON, yp1) = bessjy(2.0_f64, 1.0);
    |

warning: unused variable: `yp1`
   --> src/bessel_jy.rs:404:27
    |
404 |         let (j1, y1, jp1, yp1) = bessjy(2.0_f64, 1.0);
    |                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
404 |         let (j1, y1, jp1, _yp1) = bessjy(2.0_f64, 1.0);
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
404 -         let (j1, y1, jp1, yp1) = bessjy(2.0_f64, 1.0);
404 +         let (j1, y1, jp1, constants::CBRT_EPSILON) = bessjy(2.0_f64, 1.0);
    |

warning: unused variable: `jp2`
   --> src/bessel_jy.rs:415:22
    |
415 |         let (j2, y2, jp2, yp2) = bessjy(x, 2.0);
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
415 |         let (j2, y2, _jp2, yp2) = bessjy(x, 2.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
415 -         let (j2, y2, jp2, yp2) = bessjy(x, 2.0);
415 +         let (j2, y2, constants::CBRT_EPSILON, yp2) = bessjy(x, 2.0);
    |

warning: unused variable: `yp2`
   --> src/bessel_jy.rs:415:27
    |
415 |         let (j2, y2, jp2, yp2) = bessjy(x, 2.0);
    |                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
415 |         let (j2, y2, jp2, _yp2) = bessjy(x, 2.0);
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
415 -         let (j2, y2, jp2, yp2) = bessjy(x, 2.0);
415 +         let (j2, y2, jp2, constants::CBRT_EPSILON) = bessjy(x, 2.0);
    |

warning: unused variable: `jp3`
   --> src/bessel_jy.rs:420:22
    |
420 |         let (j3, y3, jp3, yp3) = bessjy(x, 3.0);
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
420 |         let (j3, y3, _jp3, yp3) = bessjy(x, 3.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
420 -         let (j3, y3, jp3, yp3) = bessjy(x, 3.0);
420 +         let (j3, y3, constants::CBRT_EPSILON, yp3) = bessjy(x, 3.0);
    |

warning: unused variable: `yp3`
   --> src/bessel_jy.rs:420:27
    |
420 |         let (j3, y3, jp3, yp3) = bessjy(x, 3.0);
    |                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
420 |         let (j3, y3, jp3, _yp3) = bessjy(x, 3.0);
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
420 -         let (j3, y3, jp3, yp3) = bessjy(x, 3.0);
420 +         let (j3, y3, jp3, constants::CBRT_EPSILON) = bessjy(x, 3.0);
    |

warning: unused variable: `jp_half`
   --> src/bessel_jy.rs:431:30
    |
431 |         let (j_half, y_half, jp_half, yp_half) = bessjy(x, 0.5);
    |                              ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
431 |         let (j_half, y_half, _jp_half, yp_half) = bessjy(x, 0.5);
    |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
431 -         let (j_half, y_half, jp_half, yp_half) = bessjy(x, 0.5);
431 +         let (j_half, y_half, constants::CBRT_EPSILON, yp_half) = bessjy(x, 0.5);
    |

warning: unused variable: `yp_half`
   --> src/bessel_jy.rs:431:39
    |
431 |         let (j_half, y_half, jp_half, yp_half) = bessjy(x, 0.5);
    |                                       ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
431 |         let (j_half, y_half, jp_half, _yp_half) = bessjy(x, 0.5);
    |                                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
431 -         let (j_half, y_half, jp_half, yp_half) = bessjy(x, 0.5);
431 +         let (j_half, y_half, jp_half, constants::CBRT_EPSILON) = bessjy(x, 0.5);
    |

warning: unused variable: `jp_3half`
   --> src/bessel_jy.rs:436:32
    |
436 |         let (j_3half, y_3half, jp_3half, yp_3half) = bessjy(x, 1.5);
    |                                ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
436 |         let (j_3half, y_3half, _jp_3half, yp_3half) = bessjy(x, 1.5);
    |                                +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
436 -         let (j_3half, y_3half, jp_3half, yp_3half) = bessjy(x, 1.5);
436 +         let (j_3half, y_3half, constants::CBRT_EPSILON, yp_3half) = bessjy(x, 1.5);
    |

warning: unused variable: `yp_3half`
   --> src/bessel_jy.rs:436:42
    |
436 |         let (j_3half, y_3half, jp_3half, yp_3half) = bessjy(x, 1.5);
    |                                          ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
436 |         let (j_3half, y_3half, jp_3half, _yp_3half) = bessjy(x, 1.5);
    |                                          +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
436 -         let (j_3half, y_3half, jp_3half, yp_3half) = bessjy(x, 1.5);
436 +         let (j_3half, y_3half, jp_3half, constants::CBRT_EPSILON) = bessjy(x, 1.5);
    |

warning: unused variable: `jp0`
   --> src/bessel_jy.rs:446:22
    |
446 |         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
446 |         let (j0, y0, _jp0, yp0) = bessjy(x, 0.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
446 -         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
446 +         let (j0, y0, constants::CBRT_EPSILON, yp0) = bessjy(x, 0.0);
    |

warning: unused variable: `yp0`
   --> src/bessel_jy.rs:446:27
    |
446 |         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
    |                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
446 |         let (j0, y0, jp0, _yp0) = bessjy(x, 0.0);
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
446 -         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
446 +         let (j0, y0, jp0, constants::CBRT_EPSILON) = bessjy(x, 0.0);
    |

warning: unused variable: `jp1`
   --> src/bessel_jy.rs:450:22
    |
450 |         let (j1, y1, jp1, yp1) = bessjy(x, 1.0);
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
450 |         let (j1, y1, _jp1, yp1) = bessjy(x, 1.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
450 -         let (j1, y1, jp1, yp1) = bessjy(x, 1.0);
450 +         let (j1, y1, constants::CBRT_EPSILON, yp1) = bessjy(x, 1.0);
    |

warning: unused variable: `yp1`
   --> src/bessel_jy.rs:450:27
    |
450 |         let (j1, y1, jp1, yp1) = bessjy(x, 1.0);
    |                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
450 |         let (j1, y1, jp1, _yp1) = bessjy(x, 1.0);
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
450 -         let (j1, y1, jp1, yp1) = bessjy(x, 1.0);
450 +         let (j1, y1, jp1, constants::CBRT_EPSILON) = bessjy(x, 1.0);
    |

warning: unused variable: `jp0`
   --> src/bessel_jy.rs:460:22
    |
460 |         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
460 |         let (j0, y0, _jp0, yp0) = bessjy(x, 0.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
460 -         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
460 +         let (j0, y0, constants::CBRT_EPSILON, yp0) = bessjy(x, 0.0);
    |

warning: unused variable: `yp0`
   --> src/bessel_jy.rs:460:27
    |
460 |         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
    |                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
460 |         let (j0, y0, jp0, _yp0) = bessjy(x, 0.0);
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
460 -         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
460 +         let (j0, y0, jp0, constants::CBRT_EPSILON) = bessjy(x, 0.0);
    |

warning: unused variable: `jp0`
   --> src/bessel_jy.rs:481:22
    |
481 |         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
481 |         let (j0, y0, _jp0, yp0) = bessjy(x, 0.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
481 -         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
481 +         let (j0, y0, constants::CBRT_EPSILON, yp0) = bessjy(x, 0.0);
    |

warning: unused variable: `yp0`
   --> src/bessel_jy.rs:481:27
    |
481 |         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
    |                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
481 |         let (j0, y0, jp0, _yp0) = bessjy(x, 0.0);
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
481 -         let (j0, y0, jp0, yp0) = bessjy(x, 0.0);
481 +         let (j0, y0, jp0, constants::CBRT_EPSILON) = bessjy(x, 0.0);
    |

warning: unused variable: `j`
   --> src/bessel_jy.rs:495:14
    |
495 |         let (j, y, jp, yp) = bessjy(x, nu);
    |              ^
    |
help: if this is intentional, prefix it with an underscore
    |
495 |         let (_j, y, jp, yp) = bessjy(x, nu);
    |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
495 -         let (j, y, jp, yp) = bessjy(x, nu);
495 +         let (constants::CBRT_EPSILON, y, jp, yp) = bessjy(x, nu);
    |

warning: unused variable: `y`
   --> src/bessel_jy.rs:495:17
    |
495 |         let (j, y, jp, yp) = bessjy(x, nu);
    |                 ^
    |
help: if this is intentional, prefix it with an underscore
    |
495 |         let (j, _y, jp, yp) = bessjy(x, nu);
    |                 +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
495 -         let (j, y, jp, yp) = bessjy(x, nu);
495 +         let (j, constants::CBRT_EPSILON, jp, yp) = bessjy(x, nu);
    |

warning: unused variable: `jp_nu`
   --> src/bessel_jy.rs:592:26
    |
592 |         let (j_nu, y_nu, jp_nu, yp_nu) = bessjy(x, nu);
    |                          ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
592 |         let (j_nu, y_nu, _jp_nu, yp_nu) = bessjy(x, nu);
    |                          +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
592 -         let (j_nu, y_nu, jp_nu, yp_nu) = bessjy(x, nu);
592 +         let (j_nu, y_nu, constants::CBRT_EPSILON, yp_nu) = bessjy(x, nu);
    |

warning: unused variable: `yp_nu`
   --> src/bessel_jy.rs:592:33
    |
592 |         let (j_nu, y_nu, jp_nu, yp_nu) = bessjy(x, nu);
    |                                 ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
592 |         let (j_nu, y_nu, jp_nu, _yp_nu) = bessjy(x, nu);
    |                                 +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
592 -         let (j_nu, y_nu, jp_nu, yp_nu) = bessjy(x, nu);
592 +         let (j_nu, y_nu, jp_nu, constants::CBRT_EPSILON) = bessjy(x, nu);
    |

warning: unused variable: `y_nu`
   --> src/bessel_jy.rs:613:20
    |
613 |         let (j_nu, y_nu, jp_nu, yp_nu) = bessjy(x, nu);
    |                    ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
613 |         let (j_nu, _y_nu, jp_nu, yp_nu) = bessjy(x, nu);
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
613 -         let (j_nu, y_nu, jp_nu, yp_nu) = bessjy(x, nu);
613 +         let (j_nu, constants::CBRT_EPSILON, jp_nu, yp_nu) = bessjy(x, nu);
    |

warning: unused variable: `yp_nu`
   --> src/bessel_jy.rs:613:33
    |
613 |         let (j_nu, y_nu, jp_nu, yp_nu) = bessjy(x, nu);
    |                                 ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
613 |         let (j_nu, y_nu, jp_nu, _yp_nu) = bessjy(x, nu);
    |                                 +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
613 -         let (j_nu, y_nu, jp_nu, yp_nu) = bessjy(x, nu);
613 +         let (j_nu, y_nu, jp_nu, constants::CBRT_EPSILON) = bessjy(x, nu);
    |

warning: unused variable: `boundary`
   --> src/bessel_k1.rs:376:13
    |
376 |         let boundary = 2.0_f64;
    |             ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
376 |         let _boundary = 2.0_f64;
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
376 -         let boundary = 2.0_f64;
376 +         let constants::CBRT_EPSILON = 2.0_f64;
    |

warning: unused variable: `b`
   --> src/cholesky.rs:370:13
    |
370 |         let b = vec![1.0; n];
    |             ^ help: if this is intentional, prefix it with an underscore: `_b`

error[E0716]: temporary value dropped while borrowed
   --> src/Correlation.rs:468:41
    |
468 |             (vec![3.0, 4.0].as_slice(), vec![3.0, 4.0].as_slice()),
    |                                         ^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
469 |         ];
    |          - temporary value is freed at the end of this statement
470 |
471 |         let results = correl_batch(&pairs)?;
    |                                    ------ borrow later used here
    |
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider using a `let` binding to create a longer lived value
    |
466 ~         let binding = vec![3.0, 4.0];
467 ~         let pairs = vec![
468 |             (vec![1.0, 2.0].as_slice(), vec![1.0, 2.0].as_slice()),
469 ~             (vec![3.0, 4.0].as_slice(), binding.as_slice()),
    |

error[E0716]: temporary value dropped while borrowed
   --> src/Correlation.rs:468:14
    |
468 |             (vec![3.0, 4.0].as_slice(), vec![3.0, 4.0].as_slice()),
    |              ^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
469 |         ];
    |          - temporary value is freed at the end of this statement
470 |
471 |         let results = correl_batch(&pairs)?;
    |                                    ------ borrow later used here
    |
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider using a `let` binding to create a longer lived value
    |
466 ~         let binding = vec![3.0, 4.0];
467 ~         let pairs = vec![
468 |             (vec![1.0, 2.0].as_slice(), vec![1.0, 2.0].as_slice()),
469 ~             (binding.as_slice(), vec![3.0, 4.0].as_slice()),
    |

error[E0716]: temporary value dropped while borrowed
   --> src/Correlation.rs:467:41
    |
467 |             (vec![1.0, 2.0].as_slice(), vec![1.0, 2.0].as_slice()),
    |                                         ^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
468 |             (vec![3.0, 4.0].as_slice(), vec![3.0, 4.0].as_slice()),
469 |         ];
    |          - temporary value is freed at the end of this statement
470 |
471 |         let results = correl_batch(&pairs)?;
    |                                    ------ borrow later used here
    |
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider using a `let` binding to create a longer lived value
    |
466 ~         let binding = vec![1.0, 2.0];
467 ~         let pairs = vec![
468 ~             (vec![1.0, 2.0].as_slice(), binding.as_slice()),
    |

error[E0716]: temporary value dropped while borrowed
   --> src/Correlation.rs:467:14
    |
467 |             (vec![1.0, 2.0].as_slice(), vec![1.0, 2.0].as_slice()),
    |              ^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
468 |             (vec![3.0, 4.0].as_slice(), vec![3.0, 4.0].as_slice()),
469 |         ];
    |          - temporary value is freed at the end of this statement
470 |
471 |         let results = correl_batch(&pairs)?;
    |                                    ------ borrow later used here
    |
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider using a `let` binding to create a longer lived value
    |
466 ~         let binding = vec![1.0, 2.0];
467 ~         let pairs = vec![
468 ~             (binding.as_slice(), vec![1.0, 2.0].as_slice()),
    |

warning: unused variable: `x`
   --> src/dfridr.rs:363:21
    |
363 |         fn constant(x: f64) -> f64 {
    |                     ^
    |
help: if this is intentional, prefix it with an underscore
    |
363 |         fn constant(_x: f64) -> f64 {
    |                     +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
363 -         fn constant(x: f64) -> f64 {
363 +         fn constant(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `x`
   --> src/elementary_integration_methods.rs:165:20
    |
165 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
165 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
165 -     fn constant_fn(x: f64) -> f64 {
165 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: variable does not need to be mutable
   --> src/FFT_1.rs:288:13
    |
288 |         let mut signals: Vec<Vec<f64>> = (0..8)
    |             ----^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/FFT_2.rs:500:17
    |
500 |             let mut fft1 = vec![0.0; 2 * n + 2];
    |                 ----^^^^
    |                 |
    |                 help: remove this `mut`

warning: variable does not need to be mutable
   --> src/FFT_2.rs:501:17
    |
501 |             let mut fft2 = vec![0.0; 2 * n + 2];
    |                 ----^^^^
    |                 |
    |                 help: remove this `mut`

warning: unused variable: `gln`
   --> src/gamma_continued_funciton.rs:208:22
    |
208 |         let (gammcf, gln) = gamma_continued_fraction(1.0, 2.0).unwrap();
    |                      ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
208 |         let (gammcf, _gln) = gamma_continued_fraction(1.0, 2.0).unwrap();
    |                      +
help: you might have meant to pattern match on the similarly named constant `LARGE`
    |
208 -         let (gammcf, gln) = gamma_continued_fraction(1.0, 2.0).unwrap();
208 +         let (gammcf, spline::LARGE) = gamma_continued_fraction(1.0, 2.0).unwrap();
    |

warning: unused variable: `x`
   --> src/gaucof.rs:376:18
    |
376 |             let (x, w) = GaussQuadratureGenerator::gauss_hermite(5).unwrap();
    |                  ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> src/gaucof.rs:391:14
    |
391 |         let (x, w) = GaussQuadratureGenerator::gauss_laguerre(5, 0.0).unwrap();
    |              ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> src/gaucof.rs:400:14
    |
400 |         let (x, w) = GaussQuadratureGenerator::gauss_jacobi(5, 0.0, 0.0).unwrap();
    |              ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> src/gauher.rs:351:57
    |
351 |         let result = gauss_hermite_weighted_quadrature(|x| 1.0, 5).unwrap();
    |                                                         ^
    |
help: if this is intentional, prefix it with an underscore
    |
351 |         let result = gauss_hermite_weighted_quadrature(|_x| 1.0, 5).unwrap();
    |                                                         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
351 -         let result = gauss_hermite_weighted_quadrature(|x| 1.0, 5).unwrap();
351 +         let result = gauss_hermite_weighted_quadrature(|constants::CBRT_EPSILON| 1.0, 5).unwrap();
    |

warning: unused variable: `pp`
   --> src/gauher.rs:381:18
    |
381 |         let (p3, pp) = hermite_polynomial(3, 1.0);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
381 |         let (p3, _pp) = hermite_polynomial(3, 1.0);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
381 -         let (p3, pp) = hermite_polynomial(3, 1.0);
381 +         let (p3, constants::CBRT_EPSILON) = hermite_polynomial(3, 1.0);
    |

warning: unused variable: `x`
   --> src/gaujac.rs:408:56
    |
408 |         let result = gauss_jacobi_weighted_quadrature(|x| 1.0, 5, 0.0, 0.0).unwrap();
    |                                                        ^
    |
help: if this is intentional, prefix it with an underscore
    |
408 |         let result = gauss_jacobi_weighted_quadrature(|_x| 1.0, 5, 0.0, 0.0).unwrap();
    |                                                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
408 -         let result = gauss_jacobi_weighted_quadrature(|x| 1.0, 5, 0.0, 0.0).unwrap();
408 +         let result = gauss_jacobi_weighted_quadrature(|constants::CBRT_EPSILON| 1.0, 5, 0.0, 0.0).unwrap();
    |

warning: unused variable: `x`
   --> src/gaujac.rs:416:18
    |
416 |             let (x, w) = gaujac(5, alf, bet).unwrap();
    |                  ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> src/gaujac.rs:428:14
    |
428 |         let (x, w) = gaujac(20, 0.0, 0.0).unwrap();
    |              ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `p2`
   --> src/gaujac.rs:438:18
    |
438 |         let (p1, p2, pp) = jacobi_polynomial(3, 0.0, 0.0, 0.5);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
438 |         let (p1, _p2, pp) = jacobi_polynomial(3, 0.0, 0.0, 0.5);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
438 -         let (p1, p2, pp) = jacobi_polynomial(3, 0.0, 0.0, 0.5);
438 +         let (p1, constants::CBRT_EPSILON, pp) = jacobi_polynomial(3, 0.0, 0.0, 0.5);
    |

warning: unused variable: `pp`
   --> src/gaujac.rs:438:22
    |
438 |         let (p1, p2, pp) = jacobi_polynomial(3, 0.0, 0.0, 0.5);
    |                      ^^
    |
help: if this is intentional, prefix it with an underscore
    |
438 |         let (p1, p2, _pp) = jacobi_polynomial(3, 0.0, 0.0, 0.5);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
438 -         let (p1, p2, pp) = jacobi_polynomial(3, 0.0, 0.0, 0.5);
438 +         let (p1, p2, constants::CBRT_EPSILON) = jacobi_polynomial(3, 0.0, 0.0, 0.5);
    |

warning: unused variable: `x`
   --> src/gaulag.rs:383:58
    |
383 |         let result = gauss_laguerre_weighted_quadrature(|x| 1.0, 5, 0.0).unwrap();
    |                                                          ^
    |
help: if this is intentional, prefix it with an underscore
    |
383 |         let result = gauss_laguerre_weighted_quadrature(|_x| 1.0, 5, 0.0).unwrap();
    |                                                          +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
383 -         let result = gauss_laguerre_weighted_quadrature(|x| 1.0, 5, 0.0).unwrap();
383 +         let result = gauss_laguerre_weighted_quadrature(|constants::CBRT_EPSILON| 1.0, 5, 0.0).unwrap();
    |

warning: unused variable: `x`
   --> src/gaulag.rs:398:18
    |
398 |             let (x, w) = gaulag(5, alf).unwrap();
    |                  ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `p2`
   --> src/gaulag.rs:410:18
    |
410 |         let (p3, p2, pp) = laguerre_polynomial(3, 0.0, 1.0);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
410 |         let (p3, _p2, pp) = laguerre_polynomial(3, 0.0, 1.0);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
410 -         let (p3, p2, pp) = laguerre_polynomial(3, 0.0, 1.0);
410 +         let (p3, constants::CBRT_EPSILON, pp) = laguerre_polynomial(3, 0.0, 1.0);
    |

warning: unused variable: `pp`
   --> src/gaulag.rs:410:22
    |
410 |         let (p3, p2, pp) = laguerre_polynomial(3, 0.0, 1.0);
    |                      ^^
    |
help: if this is intentional, prefix it with an underscore
    |
410 |         let (p3, p2, _pp) = laguerre_polynomial(3, 0.0, 1.0);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
410 -         let (p3, p2, pp) = laguerre_polynomial(3, 0.0, 1.0);
410 +         let (p3, p2, constants::CBRT_EPSILON) = laguerre_polynomial(3, 0.0, 1.0);
    |

warning: unused variable: `x`
   --> src/gauleg.rs:441:14
    |
441 |         let (x, w) = gauleg(0.999, 1.0, 5).unwrap();
    |              ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> src/gauleg.rs:446:14
    |
446 |         let (x, w) = gauleg(-1000.0, 1000.0, 5).unwrap();
    |              ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `results`
   --> src/hypergeo_series.rs:161:13
    |
161 |         let results = hypser_parallel(&a_params, &b_params, &c_params, &z_params);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_results`

warning: unused variable: `batch_results`
   --> src/hypergeo_series.rs:165:13
    |
165 |         let batch_results = hypser_batch(cache, &[z, z * 0.5, z * 0.25]);
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_results`

warning: unused variable: `results`
   --> src/Jacobian_elliptical.rs:240:13
    |
240 |         let results = sncndn_parallel(&uu, &emmc);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_results`

warning: unused variable: `batch_results`
   --> src/Jacobian_elliptical.rs:244:13
    |
244 |         let batch_results = sncndn_batch(cache, &[0.1, 0.2, 0.3, 0.4]);
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_results`

error[E0596]: cannot borrow `*self.residuals` as mutable, as it is behind a `&` reference
   --> src/linbcg.rs:386:17
    |
386 |                 self.residuals.push(residual_norm);
    |                 ^^^^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable
    |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
    |
 32 ~     fn a_solve(&mut self, b: &[f64], x: &mut [f64], transpose: bool);
 33 | }
...
381 |             
382 ~             fn a_solve(&mut self, b: &[f64], x: &mut [f64], transpose: bool) {
    |

warning: unused variable: `x`
   --> src/midexp.rs:196:20
    |
196 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
196 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
196 -     fn constant_fn(x: f64) -> f64 {
196 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `x`
   --> src/midinf.rs:179:20
    |
179 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
179 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
179 -     fn constant_fn(x: f64) -> f64 {
179 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `x`
   --> src/midpnt.rs:139:20
    |
139 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
139 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
139 -     fn constant_fn(x: f64) -> f64 {
139 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `x`
   --> src/midsql.rs:166:20
    |
166 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
166 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
166 -     fn constant_fn(x: f64) -> f64 {
166 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `x`
   --> src/midsqu.rs:183:20
    |
183 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
183 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
183 -     fn constant_fn(x: f64) -> f64 {
183 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

error[E0716]: temporary value dropped while borrowed
   --> src/pccheb.rs:508:13
    |
508 |             vec![1.0, 0.0, 0.0].as_slice(), // 1
    |             ^^^^^^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
509 |         ];
    |          - temporary value is freed at the end of this statement
510 |         
511 |         let results = pccheb_batch(&polynomials, 3);
    |                                    ------------ borrow later used here
    |
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider using a `let` binding to create a longer lived value
    |
505 ~         let binding = vec![1.0, 0.0, 0.0];
506 ~         let polynomials = [
507 |             vec![0.0, 0.0, 1.0].as_slice(), // x^2
508 |             vec![0.0, 1.0, 0.0].as_slice(), // x
509 ~             binding.as_slice(), // 1
    |

error[E0716]: temporary value dropped while borrowed
   --> src/pccheb.rs:507:13
    |
507 |             vec![0.0, 1.0, 0.0].as_slice(), // x
    |             ^^^^^^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
508 |             vec![1.0, 0.0, 0.0].as_slice(), // 1
509 |         ];
    |          - temporary value is freed at the end of this statement
510 |         
511 |         let results = pccheb_batch(&polynomials, 3);
    |                                    ------------ borrow later used here
    |
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider using a `let` binding to create a longer lived value
    |
505 ~         let binding = vec![0.0, 1.0, 0.0];
506 ~         let polynomials = [
507 |             vec![0.0, 0.0, 1.0].as_slice(), // x^2
508 ~             binding.as_slice(), // x
    |

error[E0716]: temporary value dropped while borrowed
   --> src/pccheb.rs:506:13
    |
506 |             vec![0.0, 0.0, 1.0].as_slice(), // x^2
    |             ^^^^^^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use
...
509 |         ];
    |          - temporary value is freed at the end of this statement
510 |         
511 |         let results = pccheb_batch(&polynomials, 3);
    |                                    ------------ borrow later used here
    |
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider using a `let` binding to create a longer lived value
    |
505 ~         let binding = vec![0.0, 0.0, 1.0];
506 ~         let polynomials = [
507 ~             binding.as_slice(), // x^2
    |

warning: unused variable: `x`
   --> src/qgaus.rs:255:20
    |
255 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
255 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
255 -     fn constant_fn(x: f64) -> f64 {
255 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `a_old`
   --> src/qrdcmp.rs:379:13
    |
379 |         let a_old = matrix_mult(&matrix_transpose(&qt_orig), &r_orig);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_a_old`

error[E0596]: cannot borrow `a_expected` as mutable, as it is not declared as mutable
   --> src/qrdcmp.rs:392:17
    |
392 |                 a_expected[i][j] += uv[i][j];
    |                 ^^^^^^^^^^ cannot borrow as mutable
    |
help: consider changing this to be mutable
    |
389 |         let mut a_expected = matrix_mult(&matrix_transpose(&qt_orig), &r_orig);
    |             +++

error[E0596]: cannot borrow `a_expected` as mutable, as it is not declared as mutable
   --> src/qrdcmp.rs:534:21
    |
534 |                     a_expected[i][j] += uv[i][j];
    |                     ^^^^^^^^^^ cannot borrow as mutable
    |
help: consider changing this to be mutable
    |
531 |             let mut a_expected = a_old.clone();
    |                 +++

warning: unused variable: `x`
   --> src/qromb.rs:212:20
    |
212 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
212 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
212 -     fn constant_fn(x: f64) -> f64 {
212 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `x`
   --> src/qromo.rs:224:20
    |
224 |     fn constant_fn(x: f64) -> f64 {
    |                    ^
    |
help: if this is intentional, prefix it with an underscore
    |
224 |     fn constant_fn(_x: f64) -> f64 {
    |                    +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
224 -     fn constant_fn(x: f64) -> f64 {
224 +     fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: variable does not need to be mutable
   --> src/random_0.rs:103:13
    |
103 |         let mut rng = Ran0::new(12345);
    |             ----^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/random_1.rs:150:13
    |
150 |         let mut rng = Ran1::new(-12345);
    |             ----^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/random_2.rs:191:13
    |
191 |         let mut rng = Ran2::new(-12345);
    |             ----^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/random_3.rs:172:13
    |
172 |         let mut rng = Ran3::new(-12345);
    |             ----^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `v`
   --> src/ratlsq.rs:601:20
    |
601 |         let (u, w, v) = svd(&a);
    |                    ^ help: if this is intentional, prefix it with an underscore: `_v`

warning: variable does not need to be mutable
   --> src/Real_FT.rs:504:13
    |
504 |         let mut data_copy = data.clone();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `original`
   --> src/Real_FT.rs:528:13
    |
528 |         let original = data1.clone();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_original`

warning: unused variable: `error`
   --> src/Recursive_Stratified_Sampling.rs:322:22
    |
322 |         let (result, error) = integrator.integrate(|x| x[0].sin(), &regn, 1000);
    |                      ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (result, _error) = integrator.integrate(|x| x[0].sin(), &regn, 1000);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (result, error) = integrator.integrate(|x| x[0].sin(), &regn, 1000);
322 +         let (result, constants::CBRT_EPSILON) = integrator.integrate(|x| x[0].sin(), &regn, 1000);
    |

warning: unused variable: `jp0`
   --> src/spherical_bessel.rs:451:13
    |
451 |         let jp0 = sphbes_jp(0, 1.0).unwrap();
    |             ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
451 |         let _jp0 = sphbes_jp(0, 1.0).unwrap();
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
451 -         let jp0 = sphbes_jp(0, 1.0).unwrap();
451 +         let constants::CBRT_EPSILON = sphbes_jp(0, 1.0).unwrap();
    |

warning: unused variable: `yp0`
   --> src/spherical_bessel.rs:452:13
    |
452 |         let yp0 = sphbes_yp(0, 1.0).unwrap();
    |             ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
452 |         let _yp0 = sphbes_yp(0, 1.0).unwrap();
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
452 -         let yp0 = sphbes_yp(0, 1.0).unwrap();
452 +         let constants::CBRT_EPSILON = sphbes_yp(0, 1.0).unwrap();
    |

warning: unused variable: `jp_asym`
   --> src/spherical_bessel.rs:521:30
    |
521 |         let (j_asym, y_asym, jp_asym, yp_asym) = sphbes_asymptotic_large_x(2, 10.0);
    |                              ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
521 |         let (j_asym, y_asym, _jp_asym, yp_asym) = sphbes_asymptotic_large_x(2, 10.0);
    |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
521 -         let (j_asym, y_asym, jp_asym, yp_asym) = sphbes_asymptotic_large_x(2, 10.0);
521 +         let (j_asym, y_asym, constants::CBRT_EPSILON, yp_asym) = sphbes_asymptotic_large_x(2, 10.0);
    |

warning: unused variable: `yp_asym`
   --> src/spherical_bessel.rs:521:39
    |
521 |         let (j_asym, y_asym, jp_asym, yp_asym) = sphbes_asymptotic_large_x(2, 10.0);
    |                                       ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
521 |         let (j_asym, y_asym, jp_asym, _yp_asym) = sphbes_asymptotic_large_x(2, 10.0);
    |                                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
521 -         let (j_asym, y_asym, jp_asym, yp_asym) = sphbes_asymptotic_large_x(2, 10.0);
521 +         let (j_asym, y_asym, jp_asym, constants::CBRT_EPSILON) = sphbes_asymptotic_large_x(2, 10.0);
    |

warning: unused variable: `jp_exact`
   --> src/spherical_bessel.rs:522:32
    |
522 |         let (j_exact, y_exact, jp_exact, yp_exact) = sphbes(2, 10.0).unwrap();
    |                                ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
522 |         let (j_exact, y_exact, _jp_exact, yp_exact) = sphbes(2, 10.0).unwrap();
    |                                +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
522 -         let (j_exact, y_exact, jp_exact, yp_exact) = sphbes(2, 10.0).unwrap();
522 +         let (j_exact, y_exact, constants::CBRT_EPSILON, yp_exact) = sphbes(2, 10.0).unwrap();
    |

warning: unused variable: `yp_exact`
   --> src/spherical_bessel.rs:522:42
    |
522 |         let (j_exact, y_exact, jp_exact, yp_exact) = sphbes(2, 10.0).unwrap();
    |                                          ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
522 |         let (j_exact, y_exact, jp_exact, _yp_exact) = sphbes(2, 10.0).unwrap();
    |                                          +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
522 -         let (j_exact, y_exact, jp_exact, yp_exact) = sphbes(2, 10.0).unwrap();
522 +         let (j_exact, y_exact, jp_exact, constants::CBRT_EPSILON) = sphbes(2, 10.0).unwrap();
    |

warning: unused variable: `y_asym_small`
   --> src/spherical_bessel.rs:528:28
    |
528 |         let (j_asym_small, y_asym_small, jp_asym_small, yp_asym_small) =
    |                            ^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
528 |         let (j_asym_small, _y_asym_small, jp_asym_small, yp_asym_small) =
    |                            +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
528 -         let (j_asym_small, y_asym_small, jp_asym_small, yp_asym_small) =
528 +         let (j_asym_small, constants::CBRT_EPSILON, jp_asym_small, yp_asym_small) =
    |

warning: unused variable: `jp_asym_small`
   --> src/spherical_bessel.rs:528:42
    |
528 |         let (j_asym_small, y_asym_small, jp_asym_small, yp_asym_small) =
    |                                          ^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
528 |         let (j_asym_small, y_asym_small, _jp_asym_small, yp_asym_small) =
    |                                          +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
528 -         let (j_asym_small, y_asym_small, jp_asym_small, yp_asym_small) =
528 +         let (j_asym_small, y_asym_small, constants::CBRT_EPSILON, yp_asym_small) =
    |

warning: unused variable: `yp_asym_small`
   --> src/spherical_bessel.rs:528:57
    |
528 |         let (j_asym_small, y_asym_small, jp_asym_small, yp_asym_small) =
    |                                                         ^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
528 |         let (j_asym_small, y_asym_small, jp_asym_small, _yp_asym_small) =
    |                                                         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
528 -         let (j_asym_small, y_asym_small, jp_asym_small, yp_asym_small) =
528 +         let (j_asym_small, y_asym_small, jp_asym_small, constants::CBRT_EPSILON) =
    |

warning: unused variable: `y_exact_small`
   --> src/spherical_bessel.rs:530:29
    |
530 |         let (j_exact_small, y_exact_small, jp_exact_small, yp_exact_small) =
    |                             ^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
530 |         let (j_exact_small, _y_exact_small, jp_exact_small, yp_exact_small) =
    |                             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
530 -         let (j_exact_small, y_exact_small, jp_exact_small, yp_exact_small) =
530 +         let (j_exact_small, constants::CBRT_EPSILON, jp_exact_small, yp_exact_small) =
    |

warning: unused variable: `jp_exact_small`
   --> src/spherical_bessel.rs:530:44
    |
530 |         let (j_exact_small, y_exact_small, jp_exact_small, yp_exact_small) =
    |                                            ^^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
530 |         let (j_exact_small, y_exact_small, _jp_exact_small, yp_exact_small) =
    |                                            +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
530 -         let (j_exact_small, y_exact_small, jp_exact_small, yp_exact_small) =
530 +         let (j_exact_small, y_exact_small, constants::CBRT_EPSILON, yp_exact_small) =
    |

warning: unused variable: `yp_exact_small`
   --> src/spherical_bessel.rs:530:60
    |
530 |         let (j_exact_small, y_exact_small, jp_exact_small, yp_exact_small) =
    |                                                            ^^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
530 |         let (j_exact_small, y_exact_small, jp_exact_small, _yp_exact_small) =
    |                                                            +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
530 -         let (j_exact_small, y_exact_small, jp_exact_small, yp_exact_small) =
530 +         let (j_exact_small, y_exact_small, jp_exact_small, constants::CBRT_EPSILON) =
    |

warning: unused variable: `n`
   --> src/toeplz.rs:322:13
    |
322 |         let n = 3;
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let _n = 3;
    |             +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
    |
322 -         let n = 3;
322 +         let bessel_jy::MAXIT = 3;
    |

Some errors have detailed explanations: E0015, E0061, E0133, E0277, E0282, E0308, E0369, E0423, E0432...
error: could not compile `num_rs` (lib test) due to 150 previous errors; 301 warnings emitted
