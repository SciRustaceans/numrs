   Compiling num_rs v0.1.0 (/home/archdabe/Documents/Numerical-recipies/Rust/numrs)
error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::ArrayView1`
 --> src/beschd.rs:1:15
  |
1 | use ndarray::{Array1, ArrayView1};
  |               ^^^^^^  ^^^^^^^^^^
  |               |       |
  |               |       no `ArrayView1` in the root
  |               |       help: a similar name exists in the module: `ArrayView`
  |               no `Array1` in the root

error[E0432]: unresolved import `std::f64::consts::EULER`
 --> src/Cosine_Sine_Integrals.rs:3:28
  |
3 | use std::f64::consts::{PI, EULER};
  |                            ^^^^^ no `EULER` in `f64::consts`

error[E0432]: unresolved import `std::f64::consts::EULER`
 --> src/ei.rs:1:5
  |
1 | use std::f64::consts::EULER;
  |     ^^^^^^^^^^^^^^^^^^^^^^^ no `EULER` in `f64::consts`

error[E0432]: unresolved import `std::f64::consts::EPSILON`
 --> src/elementary_integration_methods.rs:1:5
  |
1 | use std::f64::consts::EPSILON;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `EPSILON` in `f64::consts`

error[E0432]: unresolved import `std::f64::consts::EULER`
 --> src/exponential_integral.rs:1:5
  |
1 | use std::f64::consts::EULER;
  |     ^^^^^^^^^^^^^^^^^^^^^^^ no `EULER` in `f64::consts`

error[E0432]: unresolved import `std::f64::consts::EPSILON`
 --> src/linbcg.rs:1:5
  |
1 | use std::f64::consts::EPSILON;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `EPSILON` in `f64::consts`

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`
 --> src/orthog.rs:1:15
  |
1 | use ndarray::{Array2, Array1};
  |               ^^^^^^  ^^^^^^ no `Array1` in the root
  |               |
  |               no `Array2` in the root

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`, `ndarray::ArrayView2`, `ndarray::ArrayView1`
 --> src/pade.rs:2:15
  |
2 | use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^ no `ArrayView1` in the root
  |               |       |       |
  |               |       |       no `ArrayView2` in the root
  |               |       no `Array1` in the root
  |               no `Array2` in the root
  |
help: a similar name exists in the module
  |
2 - use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
2 + use ndarray::{Array2, Array1, ArrayView, ArrayView1};
  |
help: a similar name exists in the module
  |
2 - use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
2 + use ndarray::{Array2, Array1, ArrayView2, ArrayView};
  |

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::ArrayView1`
 --> src/polcof.rs:3:15
  |
3 | use ndarray::{Array1, ArrayView1};
  |               ^^^^^^  ^^^^^^^^^^
  |               |       |
  |               |       no `ArrayView1` in the root
  |               |       help: a similar name exists in the module: `ArrayView`
  |               no `Array1` in the root

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::ArrayView1`, `ndarray::ArrayViewMut1`
 --> src/polydiv.rs:4:15
  |
4 | use ndarray::{Array1, ArrayView1, ArrayViewMut1};
  |               ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^^^ no `ArrayViewMut1` in the root
  |               |       |
  |               |       no `ArrayView1` in the root
  |               no `Array1` in the root
  |
help: a similar name exists in the module
  |
4 - use ndarray::{Array1, ArrayView1, ArrayViewMut1};
4 + use ndarray::{Array1, ArrayView, ArrayViewMut1};
  |
help: a similar name exists in the module
  |
4 - use ndarray::{Array1, ArrayView1, ArrayViewMut1};
4 + use ndarray::{Array1, ArrayView1, ArrayViewMut};
  |

error[E0432]: unresolved import `std::f64::consts::EPSILON`
 --> src/qrdcmp.rs:3:5
  |
3 | use std::f64::consts::EPSILON as F64_EPSILON;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `EPSILON` in `f64::consts`

error: no rules expected `"Failed for degree {}"`
   --> src/gaucof.rs:456:67
    |
456 |             assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error: no rules expected `"Failed for degree {}"`
   --> src/gauher.rs:406:71
    |
406 |                 assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                       ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error: no rules expected `"Failed for degree {}"`
   --> src/gauher.rs:408:69
    |
408 |                 assert_abs_diff_eq!(computed, 0.0, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                     ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error: no rules expected `"Failed for degree {}"`
   --> src/gaujac.rs:437:67
    |
437 |             assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error: no rules expected `"Failed for degree {}"`
   --> src/gaulag.rs:425:67
    |
425 |             assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error: no rules expected `"Failed for degree {}"`
   --> src/gauleg.rs:416:67
    |
416 |             assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`, `ndarray::ArrayView2`, `ndarray::ArrayView1`
 --> src/ratlsq.rs:2:15
  |
2 | use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^ no `ArrayView1` in the root
  |               |       |       |
  |               |       |       no `ArrayView2` in the root
  |               |       no `Array1` in the root
  |               no `Array2` in the root
  |
help: a similar name exists in the module
  |
2 - use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
2 + use ndarray::{Array2, Array1, ArrayView, ArrayView1};
  |
help: a similar name exists in the module
  |
2 - use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
2 + use ndarray::{Array2, Array1, ArrayView2, ArrayView};
  |

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::ArrayView1`
 --> src/ratval.rs:4:15
  |
4 | use ndarray::{Array1, ArrayView1};
  |               ^^^^^^  ^^^^^^^^^^
  |               |       |
  |               |       no `ArrayView1` in the root
  |               |       help: a similar name exists in the module: `ArrayView`
  |               no `Array1` in the root

error[E0432]: unresolved imports `ndarray::Array3`, `ndarray::Array2`, `ndarray::ArrayViewMut3`, `ndarray::ArrayViewMut2`
 --> src/Real_FT3.rs:3:15
  |
3 | use ndarray::{Array3, Array2, ArrayViewMut3, ArrayViewMut2};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^ no `ArrayViewMut2` in the root
  |               |       |       |
  |               |       |       no `ArrayViewMut3` in the root
  |               |       no `Array2` in the root
  |               no `Array3` in the root
  |
help: a similar name exists in the module
  |
3 - use ndarray::{Array3, Array2, ArrayViewMut3, ArrayViewMut2};
3 + use ndarray::{Array3, Array2, ArrayViewMut, ArrayViewMut2};
  |
help: a similar name exists in the module
  |
3 - use ndarray::{Array3, Array2, ArrayViewMut3, ArrayViewMut2};
3 + use ndarray::{Array3, Array2, ArrayViewMut3, ArrayViewMut};
  |

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::Array2`
 --> src/Recursive_Stratified_Sampling.rs:4:15
  |
4 | use ndarray::{Array1, Array2};
  |               ^^^^^^  ^^^^^^ no `Array2` in the root
  |               |
  |               no `Array1` in the root

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`, `ndarray::ArrayView1`, `ndarray::ArrayViewMut1`
 --> src/splie2.rs:1:15
  |
1 | use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^^^ no `ArrayViewMut1` in the root
  |               |       |       |
  |               |       |       no `ArrayView1` in the root
  |               |       no `Array1` in the root
  |               no `Array2` in the root
  |
help: a similar name exists in the module
  |
1 - use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
1 + use ndarray::{Array2, Array1, ArrayView, ArrayViewMut1};
  |
help: a similar name exists in the module
  |
1 - use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
1 + use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut};
  |

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`, `ndarray::ArrayView1`, `ndarray::ArrayViewMut1`
 --> src/splin2.rs:1:15
  |
1 | use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^^^ no `ArrayViewMut1` in the root
  |               |       |       |
  |               |       |       no `ArrayView1` in the root
  |               |       no `Array1` in the root
  |               no `Array2` in the root
  |
help: a similar name exists in the module
  |
1 - use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
1 + use ndarray::{Array2, Array1, ArrayView, ArrayViewMut1};
  |
help: a similar name exists in the module
  |
1 - use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
1 + use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut};
  |

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::Array2`
 --> src/utils.rs:1:15
  |
1 | use ndarray::{Array1, Array2};
  |               ^^^^^^  ^^^^^^ no `Array2` in the root
  |               |
  |               no `Array1` in the root

error[E0432]: unresolved imports `bessel_j::bessel_j0`, `bessel_j::bessel_j1`, `bessel_j::bessel_jn`
   --> src/lib.rs:116:20
    |
116 | pub use bessel_j::{bessel_j0, bessel_j1, bessel_jn};
    |                    ^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^ no `bessel_jn` in `bessel_j`
    |                    |          |
    |                    |          no `bessel_j1` in `bessel_j`
    |                    no `bessel_j0` in `bessel_j`
    |
note: these modules exist but are inaccessible
   --> src/bessel_yn.rs:128:1
    |
128 | mod bessel_j0 {
    | ^^^^^^^^^^^^^ `crate::bessel_yn::bessel_j0`: not accessible
    |
   ::: src/bessy0.rs:6:1
    |
  6 | mod bessel_j0 {
    | ^^^^^^^^^^^^^ `crate::bessy0::bessel_j0`: not accessible
note: these modules exist but are inaccessible
   --> src/bessel_y1.rs:8:1
    |
  8 | mod bessel_j1 {
    | ^^^^^^^^^^^^^ `crate::bessel_y1::bessel_j1`: not accessible
    |
   ::: src/bessel_yn.rs:182:1
    |
182 | mod bessel_j1 {
    | ^^^^^^^^^^^^^ `crate::bessel_yn::bessel_j1`: not accessible
help: a similar name exists in the module
    |
116 - pub use bessel_j::{bessel_j0, bessel_j1, bessel_jn};
116 + pub use bessel_j::{bessj0, bessel_j1, bessel_jn};
    |
help: a similar name exists in the module
    |
116 - pub use bessel_j::{bessel_j0, bessel_j1, bessel_jn};
116 + pub use bessel_j::{bessel_j0, bessj1, bessel_jn};
    |

error[E0432]: unresolved import `beta::ln_beta`
   --> src/lib.rs:118:22
    |
118 | pub use beta::{beta, ln_beta};
    |                      ^^^^^^^ no `ln_beta` in `beta`

error[E0432]: unresolved import `crate::ndarray`
 --> src/Convolve.rs:4:12
  |
4 | use crate::ndarray::{Array1, ArrayView, ArrayViewMut, s};/// Convolution/Deconvolution implementation with FFT optimization
  |            ^^^^^^^ could not find `ndarray` in the crate root

error[E0432]: unresolved import `crate::ndarray`
 --> src/Correlation.rs:3:12
  |
3 | use crate::ndarray::{Array1, ArrayView1, ArrayViewMut1, s};
  |            ^^^^^^^ could not find `ndarray` in the crate root

error[E0432]: unresolved import `special`
 --> src/gaujac.rs:5:5
  |
5 | use special::Gamma;
  |     ^^^^^^^ use of unresolved module or unlinked crate `special`
  |
  = help: if you wanted to use a crate named `special`, use `cargo add special` to add it to your `Cargo.toml`

error[E0432]: unresolved import `special`
 --> src/gaulag.rs:5:5
  |
5 | use special::Gamma;
  |     ^^^^^^^ use of unresolved module or unlinked crate `special`
  |
  = help: if you wanted to use a crate named `special`, use `cargo add special` to add it to your `Cargo.toml`

error[E0432]: unresolved import `sprs`
 --> src/sprspm.rs:1:5
  |
1 | use sprs::{CsMat, CsVec};
  |     ^^^^ use of unresolved module or unlinked crate `sprs`
  |
  = help: if you wanted to use a crate named `sprs`, use `cargo add sprs` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `airy::ai`, `airy::bi`, `airy::ai_deriv`, `airy::bi_deriv`
   --> src/lib.rs:115:16
    |
115 | pub use airy::{ai, bi, ai_deriv, bi_deriv};
    |                ^^  ^^  ^^^^^^^^  ^^^^^^^^ no `bi_deriv` in `airy`
    |                |   |   |
    |                |   |   no `ai_deriv` in `airy`
    |                |   no `bi` in `airy`
    |                no `ai` in `airy`

error[E0432]: unresolved import `bessel_y1::bessel_y1`
   --> src/lib.rs:117:9
    |
117 | pub use bessel_y1::bessel_y1;
    |         ^^^^^^^^^^^---------
    |         |          |
    |         |          help: a similar name exists in the module: `bessel_j1`
    |         no `bessel_y1` in `bessel_y1`
    |
note: module `crate::bessel_yn::bessel_y1` exists but is inaccessible
   --> src/bessel_yn.rs:66:1
    |
 66 | mod bessel_y1 {
    | ^^^^^^^^^^^^^ not accessible

error: could not compile `num_rs` (lib test) due to 6 previous errors
warning: build failed, waiting for other jobs to finish...
error[E0425]: cannot find value `fac` in this scope
  --> src/pccheb.rs:85:30
   |
85 |                 *c.add(j) += fac;
   |                              ^^^
   |
help: the binding `fac` is available in a different scope in the same function
  --> src/pccheb.rs:74:21
   |
74 |             let mut fac = *d.add(k) / pow;
   |                     ^^^

error[E0425]: cannot find value `fac` in this scope
  --> src/pccheb.rs:87:13
   |
87 |             fac *= jm / jp;
   |             ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
  --> src/pccheb.rs:93:30
   |
93 |                 *c.add(j) += fac;
   |                              ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
  --> src/pccheb.rs:95:13
   |
95 |             fac *= jm / jp;
   |             ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:101:30
    |
101 |                 *c.add(j) += fac;
    |                              ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:103:13
    |
103 |             fac *= jm / jp;
    |             ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:109:30
    |
109 |                 *c.add(j) += fac;
    |                              ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:111:13
    |
111 |             fac *= jm / jp;
    |             ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:120:30
    |
120 |                 *c.add(j) += fac;
    |                              ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:123:17
    |
123 |                 fac *= jm / jp;
    |                 ^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `constants`
   --> src/spherical_bessel.rs:315:9
    |
315 |     let constants::CBRT_EPSILON = 1.0 / (x * x);
    |         ^^^^^^^^^ use of unresolved module or unlinked crate `constants`
    |
    = help: if you wanted to use a crate named `constants`, use `cargo add constants` to add it to your `Cargo.toml`
help: consider importing this module
    |
  1 + use crate::constants;
    |

warning: unexpected `cfg` condition value: `bench`
   --> src/airy.rs:717:7
    |
717 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `std::mem`
 --> src/bandec.rs:1:5
  |
1 | use std::mem;
  |     ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `approx::assert_abs_diff_eq`
 --> src/bcuint.rs:2:5
  |
2 | use approx::assert_abs_diff_eq;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts`
 --> src/bessel_I1.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_j1.rs:423:7
    |
423 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `PI`
 --> src/bessel_j1.rs:1:24
  |
1 | use std::f64::consts::{PI, FRAC_PI_4};
  |                        ^^

warning: unnecessary parentheses around assigned value
   --> src/bessel_jy.rs:172:14
    |
172 |         p /= (i_f64 - xmu);
    |              ^           ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
172 -         p /= (i_f64 - xmu);
172 +         p /= i_f64 - xmu ;
    |

warning: unnecessary parentheses around assigned value
   --> src/bessel_jy.rs:173:14
    |
173 |         q /= (i_f64 + xmu);
    |              ^           ^
    |
help: remove these parentheses
    |
173 -         q /= (i_f64 + xmu);
173 +         q /= i_f64 + xmu ;
    |

warning: unexpected `cfg` condition value: `parallel`
   --> src/bessel_k0.rs:323:7
    |
323 | #[cfg(feature = "parallel")]
    |       ^^^^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `parallel` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `std::f64::consts`
 --> src/bessel_k0.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts`
 --> src/bessel_k1.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_y1.rs:550:7
    |
550 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `PI`
 --> src/bessel_y1.rs:1:24
  |
1 | use std::f64::consts::{PI, FRAC_PI_4};
  |                        ^^

warning: unused import: `super::*`
 --> src/bessel_y1.rs:9:9
  |
9 |     use super::*;
  |         ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_yn.rs:583:7
    |
583 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `super::*`
 --> src/bessel_yn.rs:7:9
  |
7 |     use super::*;
  |         ^^^^^^^^

warning: unused import: `super::*`
  --> src/bessel_yn.rs:67:9
   |
67 |     use super::*;
   |         ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessik.rs:471:7
    |
471 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `FRAC_PI_2`
 --> src/bessik.rs:1:28
  |
1 | use std::f64::consts::{PI, FRAC_PI_2};
  |                            ^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessj0.rs:390:7
    |
390 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/bessy0.rs:515:7
    |
515 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/beta.rs:184:7
    |
184 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `std::f32::consts::LN_2`
 --> src/beta.rs:1:5
  |
1 | use std::f32::consts::LN_2;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
 --> src/beta.rs:2:5
  |
2 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^

warning: unused import: `std::sync::OnceLock`
 --> src/Carlson_elliptic_integral_first.rs:4:5
  |
4 | use std::sync::OnceLock;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ptr`
 --> src/chebpc.rs:1:5
  |
1 | use std::ptr;
  |     ^^^^^^^^

warning: unused import: `std::f64::consts::PI`
 --> src/Convolve.rs:1:5
  |
1 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `SQRT_2`
 --> src/dawson_integral.rs:3:28
  |
3 | use std::f64::consts::{PI, SQRT_2};
  |                            ^^^^^^

warning: unused import: `Arc`
 --> src/ddpoly.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/ei.rs:315:7
    |
315 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/error_functions.rs:440:7
    |
440 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `SQRT_2`
 --> src/error_functions.rs:1:28
  |
1 | use std::f32::consts::{PI, SQRT_2};
  |                            ^^^^^^

warning: unused doc comment
  --> src/eulsum.rs:92:1
   |
92 | /// Thread-local Euler summation for better performance in single-threaded contexts
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion
   = note: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Arc`
 --> src/eulsum.rs:1:17
  |
1 | use std::sync::{Arc, Mutex, RwLock};
  |                 ^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/exponential_integral.rs:313:7
    |
313 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `SeekFrom` and `Seek`
 --> src/Four_FS.rs:2:15
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |               ^^^^  ^^^^^^^^

warning: unused imports: `Arc` and `Mutex`
 --> src/Four_FS.rs:6:17
  |
6 | use std::sync::{Arc, Mutex};
  |                 ^^^  ^^^^^

warning: unused imports: `SeekFrom` and `Seek`
 --> src/Fourn.rs:2:15
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |               ^^^^  ^^^^^^^^

warning: unused imports: `Arc` and `Mutex`
 --> src/Fourn.rs:6:17
  |
6 | use std::sync::{Arc, Mutex};
  |                 ^^^  ^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/gamma_continued_funciton.rs:335:7
    |
335 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/gamma_continued_funciton.rs:1:24
  |
1 | use std::f32::consts::{E, PI};
  |                        ^

warning: unexpected `cfg` condition value: `bench`
   --> src/gamma_series.rs:329:7
    |
329 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `E` and `LN_2`
 --> src/gamma_series.rs:1:24
  |
1 | use std::f32::consts::{E, LN_2, PI};
  |                        ^  ^^^^

warning: unused doc comment
  --> src/gammln.rs:23:1
   |
23 | /// Thread-local cache for frequently computed values
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused import: `std::mem`
 --> src/gaussjdcp.rs:1:5
  |
1 | use std::mem;
  |     ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/inc_beta_func.rs:398:7
    |
398 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/inc_beta_func.rs:1:24
  |
1 | use std::f64::consts::{E, PI};
  |                        ^

warning: unexpected `cfg` condition value: `bench`
   --> src/incomplete_gamma.rs:326:7
    |
326 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/incomplete_gamma.rs:1:24
  |
1 | use std::f32::consts::{E, PI};
  |                        ^

warning: unused import: `std::f64::consts::FRAC_1_PI`
 --> src/Jacobian_elliptical.rs:2:5
  |
2 | use std::f64::consts::FRAC_1_PI;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Arc`
 --> src/pade.rs:3:17
  |
3 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `std::ptr`
 --> src/pccheb.rs:2:5
  |
2 | use std::ptr;
  |     ^^^^^^^^

warning: unused import: `Arc`
 --> src/polydiv.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `rayon::prelude::*`
 --> src/quad3d.rs:1:5
  |
1 | use rayon::prelude::*;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Mutex`
 --> src/quad3d.rs:2:22
  |
2 | use std::sync::{Arc, Mutex};
  |                      ^^^^^

warning: unused import: `std::f64::consts::PI`
 --> src/quad3d.rs:3:5
  |
3 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Arc`
 --> src/random_0.rs:3:17
  |
3 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_0.rs:141:11
    |
141 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_1.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_1.rs:3:5
  |
3 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_1.rs:213:11
    |
213 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_2.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_2.rs:3:5
  |
3 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_2.rs:281:11
    |
281 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_3.rs:1:17
  |
1 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_3.rs:2:5
  |
2 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_3.rs:259:11
    |
259 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `std::f64::consts`
 --> src/Recursive_Stratified_Sampling.rs:7:5
  |
7 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::*`
   --> src/lib.rs:191:13
    |
191 |     pub use std::f64::consts::*;
    |             ^^^^^^^^^^^^^^^^^^^

error[E0277]: cannot multiply `f64` by `T`
   --> src/beschd.rs:147:26
    |
147 |         return PI / ((PI * x).sin() * lanczos_gamma(T::one() - x));
    |                          ^ no implementation for `f64 * T`
    |
    = help: the trait `Mul<T>` is not implemented for `f64`
help: consider extending the `where` clause, but there might be an alternative better way to express this requirement
    |
130 |     T: BesselFloat, f64: Mul<T>
    |                     +++++++++++

error[E0282]: type annotations needed
   --> src/beschd.rs:147:31
    |
147 |         return PI / ((PI * x).sin() * lanczos_gamma(T::one() - x));
    |                               ^^^ cannot infer type

error[E0308]: mismatched types
   --> src/beschd.rs:147:16
    |
128 | fn lanczos_gamma<T>(z: T) -> T
    |                  -           - expected `T` because of return type
    |                  |
    |                  expected this type parameter
...
147 |         return PI / ((PI * x).sin() * lanczos_gamma(T::one() - x));
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `f64`
    |
    = note: expected type parameter `T`
                         found type `f64`
    = note: the caller chooses a type for `T` which can be different from `f64`

error[E0368]: binary assignment operation `-=` cannot be applied to type `T`
   --> src/beschd.rs:150:5
    |
150 |     x -= T::one();
    |     -^^^^^^^^^^^^
    |     |
    |     cannot use `-=` on type `T`
    |
help: consider further restricting type parameter `T` with trait `SubAssign`
    |
130 |     T: BesselFloat + std::ops::SubAssign,
    |                    +++++++++++++++++++++

error[E0368]: binary assignment operation `+=` cannot be applied to type `T`
   --> src/beschd.rs:154:9
    |
154 |         a += p_val / (x + T::from_i32(i as i32 + 1).unwrap());
    |         -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |         |
    |         cannot use `+=` on type `T`

error[E0308]: mismatched types
   --> src/beschd.rs:158:34
    |
128 | fn lanczos_gamma<T>(z: T) -> T
    |                  - expected this type parameter
...
158 |     (T::from_f64(2.0).unwrap() * PI).sqrt() * t.powf(x + T::from_f64(0.5).unwrap()) * (-t).exp() * a
    |      -------------------------   ^^ expected type parameter `T`, found `f64`
    |      |
    |      expected because this is `T`
    |
    = note: expected type parameter `T`
                         found type `f64`

error[E0308]: mismatched types
   --> src/beschd.rs:166:40
    |
162 | pub fn beschd_multithreaded<T>(x_values: &ArrayView1<T>, num_threads: usize) -> Array1<(T, T, T, T)>
    |                             - expected this type parameter
...
166 |     let chunk_size = (x_values.len() + num_threads - 1) / num_threads;
    |                                        ^^^^^^^^^^^ expected type parameter `T`, found `usize`
    |
    = note: expected type parameter `T`
                         found type `usize`

error[E0308]: mismatched types
   --> src/beschd.rs:166:54
    |
162 | pub fn beschd_multithreaded<T>(x_values: &ArrayView1<T>, num_threads: usize) -> Array1<(T, T, T, T)>
    |                             - expected this type parameter
...
166 |     let chunk_size = (x_values.len() + num_threads - 1) / num_threads;
    |                                                      ^ expected type parameter `T`, found integer
    |
    = note: expected type parameter `T`
                         found type `{integer}`

error[E0308]: mismatched types
   --> src/beschd.rs:166:59
    |
162 | pub fn beschd_multithreaded<T>(x_values: &ArrayView1<T>, num_threads: usize) -> Array1<(T, T, T, T)>
    |                             - expected this type parameter
...
166 |     let chunk_size = (x_values.len() + num_threads - 1) / num_threads;
    |                                                           ^^^^^^^^^^^ expected type parameter `T`, found `usize`
    |
    = note: expected type parameter `T`
                         found type `usize`

error[E0282]: type annotations needed
   --> src/beschd.rs:169:15
    |
169 |         .map(|chunk| chunk.to_owned())
    |               ^^^^^        -------- type must be known at this point
    |
help: consider giving this closure parameter an explicit type
    |
169 |         .map(|chunk: /* Type */| chunk.to_owned())
    |                    ++++++++++++

error[E0282]: type annotations needed
   --> src/beschd.rs:180:58
    |
180 |             let chunk_results: Vec<(T, T, T, T)> = chunk.iter()
    |                                                          ^^^^ cannot infer type

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_i.rs:195:10
     |
 195 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 153 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_i.rs:300:10
     |
 300 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 266 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_I1.rs:179:10
     |
 179 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 147 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_j.rs:314:10
     |
 314 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 282 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: cannot multiply `i32` by `f64`
  --> src/bessel_jy.rs:51:25
   |
51 |     let mut rjl = isign * FPMIN;
   |                         ^ no implementation for `i32 * f64`
   |
   = help: the trait `Mul<f64>` is not implemented for `i32`
   = help: the following other types implement trait `Mul<Rhs>`:
             `&i32` implements `Mul<&Complex<i32>>`
             `&i32` implements `Mul<&num_complex::Complex<i32>>`
             `&i32` implements `Mul<Complex<i32>>`
             `&i32` implements `Mul<i32>`
             `&i32` implements `Mul<num_complex::Complex<i32>>`
             `&i32` implements `Mul`
             `i32` implements `Mul<&ArrayBase<S, D>>`
             `i32` implements `Mul<&Complex<i32>>`
           and 7 others

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_jy.rs:327:10
     |
 327 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `(T, T, T, T)` to implement `Debug`
     = note: 3 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<(T, T, T, T)>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 294 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0369]: cannot multiply `T` by `T`
  --> src/bessel_k0.rs:61:55
   |
61 |     coeffs.iter().rev().fold(T::zero(), |acc, &c| acc * x + c)
   |                                                   --- ^ - T
   |                                                   |
   |                                                   T
   |
help: consider further restricting type parameter `T` with trait `Mul`
   |
60 | fn polynomial_eval<T: BesselFloat + std::ops::Mul>(x: T, coeffs: &[T]) -> T {
   |                                   +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
  --> src/bessel_k0.rs:76:19
   |
76 |         let y = x * x / T::from_f64(4.0);
   |                 - ^ - T
   |                 |
   |                 T
   |
help: consider further restricting type parameter `T` with trait `Mul`
   |
68 |     T: BesselFloat + std::ops::Mul,
   |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
  --> src/bessel_k0.rs:94:14
   |
94 |         -((x / T::from_f64(2.0)).ln() * i0) + poly
   |            - ^ ---------------- T
   |            |
   |            T
   |
help: consider further restricting type parameter `T` with trait `Div`
   |
68 |     T: BesselFloat + std::ops::Div,
   |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
  --> src/bessel_k0.rs:97:34
   |
97 |         let y = T::from_f64(2.0) / x;
   |                 ---------------- ^ - T
   |                 |
   |                 T
   |
help: consider further restricting type parameter `T` with trait `Div`
   |
68 |     T: BesselFloat + std::ops::Div,
   |                    +++++++++++++++

error[E0600]: cannot apply unary operator `-` to type `T`
   --> src/bessel_k0.rs:113:9
    |
113 |         (-x).exp() / x.sqrt() * poly
    |         ^^^^ cannot apply unary operator `-`
    |
help: consider further restricting type parameter `T` with trait `Neg`
    |
 68 |     T: BesselFloat + std::ops::Neg,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:125:20
    |
125 |         let y = (x / T::from_f64(3.75)).powi(2);
    |                  - ^ ----------------- T
    |                  |
    |                  T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
120 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:139:35
    |
139 |         let y = T::from_f64(3.75) / ax;
    |                 ----------------- ^ -- T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
120 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:165:20
    |
165 |         let y = (x / T::from_f64(3.75)).powi(2);
    |                  - ^ ----------------- T
    |                  |
    |                  T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
160 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:179:35
    |
179 |         let y = T::from_f64(3.75) / ax;
    |                 ----------------- ^ -- T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
160 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
   --> src/bessel_k0.rs:213:19
    |
213 |         let y = x * x / T::from_f64(4.0);
    |                 - ^ - T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Mul`
    |
206 |     T: BesselFloat + std::ops::Mul,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:229:12
    |
229 |         (x / T::from_f64(2.0)).ln() * i1 + (T::one() / x) * poly
    |          - ^ ---------------- T
    |          |
    |          T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:229:54
    |
229 |         (x / T::from_f64(2.0)).ln() * i1 + (T::one() / x) * poly
    |                                             -------- ^ - T
    |                                             |
    |                                             T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:231:34
    |
231 |         let y = T::from_f64(2.0) / x;
    |                 ---------------- ^ - T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0600]: cannot apply unary operator `-` to type `T`
   --> src/bessel_k0.rs:246:9
    |
246 |         (-x).exp() / x.sqrt() * poly
    |         ^^^^ cannot apply unary operator `-`
    |
help: consider further restricting type parameter `T` with trait `Neg`
    |
206 |     T: BesselFloat + std::ops::Neg,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:267:40
    |
267 |             let tox = T::from_f64(2.0) / x;
    |                       ---------------- ^ - T
    |                       |
    |                       T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
253 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
   --> src/bessel_k0.rs:272:54
    |
272 |                 let bkp = bkm + T::from_i32(k) * tox * bk;
    |                                 -------------------- ^ -- T
    |                                 |
    |                                 T
    |
help: consider further restricting type parameter `T` with trait `Mul`
    |
253 |     T: BesselFloat + std::ops::Mul,
    |                    +++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_k1.rs:260:10
     |
 260 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 228 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0599]: the method `get` exists for struct `std::sync::MutexGuard<'_, HashMap<f64, f64>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:114:42
    |
114 |             if let Some(&result) = cache.get(&x) {
    |                                          ^^^ method cannot be called on `std::sync::MutexGuard<'_, HashMap<f64, f64>>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            `f64: Hash`

error[E0599]: the method `insert` exists for struct `std::sync::MutexGuard<'_, HashMap<f64, f64>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:124:19
    |
124 |             cache.insert(x, result);
    |                   ^^^^^^
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            `f64: Hash`

error[E0599]: the method `entry` exists for struct `MutexGuard<'_, HashMap<(f64, f64, usize), Arc<...>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:227:15
    |
227 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64, usize): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64, usize): Hash`
    = note: the full name for the type has been written to '/home/archdabe/Documents/Numerical-recipies/Rust/numrs/target/debug/deps/num_rs-dd87f36d2e460a72.long-type-16049962890009306149.txt'
    = note: consider using `--verbose` to print the full type name to the console

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), Arc<ChebyshevOperator>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_calc.rs:293:15
    |
293 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), Arc<ChebyshevOperator>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_calc.rs:306:15
    |
306 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0061]: this function takes 2 arguments but 4 arguments were supplied
   --> src/Correlation.rs:196:38
    |
196 |       let (mean1, mean2, std1, std2) = rayon::join(
    |                                        ^^^^^^^^^^^
...
199 | /         || {
200 | |             let mean1 = data1.iter().sum::<f64>() / n as f64;
201 | |             (data1.iter().map(|&x| (x - mean1).powi(2)).sum::<f64>() / n as f64).sqrt()
202 | |         },
    | |_________- unexpected argument #3 of type `{closure@src/Correlation.rs:199:9: 199:11}`
203 | /         || {
204 | |             let mean2 = data2.iter().sum::<f64>() / n as f64;
205 | |             (data2.iter().map(|&x| (x - mean2).powi(2)).sum::<f64>() / n as f64).sqrt()
206 | |         },
    | |_________- unexpected argument #4 of type `{closure@src/Correlation.rs:203:9: 203:11}`
    |
note: function defined here
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-core-1.13.0/src/join/mod.rs:93:8
    |
 93 | pub fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)
    |        ^^^^
help: remove the extra arguments
    |
198 -         || data2.iter().sum::<f64>() / n as f64,
199 -         || {
200 -             let mean1 = data1.iter().sum::<f64>() / n as f64;
201 -             (data1.iter().map(|&x| (x - mean1).powi(2)).sum::<f64>() / n as f64).sqrt()
202 -         },
198 +         || data2.iter().sum::<f64>() / n as f64,
    |

error[E0308]: mismatched types
   --> src/Correlation.rs:196:9
    |
196 |       let (mean1, mean2, std1, std2) = rayon::join(
    |  _________^^^^^^^^^^^^^^^^^^^^^^^^^^___-
    | |         |
    | |         expected a tuple with 2 elements, found one with 4 elements
197 | |         || data1.iter().sum::<f64>() / n as f64,
198 | |         || data2.iter().sum::<f64>() / n as f64,
199 | |         || {
...   |
206 | |         },
207 | |     );
    | |_____- this expression has type `(f64, f64)`
    |
    = note: expected tuple `(f64, f64)`
               found tuple `(_, _, _, _)`

error[E0599]: the method `zip` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
  --> src/Cos_FT.rs:38:10
   |
36 |       let partial_sums: Vec<f64> = (2..=half_n)
   |  __________________________________-
37 | |         .into_par_iter()
38 | |         .zip(rotation_factors.par_iter())
   | |_________-^^^
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
   |
45 |   pub struct Iter<T> {
   |   ------------------ doesn't satisfy `_: IndexedParallelIterator` or `rayon::range_inclusive::Iter<usize>: Iterator`
   |
   = note: the following trait bounds were not satisfied:
           `usize: range_inclusive::private::IndexedRangeInteger`
           which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`
           `rayon::range_inclusive::Iter<usize>: Iterator`
           which is required by `&mut rayon::range_inclusive::Iter<usize>: Iterator`

error[E0599]: the method `chunks` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
  --> src/Cos_FT.rs:97:32
   |
97 |     (2..=n>>1).into_par_iter().chunks(chunk_size).for_each(|chunk| {
   |                                ^^^^^^ method cannot be called on `rayon::range_inclusive::Iter<usize>` due to unsatisfied trait bounds
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
   |
45 | pub struct Iter<T> {
   | ------------------ doesn't satisfy `_: IndexedParallelIterator`
   |
   = note: the following trait bounds were not satisfied:
           `usize: range_inclusive::private::IndexedRangeInteger`
           which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`

error[E0689]: can't call method `to_bits` on ambiguous numeric type `{float}`
   --> src/Cos_FT.rs:123:40
    |
123 |         let local_sum_bits = local_sum.to_bits();
    |                                        ^^^^^^^
    |
help: you must specify a type for this binding, like `f32`
    |
100 |         let mut local_sum: f32 = 0.0;
    |                          +++++

error[E0599]: the method `into_par_iter` exists for struct `std::iter::StepBy<std::ops::RangeInclusive<usize>>`, but its trait bounds were not satisfied
  --> src/Cos_FT2.rs:66:10
   |
65 | /     (3..=n).step_by(2)
66 | |         .into_par_iter()
   | |_________-^^^^^^^^^^^^^
   |
  ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:16:1
   |
16 |   pub struct StepBy<I> {
   |   -------------------- doesn't satisfy `_: IntoParallelIterator` or `_: ParallelIterator`
   |
   = note: the following trait bounds were not satisfied:
           `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
           `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
           `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`

error[E0599]: the method `into_par_iter` exists for struct `std::iter::StepBy<std::ops::RangeInclusive<usize>>`, but its trait bounds were not satisfied
   --> src/Cos_FT2.rs:120:10
    |
119 | /     (3..=n).step_by(2)
120 | |         .into_par_iter()
    | |_________-^^^^^^^^^^^^^
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:16:1
    |
 16 |   pub struct StepBy<I> {
    |   -------------------- doesn't satisfy `_: IntoParallelIterator` or `_: ParallelIterator`
    |
    = note: the following trait bounds were not satisfied:
            `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
            `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
            `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`

error[E0599]: the method `chunks` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
   --> src/Cos_FT2.rs:142:34
    |
142 |     (1..=half_n).into_par_iter().chunks(chunk_size).for_each(|chunk| {
    |                                  ^^^^^^ method cannot be called on `rayon::range_inclusive::Iter<usize>` due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
    |
 45 | pub struct Iter<T> {
    | ------------------ doesn't satisfy `_: IndexedParallelIterator`
    |
    = note: the following trait bounds were not satisfied:
            `usize: range_inclusive::private::IndexedRangeInteger`
            which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`

error[E0600]: cannot apply unary operator `-` to type `usize`
  --> src/Cosine_Sine_Integrals.rs:79:17
   |
79 |         let a = -((i - 1) * (i - 1)) as f64;
   |                 ^^^^^^^^^^^^^^^^^^^^ cannot apply unary operator `-`
   |
   = note: unsigned values cannot be negated

error[E0599]: no method named `abs_diff` found for type `f64` in the current scope
   --> src/Cosine_Sine_Integrals.rs:274:22
    |
274 |         if del.abs().abs_diff(1.0) < EPS {
    |                      ^^^^^^^^
    |
help: there is a method `abs_diff_eq` with a similar name, but with different arguments
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/abs_diff_eq.rs:21:5
    |
 21 |     fn abs_diff_eq(&self, other: &Rhs, epsilon: Self::Epsilon) -> bool;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<Vec<f64>, PolynomialDifferentiator>>`, but its trait bounds were not satisfied
   --> src/ddpoly.rs:171:15
    |
171 |         cache.entry(key.clone())
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<f64>: Hash` or `Vec<f64>: std::cmp::Eq`
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `Vec<f64>: std::cmp::Eq`
            `f64: Hash`
            which is required by `Vec<f64>: Hash`

error[E0599]: the method `get` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), (f64, f64)>>`, but its trait bounds were not satisfied
   --> src/dfridr.rs:122:42
    |
122 |             if let Some(&result) = cache.get(&key) {
    |                                          ^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0599]: the method `insert` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), (f64, f64)>>`, but its trait bounds were not satisfied
   --> src/dfridr.rs:133:19
    |
133 |             cache.insert(key, result);
    |                   ^^^^^^
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0277]: `F` cannot be shared between threads safely
   --> src/dfridr.rs:209:28
    |
209 |     let estimated = dfridr(func, x, h, &mut err);
    |                     ------ ^^^^ `F` cannot be shared between threads safely
    |                     |
    |                     required by a bound introduced by this call
    |
note: required by a bound in `dfridr`
   --> src/dfridr.rs:24:25
    |
 22 | pub fn dfridr<F>(func: F, x: f64, h: f64, err: &mut f64) -> f64 
    |        ------ required by a bound in this function
 23 | where
 24 |     F: Fn(f64) -> f64 + Sync + Send,
    |                         ^^^^ required by this bound in `dfridr`
help: use parentheses to call this type parameter
    |
209 |     let estimated = dfridr(func(/* f64 */), x, h, &mut err);
    |                                +++++++++++
help: consider further restricting type parameter `F` with trait `Sync`
    |
205 |     F: Fn(f64) -> f64 + std::marker::Sync,
    |                       +++++++++++++++++++

error[E0277]: `F` cannot be sent between threads safely
   --> src/dfridr.rs:209:28
    |
209 |     let estimated = dfridr(func, x, h, &mut err);
    |                     ------ ^^^^ `F` cannot be sent between threads safely
    |                     |
    |                     required by a bound introduced by this call
    |
note: required by a bound in `dfridr`
   --> src/dfridr.rs:24:32
    |
 22 | pub fn dfridr<F>(func: F, x: f64, h: f64, err: &mut f64) -> f64 
    |        ------ required by a bound in this function
 23 | where
 24 |     F: Fn(f64) -> f64 + Sync + Send,
    |                                ^^^^ required by this bound in `dfridr`
help: use parentheses to call this type parameter
    |
209 |     let estimated = dfridr(func(/* f64 */), x, h, &mut err);
    |                                +++++++++++
help: consider further restricting type parameter `F` with trait `Send`
    |
205 |     F: Fn(f64) -> f64 + std::marker::Send,
    |                       +++++++++++++++++++

error[E0277]: `*mut f64` cannot be shared between threads safely
   --> src/FFT_2.rs:105:41
    |
105 |       (1..max_k).into_par_iter().for_each(|k| {
    |                                  -------- ^--
    |                                  |        |
    |  ________________________________|________within this `{closure@src/FFT_2.rs:105:41: 105:44}`
    | |                                |
    | |                                required by a bound introduced by this call
106 | |         let j = 2 * k;
107 | |         if j >= n + 2 {
108 | |             return;
...   |
131 | |     });
    | |_____^ `*mut f64` cannot be shared between threads safely
    |
    = help: within `{closure@src/FFT_2.rs:105:41: 105:44}`, the trait `Sync` is not implemented for `*mut f64`
    = note: required because it appears within the type `&*mut f64`
note: required because it's used within this closure
   --> src/FFT_2.rs:105:41
    |
105 |     (1..max_k).into_par_iter().for_each(|k| {
    |                                         ^^^
note: required by a bound in `rayon::iter::ParallelIterator::for_each`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/iter/mod.rs:375:30
    |
373 |     fn for_each<OP>(self, op: OP)
    |        -------- required by a bound in this associated function
374 |     where
375 |         OP: Fn(Self::Item) + Sync + Send,
    |                              ^^^^ required by this bound in `ParallelIterator::for_each`

error[E0308]: arguments to this method are incorrect
   --> src/FFT_2.rs:262:18
    |
262 |             self.process(data1, data2, fft1, fft2);
    |                  ^^^^^^^               ----  ---- types differ in mutability
    |                                        |
    |                                        types differ in mutability
    |
    = note: expected mutable reference `&mut _`
                       found reference `&&mut _`
    = note: expected mutable reference `&mut _`
                       found reference `&&mut _`
note: method defined here
   --> src/FFT_2.rs:245:12
    |
245 |     pub fn process(&self, data1: &[f64], data2: &[f64], fft1: &mut [f64], fft2: &mut [f64]) {
    |            ^^^^^^^                                      ----------------  ----------------

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:279:32
    |
279 |         let amu0 = (alf + 1.0).gamma();
    |                                ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:298:60
    |
298 |         let amu0 = 2.0f64.powf(alfbet + 1.0) * (alf + 1.0).gamma() * (bet + 1.0).gamma() / 
    |                                                            ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:298:82
    |
298 |         let amu0 = 2.0f64.powf(alfbet + 1.0) * (alf + 1.0).gamma() * (bet + 1.0).gamma() / 
    |                                                                                  ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:299:35
    |
299 |                    (alfbet + 2.0).gamma();
    |                                   ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaujac.rs:96:40
   |
96 |         let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
   |                                        ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaujac.rs:96:72
   |
96 |         let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
   |                                                                        ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaujac.rs:97:40
   |
97 |         let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
   |                                        ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaujac.rs:97:81
   |
97 |         let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
   |                                                                                 ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:191:44
    |
191 |             let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
    |                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:191:76
    |
191 |             let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
    |                                                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:192:44
    |
192 |             let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
    |                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:192:85
    |
192 |             let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
    |                                                                                     ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaulag.rs:80:43
   |
80 |         let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
   |                                           ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaulag.rs:80:69
   |
80 |         let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
   |                                                                     ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaulag.rs:148:47
    |
148 |             let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
    |                                               ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaulag.rs:148:73
    |
148 |             let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
    |                                                                         ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0600]: cannot apply unary operator `-` to type `usize`
   --> src/incomplete_gamma.rs:127:14
    |
127 |         an = -i as f32 * (i as f32 - a);
    |              ^^ cannot apply unary operator `-`
    |
    = note: unsigned values cannot be negated

error[E0277]: cannot add `[{float}; 14]` to `{float}`
  --> src/Jacobian_elliptical.rs:34:27
   |
34 |         let mut c = 0.5*(a+em);
   |                           ^ no implementation for `{float} + [{float}; 14]`
   |
   = help: the trait `Add<[{float}; 14]>` is not implemented for `{float}`
   = help: the following other types implement trait `Add<Rhs>`:
             `&f128` implements `Add<f128>`
             `&f128` implements `Add`
             `&f16` implements `Add<f16>`
             `&f16` implements `Add`
             `&f32` implements `Add<&Complex<f32>>`
             `&f32` implements `Add<&num_complex::Complex<f32>>`
             `&f32` implements `Add<Complex<f32>>`
             `&f32` implements `Add<f32>`
           and 192 others

error[E0282]: type annotations needed for `Arc<_, _>`
   --> src/orthog.rs:127:13
    |
127 |         let sig_clone = Arc::clone(&sig);
    |             ^^^^^^^^^
...
135 |                 let sig_guard = sig_clone.lock().unwrap();
    |                                           ---- type must be known at this point
    |
help: consider giving `sig_clone` an explicit type, where the placeholders `_` are specified
    |
127 |         let sig_clone: Arc<T, A> = Arc::clone(&sig);
    |                      +++++++++++

error[E0689]: can't call method `max` on ambiguous numeric type `{float}`
   --> src/pade.rs:145:23
    |
145 |             big = big.max(a[[i, j]].abs());
    |                       ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
143 |         let mut big: f32 = 0.0;
    |                    +++++

error[E0689]: can't call method `max` on ambiguous numeric type `{float}`
   --> src/pade.rs:402:31
    |
402 |         max_error = max_error.max(error);
    |                               ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
380 |     let mut max_error: f32 = 0.0;
    |                      +++++

error[E0600]: cannot apply unary operator `!` to type `f64`
  --> src/polydiv.rs:19:13
   |
19 |     assert!(!v[0].abs() < f64::EPSILON, "Divisor leading coefficient cannot be zero");
   |             ^^^^^^^^^^^ cannot apply unary operator `!`

error[E0600]: cannot apply unary operator `!` to type `f64`
  --> src/polydiv.rs:54:13
   |
54 |     assert!(!v[0].abs() < f64::EPSILON, "Divisor leading coefficient cannot be zero");
   |             ^^^^^^^^^^^ cannot apply unary operator `!`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<Vec<f64>, PolynomialDivider>>`, but its trait bounds were not satisfied
   --> src/polydiv.rs:179:15
    |
179 |         cache.entry(key.clone())
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<f64>: Hash` or `Vec<f64>: std::cmp::Eq`
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `Vec<f64>: std::cmp::Eq`
            `f64: Hash`
            which is required by `Vec<f64>: Hash`

error[E0599]: no method named `clone` found for type parameter `F` in the current scope
   --> src/qgaus.rs:132:51
    |
109 | fn adaptive_recursive<F>(
    |                       - method `clone` not found for this type parameter
...
132 |         let left_result = adaptive_recursive(func.clone(), a, mid, left, tol, max_depth, depth + 1);
    |                                                   ^^^^^ method not found in `F`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use parentheses to call this type parameter
    |
132 |         let left_result = adaptive_recursive(func(/* f64 */).clone(), a, mid, left, tol, max_depth, depth + 1);
    |                                                  +++++++++++
help: the following trait defines an item `clone`, perhaps you need to restrict type parameter `F` with it:
    |
119 |     F: Fn(f64) -> f64 + Clone,
    |                       +++++++

error[E0277]: the trait bound `&F: Function3D` is not satisfied
   --> src/quad3d.rs:172:13
    |
171 |         return quad3d(
    |                ------ required by a bound introduced by this call
172 |             func.as_ref(),
    |             ^^^^^^^^^^^^^ the trait `Fn(f64, f64, f64)` is not implemented for `F`
    |
    = note: required for `&F` to implement `FnOnce(f64, f64, f64)`
note: required for `&F` to implement `Function3D`
   --> src/quad3d.rs:11:9
    |
 11 | impl<F> Function3D for F
    |         ^^^^^^^^^^     ^
 12 | where
 13 |     F: Fn(f64, f64, f64) -> f64 + Sync + Send,
    |                             --- unsatisfied trait bound introduced here
note: required by a bound in `quad3d`
   --> src/quad3d.rs:80:8
    |
 70 | pub fn quad3d<F, Y1, Y2, Z1, Z2>(
    |        ------ required by a bound in this function
...
 80 |     F: Function3D,
    |        ^^^^^^^^^^ required by this bound in `quad3d`
help: consider further restricting type parameter `F` with trait `Fn`
    |
163 |     F: Function3D + Fn(f64, f64, f64),
    |                   +++++++++++++++++++

error[E0599]: the method `take` exists for struct `rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>`, but its trait bounds were not satisfied
  --> src/random_0.rs:83:10
   |
78 | /     seeds.par_iter()
79 | |         .flat_map(|&s| {
80 | |             let mut rng = Ran0::new(s);
81 | |             rng.generate(chunk_size.min(n))
82 | |         })
83 | |         .take(n)
   | |_________-^^^^
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/iter/flat_map.rs:12:1
   |
12 |   pub struct FlatMap<I, F> {
   |   ------------------------ doesn't satisfy `_: Iterator`
   |
   = note: the following trait bounds were not satisfied:
           `rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>: Iterator`
           which is required by `&mut rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>: Iterator`

error[E0282]: type annotations needed
   --> src/ratlsq.rs:113:43
    |
113 |                         result.extend(row.iter().copied());
    |                                           ^^^^ cannot infer type

error[E0015]: cannot call non-const method `std::f64::<impl f64>::sqrt` in constants
 --> src/spherical_bessel.rs:5:31
  |
5 | const RTPIO2: f64 = FRAC_PI_2.sqrt(); // √(π/2) ≈ 1.253314137
  |                               ^^^^^^
  |
  = note: calls in constants are limited to constant functions, tuple structs and tuple variants

error[E0282]: type annotations needed
  --> src/sprspm.rs:60:9
   |
60 |     ijc.insert(0, n);
   |         ^^^^^^ cannot infer type

warning: unused import: `Read`
 --> src/Four_FS.rs:2:31
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                               ^^^^

warning: unused import: `Write`
 --> src/Four_FS.rs:2:37
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                                     ^^^^^

warning: unused import: `Read`
 --> src/Fourn.rs:2:31
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                               ^^^^

warning: unused import: `Write`
 --> src/Fourn.rs:2:37
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                                     ^^^^^

warning: variable does not need to be mutable
   --> src/airy.rs:150:13
    |
150 |         let mut x = x - 1.0;
    |             ----^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `rj2`
   --> src/airy.rs:322:14
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |              ^^^
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
    |
322 |         let (_rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (constants::CBRT_EPSILON, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `ry2`
   --> src/airy.rs:322:19
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                   ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, _ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                   +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, constants::CBRT_EPSILON, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `rjp2`
   --> src/airy.rs:322:24
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                        ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, ry2, _rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, ry2, constants::CBRT_EPSILON, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `ryp2`
   --> src/airy.rs:322:30
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                              ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, ry2, rjp2, _ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, ry2, rjp2, constants::CBRT_EPSILON) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `u3`
   --> src/bcucof.rs:176:9
    |
176 |     let u3 = u2 * u;
    |         ^^
    |
help: if this is intentional, prefix it with an underscore
    |
176 |     let _u3 = u2 * u;
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
176 -     let u3 = u2 * u;
176 +     let constants::CBRT_EPSILON = u2 * u;
    |

warning: unused variable: `x4`
  --> src/beschd.rs:92:9
   |
92 |     let x4 = x2 * x2;
   |         ^^ help: if this is intentional, prefix it with an underscore: `_x4`

warning: unused variable: `x`
   --> src/bessel_jy.rs:282:11
    |
282 | fn beschd(x: f64) -> (f64, f64, f64, f64) {
    |           ^
    |
help: if this is intentional, prefix it with an underscore
    |
282 | fn beschd(_x: f64) -> (f64, f64, f64, f64) {
    |           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
282 - fn beschd(x: f64) -> (f64, f64, f64, f64) {
282 + fn beschd(constants::CBRT_EPSILON: f64) -> (f64, f64, f64, f64) {
    |

warning: unused variable: `expected`
   --> src/bessel_yn.rs:391:9
    |
391 |     let expected = 2.0 / (PI * x);
    |         ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
391 |     let _expected = 2.0 / (PI * x);
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
391 -     let expected = 2.0 / (PI * x);
391 +     let constants::CBRT_EPSILON = 2.0 / (PI * x);
    |

warning: unused variable: `i`
  --> src/bessik.rs:51:9
   |
51 |     for i in 1..=MAXIT {
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
51 |     for _i in 1..=MAXIT {
   |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
51 -     for i in 1..=MAXIT {
51 +     for constants::MAX_ITERATIONS in 1..=MAXIT {
   |

warning: unused variable: `x`
  --> src/bessik.rs:41:30
   |
41 | fn bessik_continued_fraction(x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |                              ^
   |
help: if this is intentional, prefix it with an underscore
   |
41 | fn bessik_continued_fraction(_x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
41 - fn bessik_continued_fraction(x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
41 + fn bessik_continued_fraction(constants::CBRT_EPSILON: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |

warning: variable does not need to be mutable
  --> src/bessik.rs:59:17
   |
59 |             let mut ril = FPMIN;
   |                 ----^^^
   |                 |
   |                 help: remove this `mut`

warning: variable does not need to be mutable
  --> src/bessik.rs:60:17
   |
60 |             let mut ripl = h * ril;
   |                 ----^^^^
   |                 |
   |                 help: remove this `mut`

warning: unused variable: `l`
   --> src/bessik.rs:176:9
    |
176 |     for l in (1..=nl).rev() {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
176 |     for _l in (1..=nl).rev() {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
    |
176 -     for l in (1..=nl).rev() {
176 +     for bessel_jy::MAXIT in (1..=nl).rev() {
    |

warning: variable does not need to be mutable
   --> src/bessik.rs:223:9
    |
223 |     let mut gam1 = chebyshev_eval(xx, &coef1);
    |         ----^^^^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/bessik.rs:224:9
    |
224 |     let mut gam2 = chebyshev_eval(xx, &coef2);
    |         ----^^^^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
  --> src/beta.rs:29:9
   |
29 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `y`
   --> src/bico.rs:106:13
    |
106 |     let mut y = x;
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
106 |     let mut _y = x;
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
106 -     let mut y = x;
106 +     let mut constants::CBRT_EPSILON = x;
    |

warning: variable does not need to be mutable
   --> src/bico.rs:106:9
    |
106 |     let mut y = x;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: unused variable: `x`
   --> src/Carlson_elliptic_integral_third.rs:155:11
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |           ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Carlson_elliptic_integral_third.rs:155:19
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                   ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |                   +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Carlson_elliptic_integral_third.rs:155:27
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                           ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `func`
   --> src/chebyshev_calc.rs:244:56
    |
244 | pub fn verify_derivative<F>(a: f64, b: f64, c: &[f64], func: F, deriv_func: F, n_test: usize, tol: f64) -> bool
    |                                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_func`

warning: unused variable: `data`
  --> src/Cos_FT.rs:71:11
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |           ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `n`
  --> src/Cos_FT.rs:71:29
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |                             ^
   |
help: if this is intentional, prefix it with an underscore
   |
71 | fn realft(data: &mut [f64], _n: usize, isign: i32) {
   |                             +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
71 - fn realft(data: &mut [f64], n: usize, isign: i32) {
71 + fn realft(data: &mut [f64], constants::MAX_ITERATIONS: usize, isign: i32) {
   |

warning: unused variable: `isign`
  --> src/Cos_FT.rs:71:39
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |                                       ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
71 | fn realft(data: &mut [f64], n: usize, _isign: i32) {
   |                                       +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
71 - fn realft(data: &mut [f64], n: usize, isign: i32) {
71 + fn realft(data: &mut [f64], n: usize, bessel_jy::MAXIT: i32) {
   |

warning: unused variable: `data`
   --> src/Cos_FT2.rs:194:11
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |           ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `n`
   --> src/Cos_FT2.rs:194:29
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |                             ^
    |
help: if this is intentional, prefix it with an underscore
    |
194 | fn realft(data: &mut [f64], _n: usize, isign: i32) {
    |                             +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
194 - fn realft(data: &mut [f64], n: usize, isign: i32) {
194 + fn realft(data: &mut [f64], constants::MAX_ITERATIONS: usize, isign: i32) {
    |

warning: unused variable: `isign`
   --> src/Cos_FT2.rs:194:39
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |                                       ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
194 | fn realft(data: &mut [f64], n: usize, _isign: i32) {
    |                                       +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
    |
194 - fn realft(data: &mut [f64], n: usize, isign: i32) {
194 + fn realft(data: &mut [f64], n: usize, bessel_jy::MAXIT: i32) {
    |

warning: unused variable: `theta_vec`
   --> src/Cos_FT2.rs:209:13
    |
209 |         let theta_vec = _mm256_set1_pd(theta);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_theta_vec`

warning[E0133]: call to function `std::arch::x86_64::_mm256_set1_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:200:25
    |
200 |             let x_vec = _mm256_set1_pd(x);
    |                         ^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx
note: an unsafe function restricts its caller, but its body is safe by default
   --> src/ddpoly.rs:184:1
    |
184 | pub unsafe fn ddpoly_simd(c: &[f64], x: f64, nd: usize) -> Vec<f64> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(unsafe_op_in_unsafe_fn)]` (part of `#[warn(rust_2024_compatibility)]`) on by default

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:204:28
    |
204 |                 let pd_j = _mm256_loadu_pd(pd.as_ptr().add(j - 3));
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::const_ptr::<impl *const T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:204:44
    |
204 |                 let pd_j = _mm256_loadu_pd(pd.as_ptr().add(j - 3));
    |                                            ^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:205:36
    |
205 |                 let pd_j_minus_1 = _mm256_loadu_pd(pd.as_ptr().add(j - 4));
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::const_ptr::<impl *const T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:205:52
    |
205 |                 let pd_j_minus_1 = _mm256_loadu_pd(pd.as_ptr().add(j - 4));
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to function `std::arch::x86_64::_mm256_mul_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:207:31
    |
207 |                 let product = _mm256_mul_pd(pd_j, x_vec);
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx

warning[E0133]: call to function `std::arch::x86_64::_mm256_add_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:208:30
    |
208 |                 let result = _mm256_add_pd(product, pd_j_minus_1);
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_storeu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:210:17
    |
210 |                 _mm256_storeu_pd(pd.as_mut_ptr().add(j - 3), result);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::mut_ptr::<impl *mut T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:210:34
    |
210 |                 _mm256_storeu_pd(pd.as_mut_ptr().add(j - 3), result);
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning: variable `factorial` is assigned to, but never used
   --> src/ei.rs:137:13
    |
137 |     let mut factorial = 1.0;
    |             ^^^^^^^^^
    |
    = note: consider using `_factorial` instead
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
137 -     let mut factorial = 1.0;
137 +     let mut constants::CBRT_EPSILON = 1.0;
    |

warning: unused variable: `k_prime`
   --> src/Elliptical_Legendre_First.rs:172:9
    |
172 |     let k_prime = (1.0 - k * k).sqrt();
    |         ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
172 |     let _k_prime = (1.0 - k * k).sqrt();
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
172 -     let k_prime = (1.0 - k * k).sqrt();
172 +     let constants::CBRT_EPSILON = (1.0 - k * k).sqrt();
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_First.rs:222:7
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_First.rs:222:15
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_First.rs:222:23
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_Second.rs:232:7
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_Second.rs:232:15
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_Second.rs:232:23
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_Second.rs:238:7
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_Second.rs:238:15
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_Second.rs:238:23
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: variable does not need to be mutable
   --> src/error_functions.rs:110:9
    |
110 |     let mut x = x - 1.0;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/eulsum.rs:158:21
    |
158 |                 let mut euler = instance.lock().unwrap();
    |                     ----^^^^^
    |                     |
    |                     help: remove this `mut`

warning: variable does not need to be mutable
   --> src/exponential_integral.rs:175:9
    |
175 |     let mut result = (-x).exp() / x;
    |         ----^^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `y`
   --> src/factrl.rs:212:13
    |
212 |     let mut y = x;
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
212 |     let mut _y = x;
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
212 -     let mut y = x;
212 +     let mut constants::CBRT_EPSILON = x;
    |

warning: variable does not need to be mutable
   --> src/factrl.rs:212:9
    |
212 |     let mut y = x;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: unused variable: `isign`
  --> src/FFT_1.rs:47:100
   |
47 | fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                                                    ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
47 | fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, _isign: i32) {
   |                                                                                                    +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
47 - fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
47 + fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, bessel_jy::MAXIT: i32) {
   |

warning: unused variable: `wpr`
  --> src/FFT_1.rs:75:78
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                              ^^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, _wpr: f64, wpi: f64, isign: i32) {
   |                                                                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 - fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
75 + fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, constants::CBRT_EPSILON: f64, wpi: f64, isign: i32) {
   |

warning: unused variable: `wpi`
  --> src/FFT_1.rs:75:88
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                                        ^^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, _wpi: f64, isign: i32) {
   |                                                                                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 - fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
75 + fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, constants::CBRT_EPSILON: f64, isign: i32) {
   |

error[E0596]: cannot borrow `*fft1` as mutable, as it is a captured variable in a `Fn` closure
  --> src/FFT_2.rs:44:28
   |
44 |             let fft1_ptr = fft1.as_mut_ptr();
   |                            ^^^^ cannot borrow as mutable

warning: unused variable: `state`
  --> src/Four_FS.rs:78:9
   |
78 |         state: &mut FFTState,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `file_state`
  --> src/Four_FS.rs:79:9
   |
79 |         file_state: &mut FileState,
   |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_file_state`

warning: unused variable: `isign`
  --> src/Four_FS.rs:80:9
   |
80 |         isign: i32,
   |         ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
80 |         _isign: i32,
   |         +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
80 -         isign: i32,
80 +         bessel_jy::MAXIT: i32,
   |

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/Fourn.rs:302:32
    |
302 |                 let data_vec = _mm256_loadu_pd(chunk.as_ptr());
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior
note: an unsafe function restricts its caller, but its body is safe by default
   --> src/Fourn.rs:278:1
    |
278 | pub unsafe fn fourn_simd(data: &mut [f64], nn: &[usize], ndim: usize, isign: i32) -> Result<(), Error> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_storeu_pd` is unsafe and requires unsafe block
   --> src/Fourn.rs:309:17
    |
309 |                 _mm256_storeu_pd(chunk.as_mut_ptr(), result_vec);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning: unused variable: `k`
   --> src/frenel.rs:121:9
    |
121 |     for k in 2..=MAXIT {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
121 |     for _k in 2..=MAXIT {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
121 -     for k in 2..=MAXIT {
121 +     for constants::MAX_ITERATIONS in 2..=MAXIT {
    |

warning: variable does not need to be mutable
  --> src/gamma_continued_funciton.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `gln`
   --> src/gamma_continued_funciton.rs:191:17
    |
191 |         let (p, gln) = super::gamma_series::gamma_series(a, x)?;
    |                 ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
191 |         let (p, _gln) = super::gamma_series::gamma_series(a, x)?;
    |                 +
help: you might have meant to pattern match on the similarly named constant `LARGE`
    |
191 -         let (p, gln) = super::gamma_series::gamma_series(a, x)?;
191 +         let (p, spline::LARGE) = super::gamma_series::gamma_series(a, x)?;
    |

warning: unused variable: `gln`
   --> src/gamma_continued_funciton.rs:195:17
    |
195 |         let (q, gln) = gamma_continued_fraction(a, x)?;
    |                 ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
195 |         let (q, _gln) = gamma_continued_fraction(a, x)?;
    |                 +
help: you might have meant to pattern match on the similarly named constant `LARGE`
    |
195 -         let (q, gln) = gamma_continued_fraction(a, x)?;
195 +         let (q, spline::LARGE) = gamma_continued_fraction(a, x)?;
    |

warning: variable does not need to be mutable
  --> src/gamma_series.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `n`
  --> src/gamma_series.rs:67:9
   |
67 |     for n in 1..=MAX_ITER {
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
67 |     for _n in 1..=MAX_ITER {
   |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
67 -     for n in 1..=MAX_ITER {
67 +     for constants::MAX_ITERATIONS in 1..=MAX_ITER {
   |

warning: unused variable: `n`
   --> src/gamma_series.rs:175:9
    |
175 |     for n in 1..=MAX_ITER {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
175 |     for _n in 1..=MAX_ITER {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
175 -     for n in 1..=MAX_ITER {
175 +     for constants::MAX_ITERATIONS in 1..=MAX_ITER {
    |

warning: unused variable: `y`
  --> src/gammln.rs:44:13
   |
44 |     let mut y = x;
   |             ^
   |
help: if this is intentional, prefix it with an underscore
   |
44 |     let mut _y = x;
   |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
44 -     let mut y = x;
44 +     let mut constants::CBRT_EPSILON = x;
   |

warning: variable does not need to be mutable
  --> src/gammln.rs:44:9
   |
44 |     let mut y = x;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `b`
   --> src/gaucof.rs:162:21
    |
162 |                 let b = c * e[i];
    |                     ^
    |
help: if this is intentional, prefix it with an underscore
    |
162 |                 let _b = c * e[i];
    |                     +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
162 -                 let b = c * e[i];
162 +                 let constants::CBRT_EPSILON = c * e[i];
    |

warning: variable does not need to be mutable
   --> src/gaucof.rs:129:13
    |
129 |         let mut m = l;
    |             ----^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:146:17
    |
146 |             let mut g = d[l];
    |                 ----^
    |                 |
    |                 help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:147:17
    |
147 |             let mut p = (d[m] - g) / (2.0 * e[l]);
    |                 ----^
    |                 |
    |                 help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:241:13
    |
241 |         let mut a = vec![0.0; n];
    |             ----^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:255:13
    |
255 |         let mut a = vec![0.0; n];
    |             ----^
    |             |
    |             help: remove this `mut`

warning: value assigned to `pp` is never read
  --> src/gauher.rs:56:17
   |
56 |         let mut pp = 0.0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p1`
  --> src/gauher.rs:75:14
   |
75 |         let (p1, pp) = hermite_polynomial(n, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 |         let (_p1, pp) = hermite_polynomial(n, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 -         let (p1, pp) = hermite_polynomial(n, z);
75 +         let (constants::CBRT_EPSILON, pp) = hermite_polynomial(n, z);
   |

warning: value assigned to `pp` is never read
   --> src/gauher.rs:129:17
    |
129 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p1`
   --> src/gauher.rs:145:18
    |
145 |             let (p1, pp) = hermite_polynomial(n, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
145 |             let (_p1, pp) = hermite_polynomial(n, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
145 -             let (p1, pp) = hermite_polynomial(n, z);
145 +             let (constants::CBRT_EPSILON, pp) = hermite_polynomial(n, z);
    |

warning: unused variable: `x`
   --> src/gauher.rs:268:24
    |
268 |     pub fn constant_fn(x: f64) -> f64 {
    |                        ^
    |
help: if this is intentional, prefix it with an underscore
    |
268 |     pub fn constant_fn(_x: f64) -> f64 {
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
268 -     pub fn constant_fn(x: f64) -> f64 {
268 +     pub fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: value assigned to `pp` is never read
  --> src/gaujac.rs:73:17
   |
73 |         let mut pp = 0.0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
  --> src/gaujac.rs:76:22
   |
76 |             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
   |                      ^^
   |
help: if this is intentional, prefix it with an underscore
   |
76 |             let (p1, _p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
   |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
76 -             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
76 +             let (p1, constants::CBRT_EPSILON, new_pp) = jacobi_polynomial(n, alf, bet, z);
   |

warning: unused variable: `p1`
  --> src/gaujac.rs:92:14
   |
92 |         let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
92 |         let (_p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
92 -         let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
92 +         let (constants::CBRT_EPSILON, p2, pp) = jacobi_polynomial(n, alf, bet, z);
   |

warning: value assigned to `pp` is never read
   --> src/gaujac.rs:174:17
    |
174 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
   --> src/gaujac.rs:177:22
    |
177 |             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |                      ^^
    |
help: if this is intentional, prefix it with an underscore
    |
177 |             let (p1, _p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
177 -             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
177 +             let (p1, constants::CBRT_EPSILON, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |

warning: unused variable: `p1`
   --> src/gaujac.rs:190:18
    |
190 |             let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
190 |             let (_p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
190 -             let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
190 +             let (constants::CBRT_EPSILON, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |

warning: value assigned to `pp` is never read
  --> src/gaulag.rs:57:17
   |
57 |         let mut pp = 0.0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
  --> src/gaulag.rs:60:22
   |
60 |             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
   |                      ^^
   |
help: if this is intentional, prefix it with an underscore
   |
60 |             let (p1, _p2, new_pp) = laguerre_polynomial(n, alf, z);
   |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
60 -             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
60 +             let (p1, constants::CBRT_EPSILON, new_pp) = laguerre_polynomial(n, alf, z);
   |

warning: unused variable: `p1`
  --> src/gaulag.rs:76:14
   |
76 |         let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
76 |         let (_p1, p2, pp) = laguerre_polynomial(n, alf, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
76 -         let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
76 +         let (constants::CBRT_EPSILON, p2, pp) = laguerre_polynomial(n, alf, z);
   |

warning: value assigned to `pp` is never read
   --> src/gaulag.rs:131:17
    |
131 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
   --> src/gaulag.rs:134:22
    |
134 |             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
    |                      ^^
    |
help: if this is intentional, prefix it with an underscore
    |
134 |             let (p1, _p2, new_pp) = laguerre_polynomial(n, alf, z);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
134 -             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
134 +             let (p1, constants::CBRT_EPSILON, new_pp) = laguerre_polynomial(n, alf, z);
    |

warning: unused variable: `p1`
   --> src/gaulag.rs:147:18
    |
147 |             let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
147 |             let (_p1, p2, pp) = laguerre_polynomial(n, alf, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
147 -             let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
147 +             let (constants::CBRT_EPSILON, p2, pp) = laguerre_polynomial(n, alf, z);
    |

warning: unused variable: `key`
   --> src/gaulag.rs:178:13
    |
178 |         let key = (n, alf.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `key`
   --> src/gaulag.rs:191:13
    |
191 |         let key = (n, alf.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `x`
   --> src/gaulag.rs:273:24
    |
273 |     pub fn constant_fn(x: f64) -> f64 {
    |                        ^
    |
help: if this is intentional, prefix it with an underscore
    |
273 |     pub fn constant_fn(_x: f64) -> f64 {
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
273 -     pub fn constant_fn(x: f64) -> f64 {
273 +     pub fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `p1`
  --> src/gauleg.rs:67:14
   |
67 |         let (p1, pp) = legendre_polynomial(n, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
67 |         let (_p1, pp) = legendre_polynomial(n, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
67 -         let (p1, pp) = legendre_polynomial(n, z);
67 +         let (constants::CBRT_EPSILON, pp) = legendre_polynomial(n, z);
   |

warning: unused variable: `p1`
   --> src/gauleg.rs:126:18
    |
126 |             let (p1, pp) = legendre_polynomial(n, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
126 |             let (_p1, pp) = legendre_polynomial(n, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
126 -             let (p1, pp) = legendre_polynomial(n, z);
126 +             let (constants::CBRT_EPSILON, pp) = legendre_polynomial(n, z);
    |

warning: unused variable: `key`
   --> src/gauleg.rs:158:13
    |
158 |         let key = (n, x1.to_bits(), x2.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `key`
   --> src/gauleg.rs:173:13
    |
173 |         let key = (n, x1.to_bits(), x2.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: variable does not need to be mutable
  --> src/inc_beta_func.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: variable does not need to be mutable
  --> src/incomplete_gamma.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/Jacobian_elliptical.rs:175:17
    |
175 |             let mut u_scaled = u * self.c;
    |                 ----^^^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: value assigned to `err` is never read
  --> src/linbcg.rs:57:13
   |
57 |     let mut err = 0.0;
   |             ^^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `zm1nrm` is never read
  --> src/linbcg.rs:85:13
   |
85 |     let mut zm1nrm = 0.0;
   |             ^^^^^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `current_result` is never read
   --> src/midsqu.rs:114:13
    |
114 |     let mut current_result = 0.0;
    |             ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:205:22
    |
205 |         let qk_vec = unsafe { _mm256_set1_pd(q[k]) };
    |                      ^^^^^^ unnecessary `unsafe` block
    |
    = note: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:212:27
    |
212 |             let product = unsafe { _mm256_mul_pd(qk_vec, v_vec) };
    |                           ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:213:26
    |
213 |             let result = unsafe { _mm256_sub_pd(r_vec, product) };
    |                          ^^^^^^ unnecessary `unsafe` block

warning: variable `sum` is assigned to, but never used
   --> src/qromo.rs:192:17
    |
192 |         let mut sum = 0.0;
    |                 ^^^
    |
    = note: consider using `_sum` instead
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
192 -         let mut sum = 0.0;
192 +         let mut constants::CBRT_EPSILON = 0.0;
    |

warning: value assigned to `iy` is never read
  --> src/random_1.rs:32:17
   |
32 |         let mut iy = 0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `iy` is never read
  --> src/random_2.rs:39:17
   |
39 |         let mut iy = 0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: variable does not need to be mutable
  --> src/random_2.rs:37:13
   |
37 |         let mut idum2 = idum1;
   |             ----^^^^^
   |             |
   |             help: remove this `mut`

warning: unused variable: `k`
  --> src/random_3.rs:39:17
   |
39 |             for k in 1..=4 {
   |                 ^
   |
help: if this is intentional, prefix it with an underscore
   |
39 |             for _k in 1..=4 {
   |                 +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
39 -             for k in 1..=4 {
39 +             for bessel_jy::MAXIT in 1..=4 {
   |

Some errors have detailed explanations: E0015, E0061, E0133, E0277, E0282, E0308, E0368, E0369, E0425...
For more information about an error, try `rustc --explain E0015`.
warning: `num_rs` (lib) generated 189 warnings
error: could not compile `num_rs` (lib) due to 125 previous errors; 189 warnings emitted
   Compiling num_rs v0.1.0 (/home/archdabe/Documents/Numerical-recipies/Rust/numrs)
error[E0432]: unresolved import `ndarray::Array`
 --> src/beschd.rs:1:15
  |
1 | use ndarray::{Array, ArrayView};
  |               ^^^^^ no `Array` in the root

error[E0432]: unresolved import `std::f64::consts::EULER`
 --> src/Cosine_Sine_Integrals.rs:3:28
  |
3 | use std::f64::consts::{PI, EULER};
  |                            ^^^^^ no `EULER` in `f64::consts`

error[E0432]: unresolved import `std::f64::consts::EULER`
 --> src/ei.rs:1:5
  |
1 | use std::f64::consts::EULER;
  |     ^^^^^^^^^^^^^^^^^^^^^^^ no `EULER` in `f64::consts`

error[E0432]: unresolved import `std::f64::consts::EPSILON`
 --> src/elementary_integration_methods.rs:1:5
  |
1 | use std::f64::consts::EPSILON;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `EPSILON` in `f64::consts`

error[E0432]: unresolved import `std::f64::consts::EULER`
 --> src/exponential_integral.rs:1:5
  |
1 | use std::f64::consts::EULER;
  |     ^^^^^^^^^^^^^^^^^^^^^^^ no `EULER` in `f64::consts`

error[E0432]: unresolved import `std::f64::consts::EPSILON`
 --> src/linbcg.rs:1:5
  |
1 | use std::f64::consts::EPSILON;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `EPSILON` in `f64::consts`

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`
 --> src/orthog.rs:1:15
  |
1 | use ndarray::{Array2, Array1};
  |               ^^^^^^  ^^^^^^ no `Array1` in the root
  |               |
  |               no `Array2` in the root

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`, `ndarray::ArrayView2`, `ndarray::ArrayView1`
 --> src/pade.rs:2:15
  |
2 | use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^ no `ArrayView1` in the root
  |               |       |       |
  |               |       |       no `ArrayView2` in the root
  |               |       no `Array1` in the root
  |               no `Array2` in the root
  |
help: a similar name exists in the module
  |
2 - use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
2 + use ndarray::{Array2, Array1, ArrayView, ArrayView1};
  |
help: a similar name exists in the module
  |
2 - use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
2 + use ndarray::{Array2, Array1, ArrayView2, ArrayView};
  |

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::ArrayView1`
 --> src/polcof.rs:3:15
  |
3 | use ndarray::{Array1, ArrayView1};
  |               ^^^^^^  ^^^^^^^^^^
  |               |       |
  |               |       no `ArrayView1` in the root
  |               |       help: a similar name exists in the module: `ArrayView`
  |               no `Array1` in the root

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::ArrayView1`, `ndarray::ArrayViewMut1`
 --> src/polydiv.rs:4:15
  |
4 | use ndarray::{Array1, ArrayView1, ArrayViewMut1};
  |               ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^^^ no `ArrayViewMut1` in the root
  |               |       |
  |               |       no `ArrayView1` in the root
  |               no `Array1` in the root
  |
help: a similar name exists in the module
  |
4 - use ndarray::{Array1, ArrayView1, ArrayViewMut1};
4 + use ndarray::{Array1, ArrayView, ArrayViewMut1};
  |
help: a similar name exists in the module
  |
4 - use ndarray::{Array1, ArrayView1, ArrayViewMut1};
4 + use ndarray::{Array1, ArrayView1, ArrayViewMut};
  |

error[E0432]: unresolved import `std::f64::consts::EPSILON`
 --> src/qrdcmp.rs:3:5
  |
3 | use std::f64::consts::EPSILON as F64_EPSILON;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `EPSILON` in `f64::consts`

error: no rules expected `"Failed for degree {}"`
   --> src/gaucof.rs:456:67
    |
456 |             assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`, `ndarray::ArrayView2`, `ndarray::ArrayView1`
 --> src/ratlsq.rs:2:15
  |
2 | use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^ no `ArrayView1` in the root
  |               |       |       |
  |               |       |       no `ArrayView2` in the root
  |               |       no `Array1` in the root
  |               no `Array2` in the root
  |
help: a similar name exists in the module
  |
2 - use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
2 + use ndarray::{Array2, Array1, ArrayView, ArrayView1};
  |
help: a similar name exists in the module
  |
2 - use ndarray::{Array2, Array1, ArrayView2, ArrayView1};
2 + use ndarray::{Array2, Array1, ArrayView2, ArrayView};
  |

error: no rules expected `"Failed for degree {}"`
   --> src/gauher.rs:406:71
    |
406 |                 assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                       ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error: no rules expected `"Failed for degree {}"`
   --> src/gauher.rs:408:69
    |
408 |                 assert_abs_diff_eq!(computed, 0.0, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                     ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error: no rules expected `"Failed for degree {}"`
   --> src/gaujac.rs:437:67
    |
437 |             assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error: no rules expected `"Failed for degree {}"`
   --> src/gaulag.rs:425:67
    |
425 |             assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::ArrayView1`
 --> src/ratval.rs:4:15
  |
4 | use ndarray::{Array1, ArrayView1};
  |               ^^^^^^  ^^^^^^^^^^
  |               |       |
  |               |       no `ArrayView1` in the root
  |               |       help: a similar name exists in the module: `ArrayView`
  |               no `Array1` in the root

error: no rules expected `"Failed for degree {}"`
   --> src/gauleg.rs:416:67
    |
416 |             assert_abs_diff_eq!(computed, exact, epsilon = 1e-10, "Failed for degree {}", degree);
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ no rules expected this token in macro call
    |
note: while trying to match meta-variable `$opt:ident`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/macros.rs:124:38
    |
124 |     ($given:expr, $expected:expr $(, $opt:ident = $val:expr)*) => {
    |                                      ^^^^^^^^^^

error[E0432]: unresolved imports `ndarray::Array3`, `ndarray::Array2`, `ndarray::ArrayViewMut3`, `ndarray::ArrayViewMut2`
 --> src/Real_FT3.rs:3:15
  |
3 | use ndarray::{Array3, Array2, ArrayViewMut3, ArrayViewMut2};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^ no `ArrayViewMut2` in the root
  |               |       |       |
  |               |       |       no `ArrayViewMut3` in the root
  |               |       no `Array2` in the root
  |               no `Array3` in the root
  |
help: a similar name exists in the module
  |
3 - use ndarray::{Array3, Array2, ArrayViewMut3, ArrayViewMut2};
3 + use ndarray::{Array3, Array2, ArrayViewMut, ArrayViewMut2};
  |
help: a similar name exists in the module
  |
3 - use ndarray::{Array3, Array2, ArrayViewMut3, ArrayViewMut2};
3 + use ndarray::{Array3, Array2, ArrayViewMut3, ArrayViewMut};
  |

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::Array2`
 --> src/Recursive_Stratified_Sampling.rs:4:15
  |
4 | use ndarray::{Array1, Array2};
  |               ^^^^^^  ^^^^^^ no `Array2` in the root
  |               |
  |               no `Array1` in the root

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`, `ndarray::ArrayView1`, `ndarray::ArrayViewMut1`
 --> src/splie2.rs:1:15
  |
1 | use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^^^ no `ArrayViewMut1` in the root
  |               |       |       |
  |               |       |       no `ArrayView1` in the root
  |               |       no `Array1` in the root
  |               no `Array2` in the root
  |
help: a similar name exists in the module
  |
1 - use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
1 + use ndarray::{Array2, Array1, ArrayView, ArrayViewMut1};
  |
help: a similar name exists in the module
  |
1 - use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
1 + use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut};
  |

error[E0432]: unresolved imports `ndarray::Array2`, `ndarray::Array1`, `ndarray::ArrayView1`, `ndarray::ArrayViewMut1`
 --> src/splin2.rs:1:15
  |
1 | use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
  |               ^^^^^^  ^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^^^ no `ArrayViewMut1` in the root
  |               |       |       |
  |               |       |       no `ArrayView1` in the root
  |               |       no `Array1` in the root
  |               no `Array2` in the root
  |
help: a similar name exists in the module
  |
1 - use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
1 + use ndarray::{Array2, Array1, ArrayView, ArrayViewMut1};
  |
help: a similar name exists in the module
  |
1 - use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut1};
1 + use ndarray::{Array2, Array1, ArrayView1, ArrayViewMut};
  |

error[E0432]: unresolved imports `ndarray::Array1`, `ndarray::Array2`
 --> src/utils.rs:1:15
  |
1 | use ndarray::{Array1, Array2};
  |               ^^^^^^  ^^^^^^ no `Array2` in the root
  |               |
  |               no `Array1` in the root

error[E0432]: unresolved imports `bessel_j::bessel_j0`, `bessel_j::bessel_j1`, `bessel_j::bessel_jn`
   --> src/lib.rs:116:20
    |
116 | pub use bessel_j::{bessel_j0, bessel_j1, bessel_jn};
    |                    ^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^ no `bessel_jn` in `bessel_j`
    |                    |          |
    |                    |          no `bessel_j1` in `bessel_j`
    |                    no `bessel_j0` in `bessel_j`
    |
note: these modules exist but are inaccessible
   --> src/bessel_yn.rs:128:1
    |
128 | mod bessel_j0 {
    | ^^^^^^^^^^^^^ `crate::bessel_yn::bessel_j0`: not accessible
    |
   ::: src/bessy0.rs:6:1
    |
  6 | mod bessel_j0 {
    | ^^^^^^^^^^^^^ `crate::bessy0::bessel_j0`: not accessible
note: these modules exist but are inaccessible
   --> src/bessel_y1.rs:8:1
    |
  8 | mod bessel_j1 {
    | ^^^^^^^^^^^^^ `crate::bessel_y1::bessel_j1`: not accessible
    |
   ::: src/bessel_yn.rs:182:1
    |
182 | mod bessel_j1 {
    | ^^^^^^^^^^^^^ `crate::bessel_yn::bessel_j1`: not accessible
help: a similar name exists in the module
    |
116 - pub use bessel_j::{bessel_j0, bessel_j1, bessel_jn};
116 + pub use bessel_j::{bessj0, bessel_j1, bessel_jn};
    |
help: a similar name exists in the module
    |
116 - pub use bessel_j::{bessel_j0, bessel_j1, bessel_jn};
116 + pub use bessel_j::{bessel_j0, bessj1, bessel_jn};
    |

error[E0432]: unresolved import `beta::ln_beta`
   --> src/lib.rs:118:22
    |
118 | pub use beta::{beta, ln_beta};
    |                      ^^^^^^^ no `ln_beta` in `beta`

error[E0432]: unresolved import `crate::ndarray`
 --> src/Convolve.rs:4:12
  |
4 | use crate::ndarray::{Array1, ArrayView, ArrayViewMut, s};/// Convolution/Deconvolution implementation with FFT optimization
  |            ^^^^^^^ could not find `ndarray` in the crate root

error[E0432]: unresolved import `crate::ndarray`
 --> src/Correlation.rs:3:12
  |
3 | use crate::ndarray::{Array1, ArrayView1, ArrayViewMut1, s};
  |            ^^^^^^^ could not find `ndarray` in the crate root

error[E0432]: unresolved import `special`
 --> src/gaujac.rs:5:5
  |
5 | use special::Gamma;
  |     ^^^^^^^ use of unresolved module or unlinked crate `special`
  |
  = help: if you wanted to use a crate named `special`, use `cargo add special` to add it to your `Cargo.toml`

error[E0432]: unresolved import `special`
 --> src/gaulag.rs:5:5
  |
5 | use special::Gamma;
  |     ^^^^^^^ use of unresolved module or unlinked crate `special`
  |
  = help: if you wanted to use a crate named `special`, use `cargo add special` to add it to your `Cargo.toml`

error[E0432]: unresolved import `sprs`
 --> src/sprspm.rs:1:5
  |
1 | use sprs::{CsMat, CsVec};
  |     ^^^^ use of unresolved module or unlinked crate `sprs`
  |
  = help: if you wanted to use a crate named `sprs`, use `cargo add sprs` to add it to your `Cargo.toml`

error[E0432]: unresolved imports `airy::ai`, `airy::bi`, `airy::ai_deriv`, `airy::bi_deriv`
   --> src/lib.rs:115:16
    |
115 | pub use airy::{ai, bi, ai_deriv, bi_deriv};
    |                ^^  ^^  ^^^^^^^^  ^^^^^^^^ no `bi_deriv` in `airy`
    |                |   |   |
    |                |   |   no `ai_deriv` in `airy`
    |                |   no `bi` in `airy`
    |                no `ai` in `airy`

error[E0432]: unresolved import `bessel_y1::bessel_y1`
   --> src/lib.rs:117:9
    |
117 | pub use bessel_y1::bessel_y1;
    |         ^^^^^^^^^^^---------
    |         |          |
    |         |          help: a similar name exists in the module: `bessel_j1`
    |         no `bessel_y1` in `bessel_y1`
    |
note: module `crate::bessel_yn::bessel_y1` exists but is inaccessible
   --> src/bessel_yn.rs:66:1
    |
 66 | mod bessel_y1 {
    | ^^^^^^^^^^^^^ not accessible

error: could not compile `num_rs` (lib test) due to 6 previous errors
warning: build failed, waiting for other jobs to finish...
error[E0412]: cannot find type `ArrayView1` in this scope
   --> src/beschd.rs:10:34
    |
 10 | pub fn chebev<T>(a: T, b: T, c: &ArrayView1<T>, m: usize, x: T) -> T
    |                                  ^^^^^^^^^^ help: a type alias with a similar name exists: `ArrayView`
    |
   ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ndarray-0.5.2/src/lib.rs:429:1
    |
429 | pub type ArrayView<'a, A, D> = ArrayBase<ViewRepr<&'a A>, D>;
    | ---------------------------- similarly named type alias `ArrayView` defined here

error[E0412]: cannot find type `ArrayView1` in this scope
   --> src/beschd.rs:162:43
    |
162 | pub fn beschd_multithreaded<T>(x_values: &ArrayView1<T>, num_threads: usize) -> Array1<(T, T, T, T)>
    |                                           ^^^^^^^^^^ help: a type alias with a similar name exists: `ArrayView`
    |
   ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ndarray-0.5.2/src/lib.rs:429:1
    |
429 | pub type ArrayView<'a, A, D> = ArrayBase<ViewRepr<&'a A>, D>;
    | ---------------------------- similarly named type alias `ArrayView` defined here

error[E0412]: cannot find type `Array1` in this scope
   --> src/beschd.rs:162:81
    |
162 | pub fn beschd_multithreaded<T>(x_values: &ArrayView1<T>, num_threads: usize) -> Array1<(T, T, T, T)>
    |                                                                                 ^^^^^^ not found in this scope

error[E0412]: cannot find type `Array1` in this scope
   --> src/beschd.rs:167:21
    |
167 |     let chunks: Vec<Array1<T>> = x_values
    |                     ^^^^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
  --> src/pccheb.rs:85:30
   |
85 |                 *c.add(j) += fac;
   |                              ^^^
   |
help: the binding `fac` is available in a different scope in the same function
  --> src/pccheb.rs:74:21
   |
74 |             let mut fac = *d.add(k) / pow;
   |                     ^^^

error[E0425]: cannot find value `fac` in this scope
  --> src/pccheb.rs:87:13
   |
87 |             fac *= jm / jp;
   |             ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
  --> src/pccheb.rs:93:30
   |
93 |                 *c.add(j) += fac;
   |                              ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
  --> src/pccheb.rs:95:13
   |
95 |             fac *= jm / jp;
   |             ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:101:30
    |
101 |                 *c.add(j) += fac;
    |                              ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:103:13
    |
103 |             fac *= jm / jp;
    |             ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:109:30
    |
109 |                 *c.add(j) += fac;
    |                              ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:111:13
    |
111 |             fac *= jm / jp;
    |             ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:120:30
    |
120 |                 *c.add(j) += fac;
    |                              ^^^ not found in this scope

error[E0425]: cannot find value `fac` in this scope
   --> src/pccheb.rs:123:17
    |
123 |                 fac *= jm / jp;
    |                 ^^^ not found in this scope

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `constants`
   --> src/spherical_bessel.rs:315:9
    |
315 |     let constants::CBRT_EPSILON = 1.0 / (x * x);
    |         ^^^^^^^^^ use of unresolved module or unlinked crate `constants`
    |
    = help: if you wanted to use a crate named `constants`, use `cargo add constants` to add it to your `Cargo.toml`
help: consider importing this module
    |
  1 + use crate::constants;
    |

warning: unexpected `cfg` condition value: `bench`
   --> src/airy.rs:717:7
    |
717 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `std::mem`
 --> src/bandec.rs:1:5
  |
1 | use std::mem;
  |     ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `approx::assert_abs_diff_eq`
 --> src/bcuint.rs:2:5
  |
2 | use approx::assert_abs_diff_eq;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ArrayView`
 --> src/beschd.rs:1:22
  |
1 | use ndarray::{Array, ArrayView};
  |                      ^^^^^^^^^

warning: unused import: `std::f64::consts`
 --> src/bessel_I1.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_j1.rs:423:7
    |
423 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `PI`
 --> src/bessel_j1.rs:1:24
  |
1 | use std::f64::consts::{PI, FRAC_PI_4};
  |                        ^^

warning: unnecessary parentheses around assigned value
   --> src/bessel_jy.rs:172:14
    |
172 |         p /= (i_f64 - xmu);
    |              ^           ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
172 -         p /= (i_f64 - xmu);
172 +         p /= i_f64 - xmu ;
    |

warning: unnecessary parentheses around assigned value
   --> src/bessel_jy.rs:173:14
    |
173 |         q /= (i_f64 + xmu);
    |              ^           ^
    |
help: remove these parentheses
    |
173 -         q /= (i_f64 + xmu);
173 +         q /= i_f64 + xmu ;
    |

warning: unexpected `cfg` condition value: `parallel`
   --> src/bessel_k0.rs:323:7
    |
323 | #[cfg(feature = "parallel")]
    |       ^^^^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `parallel` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `std::f64::consts`
 --> src/bessel_k0.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts`
 --> src/bessel_k1.rs:1:5
  |
1 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_y1.rs:550:7
    |
550 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `PI`
 --> src/bessel_y1.rs:1:24
  |
1 | use std::f64::consts::{PI, FRAC_PI_4};
  |                        ^^

warning: unused import: `super::*`
 --> src/bessel_y1.rs:9:9
  |
9 |     use super::*;
  |         ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessel_yn.rs:583:7
    |
583 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `super::*`
 --> src/bessel_yn.rs:7:9
  |
7 |     use super::*;
  |         ^^^^^^^^

warning: unused import: `super::*`
  --> src/bessel_yn.rs:67:9
   |
67 |     use super::*;
   |         ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessik.rs:471:7
    |
471 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `FRAC_PI_2`
 --> src/bessik.rs:1:28
  |
1 | use std::f64::consts::{PI, FRAC_PI_2};
  |                            ^^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/bessj0.rs:390:7
    |
390 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/bessy0.rs:515:7
    |
515 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/beta.rs:184:7
    |
184 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `std::f32::consts::LN_2`
 --> src/beta.rs:1:5
  |
1 | use std::f32::consts::LN_2;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
 --> src/beta.rs:2:5
  |
2 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^

warning: unused import: `std::sync::OnceLock`
 --> src/Carlson_elliptic_integral_first.rs:4:5
  |
4 | use std::sync::OnceLock;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ptr`
 --> src/chebpc.rs:1:5
  |
1 | use std::ptr;
  |     ^^^^^^^^

warning: unused import: `std::f64::consts::PI`
 --> src/Convolve.rs:1:5
  |
1 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `SQRT_2`
 --> src/dawson_integral.rs:3:28
  |
3 | use std::f64::consts::{PI, SQRT_2};
  |                            ^^^^^^

warning: unused import: `Arc`
 --> src/ddpoly.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/ei.rs:315:7
    |
315 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unexpected `cfg` condition value: `bench`
   --> src/error_functions.rs:440:7
    |
440 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `SQRT_2`
 --> src/error_functions.rs:1:28
  |
1 | use std::f32::consts::{PI, SQRT_2};
  |                            ^^^^^^

warning: unused doc comment
  --> src/eulsum.rs:92:1
   |
92 | /// Thread-local Euler summation for better performance in single-threaded contexts
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion
   = note: `#[warn(unused_doc_comments)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Arc`
 --> src/eulsum.rs:1:17
  |
1 | use std::sync::{Arc, Mutex, RwLock};
  |                 ^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/exponential_integral.rs:313:7
    |
313 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `SeekFrom` and `Seek`
 --> src/Four_FS.rs:2:15
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |               ^^^^  ^^^^^^^^

warning: unused imports: `Arc` and `Mutex`
 --> src/Four_FS.rs:6:17
  |
6 | use std::sync::{Arc, Mutex};
  |                 ^^^  ^^^^^

warning: unused imports: `SeekFrom` and `Seek`
 --> src/Fourn.rs:2:15
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |               ^^^^  ^^^^^^^^

warning: unused imports: `Arc` and `Mutex`
 --> src/Fourn.rs:6:17
  |
6 | use std::sync::{Arc, Mutex};
  |                 ^^^  ^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/gamma_continued_funciton.rs:335:7
    |
335 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/gamma_continued_funciton.rs:1:24
  |
1 | use std::f32::consts::{E, PI};
  |                        ^

warning: unexpected `cfg` condition value: `bench`
   --> src/gamma_series.rs:329:7
    |
329 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `E` and `LN_2`
 --> src/gamma_series.rs:1:24
  |
1 | use std::f32::consts::{E, LN_2, PI};
  |                        ^  ^^^^

warning: unused doc comment
  --> src/gammln.rs:23:1
   |
23 | /// Thread-local cache for frequently computed values
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
   |
   = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion

warning: unused import: `std::mem`
 --> src/gaussjdcp.rs:1:5
  |
1 | use std::mem;
  |     ^^^^^^^^

warning: unexpected `cfg` condition value: `bench`
   --> src/inc_beta_func.rs:398:7
    |
398 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/inc_beta_func.rs:1:24
  |
1 | use std::f64::consts::{E, PI};
  |                        ^

warning: unexpected `cfg` condition value: `bench`
   --> src/incomplete_gamma.rs:326:7
    |
326 | #[cfg(feature = "bench")]
    |       ^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `bench` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `E`
 --> src/incomplete_gamma.rs:1:24
  |
1 | use std::f32::consts::{E, PI};
  |                        ^

warning: unused import: `std::f64::consts::FRAC_1_PI`
 --> src/Jacobian_elliptical.rs:2:5
  |
2 | use std::f64::consts::FRAC_1_PI;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Arc`
 --> src/pade.rs:3:17
  |
3 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `std::ptr`
 --> src/pccheb.rs:2:5
  |
2 | use std::ptr;
  |     ^^^^^^^^

warning: unused import: `Arc`
 --> src/polydiv.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `rayon::prelude::*`
 --> src/quad3d.rs:1:5
  |
1 | use rayon::prelude::*;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `Mutex`
 --> src/quad3d.rs:2:22
  |
2 | use std::sync::{Arc, Mutex};
  |                      ^^^^^

warning: unused import: `std::f64::consts::PI`
 --> src/quad3d.rs:3:5
  |
3 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Arc`
 --> src/random_0.rs:3:17
  |
3 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_0.rs:141:11
    |
141 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_1.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_1.rs:3:5
  |
3 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_1.rs:213:11
    |
213 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_2.rs:2:17
  |
2 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_2.rs:3:5
  |
3 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_2.rs:281:11
    |
281 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `Arc`
 --> src/random_3.rs:1:17
  |
1 | use std::sync::{Arc, Mutex};
  |                 ^^^

warning: unused import: `lazy_static::lazy_static`
 --> src/random_3.rs:2:5
  |
2 | use lazy_static::lazy_static;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `std`
   --> src/random_3.rs:259:11
    |
259 |     #[cfg(feature = "std")]
    |           ^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `async` and `tokio`
    = help: consider adding `std` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused import: `std::f64::consts`
 --> src/Recursive_Stratified_Sampling.rs:7:5
  |
7 | use std::f64::consts;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::*`
   --> src/lib.rs:191:13
    |
191 |     pub use std::f64::consts::*;
    |             ^^^^^^^^^^^^^^^^^^^

error[E0433]: failed to resolve: use of undeclared type `Array1`
  --> src/beschd.rs:39:14
   |
39 |     let c1 = Array1::from_vec(vec![
   |              ^^^^^^ use of undeclared type `Array1`

error[E0433]: failed to resolve: use of undeclared type `Array1`
  --> src/beschd.rs:50:14
   |
50 |     let c2 = Array1::from_vec(vec![
   |              ^^^^^^ use of undeclared type `Array1`

error[E0433]: failed to resolve: use of undeclared type `Array1`
   --> src/beschd.rs:133:13
    |
133 |     let p = Array1::from_vec(vec![
    |             ^^^^^^ use of undeclared type `Array1`

error[E0277]: cannot multiply `f64` by `T`
   --> src/beschd.rs:147:26
    |
147 |         return PI / ((PI * x).sin() * lanczos_gamma(T::one() - x));
    |                          ^ no implementation for `f64 * T`
    |
    = help: the trait `Mul<T>` is not implemented for `f64`
help: consider extending the `where` clause, but there might be an alternative better way to express this requirement
    |
130 |     T: BesselFloat, f64: Mul<T>
    |                     +++++++++++

error[E0282]: type annotations needed
   --> src/beschd.rs:147:31
    |
147 |         return PI / ((PI * x).sin() * lanczos_gamma(T::one() - x));
    |                               ^^^ cannot infer type

error[E0308]: mismatched types
   --> src/beschd.rs:147:16
    |
128 | fn lanczos_gamma<T>(z: T) -> T
    |                  -           - expected `T` because of return type
    |                  |
    |                  expected this type parameter
...
147 |         return PI / ((PI * x).sin() * lanczos_gamma(T::one() - x));
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `T`, found `f64`
    |
    = note: expected type parameter `T`
                         found type `f64`
    = note: the caller chooses a type for `T` which can be different from `f64`

error[E0368]: binary assignment operation `-=` cannot be applied to type `T`
   --> src/beschd.rs:150:5
    |
150 |     x -= T::one();
    |     -^^^^^^^^^^^^
    |     |
    |     cannot use `-=` on type `T`
    |
help: consider further restricting type parameter `T` with trait `SubAssign`
    |
130 |     T: BesselFloat + std::ops::SubAssign,
    |                    +++++++++++++++++++++

error[E0368]: binary assignment operation `+=` cannot be applied to type `T`
   --> src/beschd.rs:154:9
    |
154 |         a += p_val / (x + T::from_i32(i as i32 + 1).unwrap());
    |         -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |         |
    |         cannot use `+=` on type `T`

error[E0308]: mismatched types
   --> src/beschd.rs:158:34
    |
128 | fn lanczos_gamma<T>(z: T) -> T
    |                  - expected this type parameter
...
158 |     (T::from_f64(2.0).unwrap() * PI).sqrt() * t.powf(x + T::from_f64(0.5).unwrap()) * (-t).exp() * a
    |      -------------------------   ^^ expected type parameter `T`, found `f64`
    |      |
    |      expected because this is `T`
    |
    = note: expected type parameter `T`
                         found type `f64`

error[E0308]: mismatched types
   --> src/beschd.rs:166:40
    |
162 | pub fn beschd_multithreaded<T>(x_values: &ArrayView1<T>, num_threads: usize) -> Array1<(T, T, T, T)>
    |                             - expected this type parameter
...
166 |     let chunk_size = (x_values.len() + num_threads - 1) / num_threads;
    |                                        ^^^^^^^^^^^ expected type parameter `T`, found `usize`
    |
    = note: expected type parameter `T`
                         found type `usize`

error[E0308]: mismatched types
   --> src/beschd.rs:166:54
    |
162 | pub fn beschd_multithreaded<T>(x_values: &ArrayView1<T>, num_threads: usize) -> Array1<(T, T, T, T)>
    |                             - expected this type parameter
...
166 |     let chunk_size = (x_values.len() + num_threads - 1) / num_threads;
    |                                                      ^ expected type parameter `T`, found integer
    |
    = note: expected type parameter `T`
                         found type `{integer}`

error[E0308]: mismatched types
   --> src/beschd.rs:166:59
    |
162 | pub fn beschd_multithreaded<T>(x_values: &ArrayView1<T>, num_threads: usize) -> Array1<(T, T, T, T)>
    |                             - expected this type parameter
...
166 |     let chunk_size = (x_values.len() + num_threads - 1) / num_threads;
    |                                                           ^^^^^^^^^^^ expected type parameter `T`, found `usize`
    |
    = note: expected type parameter `T`
                         found type `usize`

error[E0282]: type annotations needed
   --> src/beschd.rs:169:15
    |
169 |         .map(|chunk| chunk.to_owned())
    |               ^^^^^        -------- type must be known at this point
    |
help: consider giving this closure parameter an explicit type
    |
169 |         .map(|chunk: /* Type */| chunk.to_owned())
    |                    ++++++++++++

error[E0282]: type annotations needed
   --> src/beschd.rs:180:58
    |
180 |             let chunk_results: Vec<(T, T, T, T)> = chunk.iter()
    |                                                          ^^^^ cannot infer type

error[E0433]: failed to resolve: use of undeclared type `Array1`
   --> src/beschd.rs:198:5
    |
198 |     Array1::from_vec(final_results)
    |     ^^^^^^ use of undeclared type `Array1`

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_i.rs:195:10
     |
 195 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 153 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_i.rs:300:10
     |
 300 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 266 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_I1.rs:179:10
     |
 179 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 147 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_j.rs:314:10
     |
 314 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 282 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0277]: cannot multiply `i32` by `f64`
  --> src/bessel_jy.rs:51:25
   |
51 |     let mut rjl = isign * FPMIN;
   |                         ^ no implementation for `i32 * f64`
   |
   = help: the trait `Mul<f64>` is not implemented for `i32`
   = help: the following other types implement trait `Mul<Rhs>`:
             `&i32` implements `Mul<&Complex<i32>>`
             `&i32` implements `Mul<&num_complex::Complex<i32>>`
             `&i32` implements `Mul<Complex<i32>>`
             `&i32` implements `Mul<i32>`
             `&i32` implements `Mul<num_complex::Complex<i32>>`
             `&i32` implements `Mul`
             `i32` implements `Mul<&ArrayBase<S, D>>`
             `i32` implements `Mul<&Complex<i32>>`
           and 7 others

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_jy.rs:327:10
     |
 327 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `(T, T, T, T)` to implement `Debug`
     = note: 3 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<(T, T, T, T)>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 294 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0369]: cannot multiply `T` by `T`
  --> src/bessel_k0.rs:61:55
   |
61 |     coeffs.iter().rev().fold(T::zero(), |acc, &c| acc * x + c)
   |                                                   --- ^ - T
   |                                                   |
   |                                                   T
   |
help: consider further restricting type parameter `T` with trait `Mul`
   |
60 | fn polynomial_eval<T: BesselFloat + std::ops::Mul>(x: T, coeffs: &[T]) -> T {
   |                                   +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
  --> src/bessel_k0.rs:76:19
   |
76 |         let y = x * x / T::from_f64(4.0);
   |                 - ^ - T
   |                 |
   |                 T
   |
help: consider further restricting type parameter `T` with trait `Mul`
   |
68 |     T: BesselFloat + std::ops::Mul,
   |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
  --> src/bessel_k0.rs:94:14
   |
94 |         -((x / T::from_f64(2.0)).ln() * i0) + poly
   |            - ^ ---------------- T
   |            |
   |            T
   |
help: consider further restricting type parameter `T` with trait `Div`
   |
68 |     T: BesselFloat + std::ops::Div,
   |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
  --> src/bessel_k0.rs:97:34
   |
97 |         let y = T::from_f64(2.0) / x;
   |                 ---------------- ^ - T
   |                 |
   |                 T
   |
help: consider further restricting type parameter `T` with trait `Div`
   |
68 |     T: BesselFloat + std::ops::Div,
   |                    +++++++++++++++

error[E0600]: cannot apply unary operator `-` to type `T`
   --> src/bessel_k0.rs:113:9
    |
113 |         (-x).exp() / x.sqrt() * poly
    |         ^^^^ cannot apply unary operator `-`
    |
help: consider further restricting type parameter `T` with trait `Neg`
    |
 68 |     T: BesselFloat + std::ops::Neg,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:125:20
    |
125 |         let y = (x / T::from_f64(3.75)).powi(2);
    |                  - ^ ----------------- T
    |                  |
    |                  T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
120 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:139:35
    |
139 |         let y = T::from_f64(3.75) / ax;
    |                 ----------------- ^ -- T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
120 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:165:20
    |
165 |         let y = (x / T::from_f64(3.75)).powi(2);
    |                  - ^ ----------------- T
    |                  |
    |                  T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
160 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:179:35
    |
179 |         let y = T::from_f64(3.75) / ax;
    |                 ----------------- ^ -- T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
160 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
   --> src/bessel_k0.rs:213:19
    |
213 |         let y = x * x / T::from_f64(4.0);
    |                 - ^ - T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Mul`
    |
206 |     T: BesselFloat + std::ops::Mul,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:229:12
    |
229 |         (x / T::from_f64(2.0)).ln() * i1 + (T::one() / x) * poly
    |          - ^ ---------------- T
    |          |
    |          T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:229:54
    |
229 |         (x / T::from_f64(2.0)).ln() * i1 + (T::one() / x) * poly
    |                                             -------- ^ - T
    |                                             |
    |                                             T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:231:34
    |
231 |         let y = T::from_f64(2.0) / x;
    |                 ---------------- ^ - T
    |                 |
    |                 T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
206 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0600]: cannot apply unary operator `-` to type `T`
   --> src/bessel_k0.rs:246:9
    |
246 |         (-x).exp() / x.sqrt() * poly
    |         ^^^^ cannot apply unary operator `-`
    |
help: consider further restricting type parameter `T` with trait `Neg`
    |
206 |     T: BesselFloat + std::ops::Neg,
    |                    +++++++++++++++

error[E0369]: cannot divide `T` by `T`
   --> src/bessel_k0.rs:267:40
    |
267 |             let tox = T::from_f64(2.0) / x;
    |                       ---------------- ^ - T
    |                       |
    |                       T
    |
help: consider further restricting type parameter `T` with trait `Div`
    |
253 |     T: BesselFloat + std::ops::Div,
    |                    +++++++++++++++

error[E0369]: cannot multiply `T` by `T`
   --> src/bessel_k0.rs:272:54
    |
272 |                 let bkp = bkm + T::from_i32(k) * tox * bk;
    |                                 -------------------- ^ -- T
    |                                 |
    |                                 T
    |
help: consider further restricting type parameter `T` with trait `Mul`
    |
253 |     T: BesselFloat + std::ops::Mul,
    |                    +++++++++++++++

error[E0277]: `T` doesn't implement `Debug`
    --> src/bessel_k1.rs:260:10
     |
 260 |         .unwrap()
     |          ^^^^^^ the trait `Debug` is not implemented for `T`
     |
     = note: required for `Vec<T>` to implement `Debug`
     = note: 2 redundant requirements hidden
     = note: required for `Arc<std::sync::Mutex<Vec<T>>>` to implement `Debug`
note: required by a bound in `Result::<T, E>::unwrap`
    --> /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1222:12
     |
1220 |     pub fn unwrap(self) -> T
     |            ------ required by a bound in this associated function
1221 |     where
1222 |         E: fmt::Debug,
     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`
help: consider further restricting type parameter `T` with trait `Debug`
     |
 228 |     T: BesselFloat + Send + Sync + 'static + std::fmt::Debug,
     |                                            +++++++++++++++++

error[E0599]: the method `get` exists for struct `std::sync::MutexGuard<'_, HashMap<f64, f64>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:114:42
    |
114 |             if let Some(&result) = cache.get(&x) {
    |                                          ^^^ method cannot be called on `std::sync::MutexGuard<'_, HashMap<f64, f64>>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            `f64: Hash`

error[E0599]: the method `insert` exists for struct `std::sync::MutexGuard<'_, HashMap<f64, f64>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:124:19
    |
124 |             cache.insert(x, result);
    |                   ^^^^^^
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            `f64: Hash`

error[E0599]: the method `entry` exists for struct `MutexGuard<'_, HashMap<(f64, f64, usize), Arc<...>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_approx.rs:227:15
    |
227 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64, usize): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64, usize): Hash`
    = note: the full name for the type has been written to '/home/archdabe/Documents/Numerical-recipies/Rust/numrs/target/debug/deps/num_rs-dd87f36d2e460a72.long-type-2519982621937593394.txt'
    = note: consider using `--verbose` to print the full type name to the console

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), Arc<ChebyshevOperator>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_calc.rs:293:15
    |
293 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), Arc<ChebyshevOperator>>>`, but its trait bounds were not satisfied
   --> src/chebyshev_calc.rs:306:15
    |
306 |         cache.entry(key)
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0061]: this function takes 2 arguments but 4 arguments were supplied
   --> src/Correlation.rs:196:38
    |
196 |       let (mean1, mean2, std1, std2) = rayon::join(
    |                                        ^^^^^^^^^^^
...
199 | /         || {
200 | |             let mean1 = data1.iter().sum::<f64>() / n as f64;
201 | |             (data1.iter().map(|&x| (x - mean1).powi(2)).sum::<f64>() / n as f64).sqrt()
202 | |         },
    | |_________- unexpected argument #3 of type `{closure@src/Correlation.rs:199:9: 199:11}`
203 | /         || {
204 | |             let mean2 = data2.iter().sum::<f64>() / n as f64;
205 | |             (data2.iter().map(|&x| (x - mean2).powi(2)).sum::<f64>() / n as f64).sqrt()
206 | |         },
    | |_________- unexpected argument #4 of type `{closure@src/Correlation.rs:203:9: 203:11}`
    |
note: function defined here
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-core-1.13.0/src/join/mod.rs:93:8
    |
 93 | pub fn join<A, B, RA, RB>(oper_a: A, oper_b: B) -> (RA, RB)
    |        ^^^^
help: remove the extra arguments
    |
198 -         || data2.iter().sum::<f64>() / n as f64,
199 -         || {
200 -             let mean1 = data1.iter().sum::<f64>() / n as f64;
201 -             (data1.iter().map(|&x| (x - mean1).powi(2)).sum::<f64>() / n as f64).sqrt()
202 -         },
198 +         || data2.iter().sum::<f64>() / n as f64,
    |

error[E0308]: mismatched types
   --> src/Correlation.rs:196:9
    |
196 |       let (mean1, mean2, std1, std2) = rayon::join(
    |  _________^^^^^^^^^^^^^^^^^^^^^^^^^^___-
    | |         |
    | |         expected a tuple with 2 elements, found one with 4 elements
197 | |         || data1.iter().sum::<f64>() / n as f64,
198 | |         || data2.iter().sum::<f64>() / n as f64,
199 | |         || {
...   |
206 | |         },
207 | |     );
    | |_____- this expression has type `(f64, f64)`
    |
    = note: expected tuple `(f64, f64)`
               found tuple `(_, _, _, _)`

error[E0599]: the method `zip` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
  --> src/Cos_FT.rs:38:10
   |
36 |       let partial_sums: Vec<f64> = (2..=half_n)
   |  __________________________________-
37 | |         .into_par_iter()
38 | |         .zip(rotation_factors.par_iter())
   | |_________-^^^
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
   |
45 |   pub struct Iter<T> {
   |   ------------------ doesn't satisfy `_: IndexedParallelIterator` or `rayon::range_inclusive::Iter<usize>: Iterator`
   |
   = note: the following trait bounds were not satisfied:
           `usize: range_inclusive::private::IndexedRangeInteger`
           which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`
           `rayon::range_inclusive::Iter<usize>: Iterator`
           which is required by `&mut rayon::range_inclusive::Iter<usize>: Iterator`

error[E0599]: the method `chunks` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
  --> src/Cos_FT.rs:97:32
   |
97 |     (2..=n>>1).into_par_iter().chunks(chunk_size).for_each(|chunk| {
   |                                ^^^^^^ method cannot be called on `rayon::range_inclusive::Iter<usize>` due to unsatisfied trait bounds
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
   |
45 | pub struct Iter<T> {
   | ------------------ doesn't satisfy `_: IndexedParallelIterator`
   |
   = note: the following trait bounds were not satisfied:
           `usize: range_inclusive::private::IndexedRangeInteger`
           which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`

error[E0689]: can't call method `to_bits` on ambiguous numeric type `{float}`
   --> src/Cos_FT.rs:123:40
    |
123 |         let local_sum_bits = local_sum.to_bits();
    |                                        ^^^^^^^
    |
help: you must specify a type for this binding, like `f32`
    |
100 |         let mut local_sum: f32 = 0.0;
    |                          +++++

error[E0599]: the method `into_par_iter` exists for struct `std::iter::StepBy<std::ops::RangeInclusive<usize>>`, but its trait bounds were not satisfied
  --> src/Cos_FT2.rs:66:10
   |
65 | /     (3..=n).step_by(2)
66 | |         .into_par_iter()
   | |_________-^^^^^^^^^^^^^
   |
  ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:16:1
   |
16 |   pub struct StepBy<I> {
   |   -------------------- doesn't satisfy `_: IntoParallelIterator` or `_: ParallelIterator`
   |
   = note: the following trait bounds were not satisfied:
           `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
           `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
           `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
           which is required by `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`

error[E0599]: the method `into_par_iter` exists for struct `std::iter::StepBy<std::ops::RangeInclusive<usize>>`, but its trait bounds were not satisfied
   --> src/Cos_FT2.rs:120:10
    |
119 | /     (3..=n).step_by(2)
120 | |         .into_par_iter()
    | |_________-^^^^^^^^^^^^^
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:16:1
    |
 16 |   pub struct StepBy<I> {
    |   -------------------- doesn't satisfy `_: IntoParallelIterator` or `_: ParallelIterator`
    |
    = note: the following trait bounds were not satisfied:
            `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
            `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `&std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`
            `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::ParallelIterator`
            which is required by `&mut std::iter::StepBy<std::ops::RangeInclusive<usize>>: rayon::iter::IntoParallelIterator`

error[E0599]: the method `chunks` exists for struct `rayon::range_inclusive::Iter<usize>`, but its trait bounds were not satisfied
   --> src/Cos_FT2.rs:142:34
    |
142 |     (1..=half_n).into_par_iter().chunks(chunk_size).for_each(|chunk| {
    |                                  ^^^^^^ method cannot be called on `rayon::range_inclusive::Iter<usize>` due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/range_inclusive.rs:45:1
    |
 45 | pub struct Iter<T> {
    | ------------------ doesn't satisfy `_: IndexedParallelIterator`
    |
    = note: the following trait bounds were not satisfied:
            `usize: range_inclusive::private::IndexedRangeInteger`
            which is required by `rayon::range_inclusive::Iter<usize>: rayon::iter::IndexedParallelIterator`

error[E0600]: cannot apply unary operator `-` to type `usize`
  --> src/Cosine_Sine_Integrals.rs:79:17
   |
79 |         let a = -((i - 1) * (i - 1)) as f64;
   |                 ^^^^^^^^^^^^^^^^^^^^ cannot apply unary operator `-`
   |
   = note: unsigned values cannot be negated

error[E0599]: no method named `abs_diff` found for type `f64` in the current scope
   --> src/Cosine_Sine_Integrals.rs:274:22
    |
274 |         if del.abs().abs_diff(1.0) < EPS {
    |                      ^^^^^^^^
    |
help: there is a method `abs_diff_eq` with a similar name, but with different arguments
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/approx-0.5.1/src/abs_diff_eq.rs:21:5
    |
 21 |     fn abs_diff_eq(&self, other: &Rhs, epsilon: Self::Epsilon) -> bool;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<Vec<f64>, PolynomialDifferentiator>>`, but its trait bounds were not satisfied
   --> src/ddpoly.rs:171:15
    |
171 |         cache.entry(key.clone())
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<f64>: Hash` or `Vec<f64>: std::cmp::Eq`
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `Vec<f64>: std::cmp::Eq`
            `f64: Hash`
            which is required by `Vec<f64>: Hash`

error[E0599]: the method `get` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), (f64, f64)>>`, but its trait bounds were not satisfied
   --> src/dfridr.rs:122:42
    |
122 |             if let Some(&result) = cache.get(&key) {
    |                                          ^^^ method cannot be called due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0599]: the method `insert` exists for struct `std::sync::MutexGuard<'_, HashMap<(f64, f64), (f64, f64)>>`, but its trait bounds were not satisfied
   --> src/dfridr.rs:133:19
    |
133 |             cache.insert(key, result);
    |                   ^^^^^^
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `(f64, f64): std::cmp::Eq`
            `f64: Hash`
            which is required by `(f64, f64): Hash`

error[E0277]: `F` cannot be shared between threads safely
   --> src/dfridr.rs:209:28
    |
209 |     let estimated = dfridr(func, x, h, &mut err);
    |                     ------ ^^^^ `F` cannot be shared between threads safely
    |                     |
    |                     required by a bound introduced by this call
    |
note: required by a bound in `dfridr`
   --> src/dfridr.rs:24:25
    |
 22 | pub fn dfridr<F>(func: F, x: f64, h: f64, err: &mut f64) -> f64 
    |        ------ required by a bound in this function
 23 | where
 24 |     F: Fn(f64) -> f64 + Sync + Send,
    |                         ^^^^ required by this bound in `dfridr`
help: use parentheses to call this type parameter
    |
209 |     let estimated = dfridr(func(/* f64 */), x, h, &mut err);
    |                                +++++++++++
help: consider further restricting type parameter `F` with trait `Sync`
    |
205 |     F: Fn(f64) -> f64 + std::marker::Sync,
    |                       +++++++++++++++++++

error[E0277]: `F` cannot be sent between threads safely
   --> src/dfridr.rs:209:28
    |
209 |     let estimated = dfridr(func, x, h, &mut err);
    |                     ------ ^^^^ `F` cannot be sent between threads safely
    |                     |
    |                     required by a bound introduced by this call
    |
note: required by a bound in `dfridr`
   --> src/dfridr.rs:24:32
    |
 22 | pub fn dfridr<F>(func: F, x: f64, h: f64, err: &mut f64) -> f64 
    |        ------ required by a bound in this function
 23 | where
 24 |     F: Fn(f64) -> f64 + Sync + Send,
    |                                ^^^^ required by this bound in `dfridr`
help: use parentheses to call this type parameter
    |
209 |     let estimated = dfridr(func(/* f64 */), x, h, &mut err);
    |                                +++++++++++
help: consider further restricting type parameter `F` with trait `Send`
    |
205 |     F: Fn(f64) -> f64 + std::marker::Send,
    |                       +++++++++++++++++++

error[E0277]: `*mut f64` cannot be shared between threads safely
   --> src/FFT_2.rs:105:41
    |
105 |       (1..max_k).into_par_iter().for_each(|k| {
    |                                  -------- ^--
    |                                  |        |
    |  ________________________________|________within this `{closure@src/FFT_2.rs:105:41: 105:44}`
    | |                                |
    | |                                required by a bound introduced by this call
106 | |         let j = 2 * k;
107 | |         if j >= n + 2 {
108 | |             return;
...   |
131 | |     });
    | |_____^ `*mut f64` cannot be shared between threads safely
    |
    = help: within `{closure@src/FFT_2.rs:105:41: 105:44}`, the trait `Sync` is not implemented for `*mut f64`
    = note: required because it appears within the type `&*mut f64`
note: required because it's used within this closure
   --> src/FFT_2.rs:105:41
    |
105 |     (1..max_k).into_par_iter().for_each(|k| {
    |                                         ^^^
note: required by a bound in `rayon::iter::ParallelIterator::for_each`
   --> /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/iter/mod.rs:375:30
    |
373 |     fn for_each<OP>(self, op: OP)
    |        -------- required by a bound in this associated function
374 |     where
375 |         OP: Fn(Self::Item) + Sync + Send,
    |                              ^^^^ required by this bound in `ParallelIterator::for_each`

error[E0308]: arguments to this method are incorrect
   --> src/FFT_2.rs:262:18
    |
262 |             self.process(data1, data2, fft1, fft2);
    |                  ^^^^^^^               ----  ---- types differ in mutability
    |                                        |
    |                                        types differ in mutability
    |
    = note: expected mutable reference `&mut _`
                       found reference `&&mut _`
    = note: expected mutable reference `&mut _`
                       found reference `&&mut _`
note: method defined here
   --> src/FFT_2.rs:245:12
    |
245 |     pub fn process(&self, data1: &[f64], data2: &[f64], fft1: &mut [f64], fft2: &mut [f64]) {
    |            ^^^^^^^                                      ----------------  ----------------

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:279:32
    |
279 |         let amu0 = (alf + 1.0).gamma();
    |                                ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:298:60
    |
298 |         let amu0 = 2.0f64.powf(alfbet + 1.0) * (alf + 1.0).gamma() * (bet + 1.0).gamma() / 
    |                                                            ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:298:82
    |
298 |         let amu0 = 2.0f64.powf(alfbet + 1.0) * (alf + 1.0).gamma() * (bet + 1.0).gamma() / 
    |                                                                                  ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaucof.rs:299:35
    |
299 |                    (alfbet + 2.0).gamma();
    |                                   ^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaujac.rs:96:40
   |
96 |         let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
   |                                        ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaujac.rs:96:72
   |
96 |         let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
   |                                                                        ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaujac.rs:97:40
   |
97 |         let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
   |                                        ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaujac.rs:97:81
   |
97 |         let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
   |                                                                                 ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:191:44
    |
191 |             let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
    |                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:191:76
    |
191 |             let log_num = (alf + n as f64).ln_gamma().0 + (bet + n as f64).ln_gamma().0;
    |                                                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:192:44
    |
192 |             let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
    |                                            ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaujac.rs:192:85
    |
192 |             let log_den = (n as f64 + 1.0).ln_gamma().0 + (n as f64 + alfbet + 1.0).ln_gamma().0;
    |                                                                                     ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaulag.rs:80:43
   |
80 |         let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
   |                                           ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
  --> src/gaulag.rs:80:69
   |
80 |         let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
   |                                                                     ^^^^^^^^
   |
   = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
   = help: add `#![feature(float_gamma)]` to the crate attributes to enable
   = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaulag.rs:148:47
    |
148 |             let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
    |                                               ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0658]: use of unstable library feature `float_gamma`
   --> src/gaulag.rs:148:73
    |
148 |             let log_weight = (alf + n as f64).ln_gamma().0 - (n as f64).ln_gamma().0;
    |                                                                         ^^^^^^^^
    |
    = note: see issue #99842 <https://github.com/rust-lang/rust/issues/99842> for more information
    = help: add `#![feature(float_gamma)]` to the crate attributes to enable
    = note: this compiler was built on 2025-10-01; consider upgrading it if it is out of date

error[E0600]: cannot apply unary operator `-` to type `usize`
   --> src/incomplete_gamma.rs:127:14
    |
127 |         an = -i as f32 * (i as f32 - a);
    |              ^^ cannot apply unary operator `-`
    |
    = note: unsigned values cannot be negated

error[E0277]: cannot add `[{float}; 14]` to `{float}`
  --> src/Jacobian_elliptical.rs:34:27
   |
34 |         let mut c = 0.5*(a+em);
   |                           ^ no implementation for `{float} + [{float}; 14]`
   |
   = help: the trait `Add<[{float}; 14]>` is not implemented for `{float}`
   = help: the following other types implement trait `Add<Rhs>`:
             `&f128` implements `Add<f128>`
             `&f128` implements `Add`
             `&f16` implements `Add<f16>`
             `&f16` implements `Add`
             `&f32` implements `Add<&Complex<f32>>`
             `&f32` implements `Add<&num_complex::Complex<f32>>`
             `&f32` implements `Add<Complex<f32>>`
             `&f32` implements `Add<f32>`
           and 192 others

error[E0282]: type annotations needed for `Arc<_, _>`
   --> src/orthog.rs:127:13
    |
127 |         let sig_clone = Arc::clone(&sig);
    |             ^^^^^^^^^
...
135 |                 let sig_guard = sig_clone.lock().unwrap();
    |                                           ---- type must be known at this point
    |
help: consider giving `sig_clone` an explicit type, where the placeholders `_` are specified
    |
127 |         let sig_clone: Arc<T, A> = Arc::clone(&sig);
    |                      +++++++++++

error[E0689]: can't call method `max` on ambiguous numeric type `{float}`
   --> src/pade.rs:145:23
    |
145 |             big = big.max(a[[i, j]].abs());
    |                       ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
143 |         let mut big: f32 = 0.0;
    |                    +++++

error[E0689]: can't call method `max` on ambiguous numeric type `{float}`
   --> src/pade.rs:402:31
    |
402 |         max_error = max_error.max(error);
    |                               ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
380 |     let mut max_error: f32 = 0.0;
    |                      +++++

error[E0600]: cannot apply unary operator `!` to type `f64`
  --> src/polydiv.rs:19:13
   |
19 |     assert!(!v[0].abs() < f64::EPSILON, "Divisor leading coefficient cannot be zero");
   |             ^^^^^^^^^^^ cannot apply unary operator `!`

error[E0600]: cannot apply unary operator `!` to type `f64`
  --> src/polydiv.rs:54:13
   |
54 |     assert!(!v[0].abs() < f64::EPSILON, "Divisor leading coefficient cannot be zero");
   |             ^^^^^^^^^^^ cannot apply unary operator `!`

error[E0599]: the method `entry` exists for struct `std::sync::MutexGuard<'_, HashMap<Vec<f64>, PolynomialDivider>>`, but its trait bounds were not satisfied
   --> src/polydiv.rs:179:15
    |
179 |         cache.entry(key.clone())
    |               ^^^^^ method cannot be called due to unsatisfied trait bounds
    |
   ::: /home/archdabe/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:434:1
    |
434 | pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global> {
    | ------------------------------------------------------------------------------------------------ doesn't satisfy `Vec<f64>: Hash` or `Vec<f64>: std::cmp::Eq`
    |
    = note: the following trait bounds were not satisfied:
            `f64: std::cmp::Eq`
            which is required by `Vec<f64>: std::cmp::Eq`
            `f64: Hash`
            which is required by `Vec<f64>: Hash`

error[E0599]: no method named `clone` found for type parameter `F` in the current scope
   --> src/qgaus.rs:132:51
    |
109 | fn adaptive_recursive<F>(
    |                       - method `clone` not found for this type parameter
...
132 |         let left_result = adaptive_recursive(func.clone(), a, mid, left, tol, max_depth, depth + 1);
    |                                                   ^^^^^ method not found in `F`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: use parentheses to call this type parameter
    |
132 |         let left_result = adaptive_recursive(func(/* f64 */).clone(), a, mid, left, tol, max_depth, depth + 1);
    |                                                  +++++++++++
help: the following trait defines an item `clone`, perhaps you need to restrict type parameter `F` with it:
    |
119 |     F: Fn(f64) -> f64 + Clone,
    |                       +++++++

error[E0277]: the trait bound `&F: Function3D` is not satisfied
   --> src/quad3d.rs:172:13
    |
171 |         return quad3d(
    |                ------ required by a bound introduced by this call
172 |             func.as_ref(),
    |             ^^^^^^^^^^^^^ the trait `Fn(f64, f64, f64)` is not implemented for `F`
    |
    = note: required for `&F` to implement `FnOnce(f64, f64, f64)`
note: required for `&F` to implement `Function3D`
   --> src/quad3d.rs:11:9
    |
 11 | impl<F> Function3D for F
    |         ^^^^^^^^^^     ^
 12 | where
 13 |     F: Fn(f64, f64, f64) -> f64 + Sync + Send,
    |                             --- unsatisfied trait bound introduced here
note: required by a bound in `quad3d`
   --> src/quad3d.rs:80:8
    |
 70 | pub fn quad3d<F, Y1, Y2, Z1, Z2>(
    |        ------ required by a bound in this function
...
 80 |     F: Function3D,
    |        ^^^^^^^^^^ required by this bound in `quad3d`
help: consider further restricting type parameter `F` with trait `Fn`
    |
163 |     F: Function3D + Fn(f64, f64, f64),
    |                   +++++++++++++++++++

error[E0599]: the method `take` exists for struct `rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>`, but its trait bounds were not satisfied
  --> src/random_0.rs:83:10
   |
78 | /     seeds.par_iter()
79 | |         .flat_map(|&s| {
80 | |             let mut rng = Ran0::new(s);
81 | |             rng.generate(chunk_size.min(n))
82 | |         })
83 | |         .take(n)
   | |_________-^^^^
   |
  ::: /home/archdabe/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rayon-1.11.0/src/iter/flat_map.rs:12:1
   |
12 |   pub struct FlatMap<I, F> {
   |   ------------------------ doesn't satisfy `_: Iterator`
   |
   = note: the following trait bounds were not satisfied:
           `rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>: Iterator`
           which is required by `&mut rayon::iter::FlatMap<rayon::slice::Iter<'_, i64>, {closure@src/random_0.rs:79:19: 79:23}>: Iterator`

error[E0282]: type annotations needed
   --> src/ratlsq.rs:113:43
    |
113 |                         result.extend(row.iter().copied());
    |                                           ^^^^ cannot infer type

error[E0015]: cannot call non-const method `std::f64::<impl f64>::sqrt` in constants
 --> src/spherical_bessel.rs:5:31
  |
5 | const RTPIO2: f64 = FRAC_PI_2.sqrt(); // √(π/2) ≈ 1.253314137
  |                               ^^^^^^
  |
  = note: calls in constants are limited to constant functions, tuple structs and tuple variants

error[E0282]: type annotations needed
  --> src/sprspm.rs:60:9
   |
60 |     ijc.insert(0, n);
   |         ^^^^^^ cannot infer type

warning: unused import: `Read`
 --> src/Four_FS.rs:2:31
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                               ^^^^

warning: unused import: `Write`
 --> src/Four_FS.rs:2:37
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                                     ^^^^^

warning: unused import: `Read`
 --> src/Fourn.rs:2:31
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                               ^^^^

warning: unused import: `Write`
 --> src/Fourn.rs:2:37
  |
2 | use std::io::{Seek, SeekFrom, Read, Write, Error, ErrorKind};
  |                                     ^^^^^

warning: variable does not need to be mutable
   --> src/airy.rs:150:13
    |
150 |         let mut x = x - 1.0;
    |             ----^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `rj2`
   --> src/airy.rs:322:14
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |              ^^^
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
    |
322 |         let (_rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (constants::CBRT_EPSILON, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `ry2`
   --> src/airy.rs:322:19
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                   ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, _ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                   +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, constants::CBRT_EPSILON, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `rjp2`
   --> src/airy.rs:322:24
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                        ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, ry2, _rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, ry2, constants::CBRT_EPSILON, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `ryp2`
   --> src/airy.rs:322:30
    |
322 |         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                              ^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
322 |         let (rj2, ry2, rjp2, _ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
    |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
322 -         let (rj2, ry2, rjp2, ryp2) = bessel_jy::bessjy(z, TWOTHR)?;
322 +         let (rj2, ry2, rjp2, constants::CBRT_EPSILON) = bessel_jy::bessjy(z, TWOTHR)?;
    |

warning: unused variable: `u3`
   --> src/bcucof.rs:176:9
    |
176 |     let u3 = u2 * u;
    |         ^^
    |
help: if this is intentional, prefix it with an underscore
    |
176 |     let _u3 = u2 * u;
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
176 -     let u3 = u2 * u;
176 +     let constants::CBRT_EPSILON = u2 * u;
    |

warning: unused variable: `x4`
  --> src/beschd.rs:92:9
   |
92 |     let x4 = x2 * x2;
   |         ^^ help: if this is intentional, prefix it with an underscore: `_x4`

warning: unused variable: `x`
   --> src/bessel_jy.rs:282:11
    |
282 | fn beschd(x: f64) -> (f64, f64, f64, f64) {
    |           ^
    |
help: if this is intentional, prefix it with an underscore
    |
282 | fn beschd(_x: f64) -> (f64, f64, f64, f64) {
    |           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
282 - fn beschd(x: f64) -> (f64, f64, f64, f64) {
282 + fn beschd(constants::CBRT_EPSILON: f64) -> (f64, f64, f64, f64) {
    |

warning: unused variable: `expected`
   --> src/bessel_yn.rs:391:9
    |
391 |     let expected = 2.0 / (PI * x);
    |         ^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
391 |     let _expected = 2.0 / (PI * x);
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
391 -     let expected = 2.0 / (PI * x);
391 +     let constants::CBRT_EPSILON = 2.0 / (PI * x);
    |

warning: unused variable: `i`
  --> src/bessik.rs:51:9
   |
51 |     for i in 1..=MAXIT {
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
51 |     for _i in 1..=MAXIT {
   |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
51 -     for i in 1..=MAXIT {
51 +     for constants::MAX_ITERATIONS in 1..=MAXIT {
   |

warning: unused variable: `x`
  --> src/bessik.rs:41:30
   |
41 | fn bessik_continued_fraction(x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |                              ^
   |
help: if this is intentional, prefix it with an underscore
   |
41 | fn bessik_continued_fraction(_x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
41 - fn bessik_continued_fraction(x: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
41 + fn bessik_continued_fraction(constants::CBRT_EPSILON: f64, xmu: f64, xi: f64, xi2: f64) -> Result<(f64, f64), String> {
   |

warning: variable does not need to be mutable
  --> src/bessik.rs:59:17
   |
59 |             let mut ril = FPMIN;
   |                 ----^^^
   |                 |
   |                 help: remove this `mut`

warning: variable does not need to be mutable
  --> src/bessik.rs:60:17
   |
60 |             let mut ripl = h * ril;
   |                 ----^^^^
   |                 |
   |                 help: remove this `mut`

warning: unused variable: `l`
   --> src/bessik.rs:176:9
    |
176 |     for l in (1..=nl).rev() {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
176 |     for _l in (1..=nl).rev() {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
    |
176 -     for l in (1..=nl).rev() {
176 +     for bessel_jy::MAXIT in (1..=nl).rev() {
    |

warning: variable does not need to be mutable
   --> src/bessik.rs:223:9
    |
223 |     let mut gam1 = chebyshev_eval(xx, &coef1);
    |         ----^^^^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/bessik.rs:224:9
    |
224 |     let mut gam2 = chebyshev_eval(xx, &coef2);
    |         ----^^^^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
  --> src/beta.rs:29:9
   |
29 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `y`
   --> src/bico.rs:106:13
    |
106 |     let mut y = x;
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
106 |     let mut _y = x;
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
106 -     let mut y = x;
106 +     let mut constants::CBRT_EPSILON = x;
    |

warning: variable does not need to be mutable
   --> src/bico.rs:106:9
    |
106 |     let mut y = x;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: unused variable: `x`
   --> src/Carlson_elliptic_integral_third.rs:155:11
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |           ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Carlson_elliptic_integral_third.rs:155:19
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                   ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |                   +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Carlson_elliptic_integral_third.rs:155:27
    |
155 | pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                           ^
    |
help: if this is intentional, prefix it with an underscore
    |
155 | pub fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                           +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
155 - pub fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
155 + pub fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `func`
   --> src/chebyshev_calc.rs:244:56
    |
244 | pub fn verify_derivative<F>(a: f64, b: f64, c: &[f64], func: F, deriv_func: F, n_test: usize, tol: f64) -> bool
    |                                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_func`

warning: unused variable: `data`
  --> src/Cos_FT.rs:71:11
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |           ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `n`
  --> src/Cos_FT.rs:71:29
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |                             ^
   |
help: if this is intentional, prefix it with an underscore
   |
71 | fn realft(data: &mut [f64], _n: usize, isign: i32) {
   |                             +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
71 - fn realft(data: &mut [f64], n: usize, isign: i32) {
71 + fn realft(data: &mut [f64], constants::MAX_ITERATIONS: usize, isign: i32) {
   |

warning: unused variable: `isign`
  --> src/Cos_FT.rs:71:39
   |
71 | fn realft(data: &mut [f64], n: usize, isign: i32) {
   |                                       ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
71 | fn realft(data: &mut [f64], n: usize, _isign: i32) {
   |                                       +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
71 - fn realft(data: &mut [f64], n: usize, isign: i32) {
71 + fn realft(data: &mut [f64], n: usize, bessel_jy::MAXIT: i32) {
   |

warning: unused variable: `data`
   --> src/Cos_FT2.rs:194:11
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |           ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `n`
   --> src/Cos_FT2.rs:194:29
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |                             ^
    |
help: if this is intentional, prefix it with an underscore
    |
194 | fn realft(data: &mut [f64], _n: usize, isign: i32) {
    |                             +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
194 - fn realft(data: &mut [f64], n: usize, isign: i32) {
194 + fn realft(data: &mut [f64], constants::MAX_ITERATIONS: usize, isign: i32) {
    |

warning: unused variable: `isign`
   --> src/Cos_FT2.rs:194:39
    |
194 | fn realft(data: &mut [f64], n: usize, isign: i32) {
    |                                       ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
194 | fn realft(data: &mut [f64], n: usize, _isign: i32) {
    |                                       +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
    |
194 - fn realft(data: &mut [f64], n: usize, isign: i32) {
194 + fn realft(data: &mut [f64], n: usize, bessel_jy::MAXIT: i32) {
    |

warning: unused variable: `theta_vec`
   --> src/Cos_FT2.rs:209:13
    |
209 |         let theta_vec = _mm256_set1_pd(theta);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_theta_vec`

warning[E0133]: call to function `std::arch::x86_64::_mm256_set1_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:200:25
    |
200 |             let x_vec = _mm256_set1_pd(x);
    |                         ^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx
note: an unsafe function restricts its caller, but its body is safe by default
   --> src/ddpoly.rs:184:1
    |
184 | pub unsafe fn ddpoly_simd(c: &[f64], x: f64, nd: usize) -> Vec<f64> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(unsafe_op_in_unsafe_fn)]` (part of `#[warn(rust_2024_compatibility)]`) on by default

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:204:28
    |
204 |                 let pd_j = _mm256_loadu_pd(pd.as_ptr().add(j - 3));
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::const_ptr::<impl *const T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:204:44
    |
204 |                 let pd_j = _mm256_loadu_pd(pd.as_ptr().add(j - 3));
    |                                            ^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:205:36
    |
205 |                 let pd_j_minus_1 = _mm256_loadu_pd(pd.as_ptr().add(j - 4));
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::const_ptr::<impl *const T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:205:52
    |
205 |                 let pd_j_minus_1 = _mm256_loadu_pd(pd.as_ptr().add(j - 4));
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to function `std::arch::x86_64::_mm256_mul_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:207:31
    |
207 |                 let product = _mm256_mul_pd(pd_j, x_vec);
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx

warning[E0133]: call to function `std::arch::x86_64::_mm256_add_pd` with `#[target_feature]` is unsafe and requires unsafe block
   --> src/ddpoly.rs:208:30
    |
208 |                 let result = _mm256_add_pd(product, pd_j_minus_1);
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to function with `#[target_feature]`
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = help: in order for the call to be safe, the context requires the following additional target feature: avx

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_storeu_pd` is unsafe and requires unsafe block
   --> src/ddpoly.rs:210:17
    |
210 |                 _mm256_storeu_pd(pd.as_mut_ptr().add(j - 3), result);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning[E0133]: call to unsafe function `std::ptr::mut_ptr::<impl *mut T>::add` is unsafe and requires unsafe block
   --> src/ddpoly.rs:210:34
    |
210 |                 _mm256_storeu_pd(pd.as_mut_ptr().add(j - 3), result);
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning: variable `factorial` is assigned to, but never used
   --> src/ei.rs:137:13
    |
137 |     let mut factorial = 1.0;
    |             ^^^^^^^^^
    |
    = note: consider using `_factorial` instead
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
137 -     let mut factorial = 1.0;
137 +     let mut constants::CBRT_EPSILON = 1.0;
    |

warning: unused variable: `k_prime`
   --> src/Elliptical_Legendre_First.rs:172:9
    |
172 |     let k_prime = (1.0 - k * k).sqrt();
    |         ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
172 |     let _k_prime = (1.0 - k * k).sqrt();
    |         +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
172 -     let k_prime = (1.0 - k * k).sqrt();
172 +     let constants::CBRT_EPSILON = (1.0 - k * k).sqrt();
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_First.rs:222:7
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_First.rs:222:15
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_First.rs:222:23
    |
222 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
222 | fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
222 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
222 + fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_Second.rs:232:7
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_Second.rs:232:15
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_Second.rs:232:23
    |
232 | fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
232 | fn rf(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
232 - fn rf(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
232 + fn rf(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `x`
   --> src/Elliptical_Legendre_Second.rs:238:7
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(_x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(constants::CBRT_EPSILON: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `y`
   --> src/Elliptical_Legendre_Second.rs:238:15
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |               ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(x: f64, _y: f64, z: f64) -> EllipticResult<f64> {
    |               +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(x: f64, constants::CBRT_EPSILON: f64, z: f64) -> EllipticResult<f64> {
    |

warning: unused variable: `z`
   --> src/Elliptical_Legendre_Second.rs:238:23
    |
238 | fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
    |                       ^
    |
help: if this is intentional, prefix it with an underscore
    |
238 | fn rd(x: f64, y: f64, _z: f64) -> EllipticResult<f64> {
    |                       +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
238 - fn rd(x: f64, y: f64, z: f64) -> EllipticResult<f64> {
238 + fn rd(x: f64, y: f64, constants::CBRT_EPSILON: f64) -> EllipticResult<f64> {
    |

warning: variable does not need to be mutable
   --> src/error_functions.rs:110:9
    |
110 |     let mut x = x - 1.0;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/eulsum.rs:158:21
    |
158 |                 let mut euler = instance.lock().unwrap();
    |                     ----^^^^^
    |                     |
    |                     help: remove this `mut`

warning: variable does not need to be mutable
   --> src/exponential_integral.rs:175:9
    |
175 |     let mut result = (-x).exp() / x;
    |         ----^^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `y`
   --> src/factrl.rs:212:13
    |
212 |     let mut y = x;
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
212 |     let mut _y = x;
    |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
212 -     let mut y = x;
212 +     let mut constants::CBRT_EPSILON = x;
    |

warning: variable does not need to be mutable
   --> src/factrl.rs:212:9
    |
212 |     let mut y = x;
    |         ----^
    |         |
    |         help: remove this `mut`

warning: unused variable: `isign`
  --> src/FFT_1.rs:47:100
   |
47 | fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                                                    ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
47 | fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, _isign: i32) {
   |                                                                                                    +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
47 - fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
47 + fn process_butterflies_sequential(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, bessel_jy::MAXIT: i32) {
   |

warning: unused variable: `wpr`
  --> src/FFT_1.rs:75:78
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                              ^^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, _wpr: f64, wpi: f64, isign: i32) {
   |                                                                              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 - fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
75 + fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, constants::CBRT_EPSILON: f64, wpi: f64, isign: i32) {
   |

warning: unused variable: `wpi`
  --> src/FFT_1.rs:75:88
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
   |                                                                                        ^^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 | fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, _wpi: f64, isign: i32) {
   |                                                                                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 - fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, wpi: f64, isign: i32) {
75 + fn process_butterflies_parallel(data: &mut [f64], mmax: usize, istep: usize, wpr: f64, constants::CBRT_EPSILON: f64, isign: i32) {
   |

error[E0596]: cannot borrow `*fft1` as mutable, as it is a captured variable in a `Fn` closure
  --> src/FFT_2.rs:44:28
   |
44 |             let fft1_ptr = fft1.as_mut_ptr();
   |                            ^^^^ cannot borrow as mutable

warning: unused variable: `state`
  --> src/Four_FS.rs:78:9
   |
78 |         state: &mut FFTState,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `file_state`
  --> src/Four_FS.rs:79:9
   |
79 |         file_state: &mut FileState,
   |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_file_state`

warning: unused variable: `isign`
  --> src/Four_FS.rs:80:9
   |
80 |         isign: i32,
   |         ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
80 |         _isign: i32,
   |         +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
80 -         isign: i32,
80 +         bessel_jy::MAXIT: i32,
   |

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_loadu_pd` is unsafe and requires unsafe block
   --> src/Fourn.rs:302:32
    |
302 |                 let data_vec = _mm256_loadu_pd(chunk.as_ptr());
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior
note: an unsafe function restricts its caller, but its body is safe by default
   --> src/Fourn.rs:278:1
    |
278 | pub unsafe fn fourn_simd(data: &mut [f64], nn: &[usize], ndim: usize, isign: i32) -> Result<(), Error> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning[E0133]: call to unsafe function `std::arch::x86_64::_mm256_storeu_pd` is unsafe and requires unsafe block
   --> src/Fourn.rs:309:17
    |
309 |                 _mm256_storeu_pd(chunk.as_mut_ptr(), result_vec);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/unsafe-op-in-unsafe-fn.html>
    = note: consult the function's documentation for information on how to avoid undefined behavior

warning: unused variable: `k`
   --> src/frenel.rs:121:9
    |
121 |     for k in 2..=MAXIT {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
121 |     for _k in 2..=MAXIT {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
121 -     for k in 2..=MAXIT {
121 +     for constants::MAX_ITERATIONS in 2..=MAXIT {
    |

warning: variable does not need to be mutable
  --> src/gamma_continued_funciton.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `gln`
   --> src/gamma_continued_funciton.rs:191:17
    |
191 |         let (p, gln) = super::gamma_series::gamma_series(a, x)?;
    |                 ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
191 |         let (p, _gln) = super::gamma_series::gamma_series(a, x)?;
    |                 +
help: you might have meant to pattern match on the similarly named constant `LARGE`
    |
191 -         let (p, gln) = super::gamma_series::gamma_series(a, x)?;
191 +         let (p, spline::LARGE) = super::gamma_series::gamma_series(a, x)?;
    |

warning: unused variable: `gln`
   --> src/gamma_continued_funciton.rs:195:17
    |
195 |         let (q, gln) = gamma_continued_fraction(a, x)?;
    |                 ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
195 |         let (q, _gln) = gamma_continued_fraction(a, x)?;
    |                 +
help: you might have meant to pattern match on the similarly named constant `LARGE`
    |
195 -         let (q, gln) = gamma_continued_fraction(a, x)?;
195 +         let (q, spline::LARGE) = gamma_continued_fraction(a, x)?;
    |

warning: variable does not need to be mutable
  --> src/gamma_series.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `n`
  --> src/gamma_series.rs:67:9
   |
67 |     for n in 1..=MAX_ITER {
   |         ^
   |
help: if this is intentional, prefix it with an underscore
   |
67 |     for _n in 1..=MAX_ITER {
   |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
   |
67 -     for n in 1..=MAX_ITER {
67 +     for constants::MAX_ITERATIONS in 1..=MAX_ITER {
   |

warning: unused variable: `n`
   --> src/gamma_series.rs:175:9
    |
175 |     for n in 1..=MAX_ITER {
    |         ^
    |
help: if this is intentional, prefix it with an underscore
    |
175 |     for _n in 1..=MAX_ITER {
    |         +
help: you might have meant to pattern match on the similarly named constant `MAX_ITERATIONS`
    |
175 -     for n in 1..=MAX_ITER {
175 +     for constants::MAX_ITERATIONS in 1..=MAX_ITER {
    |

warning: unused variable: `y`
  --> src/gammln.rs:44:13
   |
44 |     let mut y = x;
   |             ^
   |
help: if this is intentional, prefix it with an underscore
   |
44 |     let mut _y = x;
   |             +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
44 -     let mut y = x;
44 +     let mut constants::CBRT_EPSILON = x;
   |

warning: variable does not need to be mutable
  --> src/gammln.rs:44:9
   |
44 |     let mut y = x;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: unused variable: `b`
   --> src/gaucof.rs:162:21
    |
162 |                 let b = c * e[i];
    |                     ^
    |
help: if this is intentional, prefix it with an underscore
    |
162 |                 let _b = c * e[i];
    |                     +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
162 -                 let b = c * e[i];
162 +                 let constants::CBRT_EPSILON = c * e[i];
    |

warning: variable does not need to be mutable
   --> src/gaucof.rs:129:13
    |
129 |         let mut m = l;
    |             ----^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:146:17
    |
146 |             let mut g = d[l];
    |                 ----^
    |                 |
    |                 help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:147:17
    |
147 |             let mut p = (d[m] - g) / (2.0 * e[l]);
    |                 ----^
    |                 |
    |                 help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:241:13
    |
241 |         let mut a = vec![0.0; n];
    |             ----^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/gaucof.rs:255:13
    |
255 |         let mut a = vec![0.0; n];
    |             ----^
    |             |
    |             help: remove this `mut`

warning: value assigned to `pp` is never read
  --> src/gauher.rs:56:17
   |
56 |         let mut pp = 0.0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p1`
  --> src/gauher.rs:75:14
   |
75 |         let (p1, pp) = hermite_polynomial(n, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
75 |         let (_p1, pp) = hermite_polynomial(n, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
75 -         let (p1, pp) = hermite_polynomial(n, z);
75 +         let (constants::CBRT_EPSILON, pp) = hermite_polynomial(n, z);
   |

warning: value assigned to `pp` is never read
   --> src/gauher.rs:129:17
    |
129 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p1`
   --> src/gauher.rs:145:18
    |
145 |             let (p1, pp) = hermite_polynomial(n, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
145 |             let (_p1, pp) = hermite_polynomial(n, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
145 -             let (p1, pp) = hermite_polynomial(n, z);
145 +             let (constants::CBRT_EPSILON, pp) = hermite_polynomial(n, z);
    |

warning: unused variable: `x`
   --> src/gauher.rs:268:24
    |
268 |     pub fn constant_fn(x: f64) -> f64 {
    |                        ^
    |
help: if this is intentional, prefix it with an underscore
    |
268 |     pub fn constant_fn(_x: f64) -> f64 {
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
268 -     pub fn constant_fn(x: f64) -> f64 {
268 +     pub fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: value assigned to `pp` is never read
  --> src/gaujac.rs:73:17
   |
73 |         let mut pp = 0.0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
  --> src/gaujac.rs:76:22
   |
76 |             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
   |                      ^^
   |
help: if this is intentional, prefix it with an underscore
   |
76 |             let (p1, _p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
   |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
76 -             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
76 +             let (p1, constants::CBRT_EPSILON, new_pp) = jacobi_polynomial(n, alf, bet, z);
   |

warning: unused variable: `p1`
  --> src/gaujac.rs:92:14
   |
92 |         let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
92 |         let (_p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
92 -         let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
92 +         let (constants::CBRT_EPSILON, p2, pp) = jacobi_polynomial(n, alf, bet, z);
   |

warning: value assigned to `pp` is never read
   --> src/gaujac.rs:174:17
    |
174 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
   --> src/gaujac.rs:177:22
    |
177 |             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |                      ^^
    |
help: if this is intentional, prefix it with an underscore
    |
177 |             let (p1, _p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
177 -             let (p1, p2, new_pp) = jacobi_polynomial(n, alf, bet, z);
177 +             let (p1, constants::CBRT_EPSILON, new_pp) = jacobi_polynomial(n, alf, bet, z);
    |

warning: unused variable: `p1`
   --> src/gaujac.rs:190:18
    |
190 |             let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
190 |             let (_p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
190 -             let (p1, p2, pp) = jacobi_polynomial(n, alf, bet, z);
190 +             let (constants::CBRT_EPSILON, p2, pp) = jacobi_polynomial(n, alf, bet, z);
    |

warning: value assigned to `pp` is never read
  --> src/gaulag.rs:57:17
   |
57 |         let mut pp = 0.0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
  --> src/gaulag.rs:60:22
   |
60 |             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
   |                      ^^
   |
help: if this is intentional, prefix it with an underscore
   |
60 |             let (p1, _p2, new_pp) = laguerre_polynomial(n, alf, z);
   |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
60 -             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
60 +             let (p1, constants::CBRT_EPSILON, new_pp) = laguerre_polynomial(n, alf, z);
   |

warning: unused variable: `p1`
  --> src/gaulag.rs:76:14
   |
76 |         let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
76 |         let (_p1, p2, pp) = laguerre_polynomial(n, alf, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
76 -         let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
76 +         let (constants::CBRT_EPSILON, p2, pp) = laguerre_polynomial(n, alf, z);
   |

warning: value assigned to `pp` is never read
   --> src/gaulag.rs:131:17
    |
131 |         let mut pp = 0.0;
    |                 ^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `p2`
   --> src/gaulag.rs:134:22
    |
134 |             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
    |                      ^^
    |
help: if this is intentional, prefix it with an underscore
    |
134 |             let (p1, _p2, new_pp) = laguerre_polynomial(n, alf, z);
    |                      +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
134 -             let (p1, p2, new_pp) = laguerre_polynomial(n, alf, z);
134 +             let (p1, constants::CBRT_EPSILON, new_pp) = laguerre_polynomial(n, alf, z);
    |

warning: unused variable: `p1`
   --> src/gaulag.rs:147:18
    |
147 |             let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
147 |             let (_p1, p2, pp) = laguerre_polynomial(n, alf, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
147 -             let (p1, p2, pp) = laguerre_polynomial(n, alf, z);
147 +             let (constants::CBRT_EPSILON, p2, pp) = laguerre_polynomial(n, alf, z);
    |

warning: unused variable: `key`
   --> src/gaulag.rs:178:13
    |
178 |         let key = (n, alf.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `key`
   --> src/gaulag.rs:191:13
    |
191 |         let key = (n, alf.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `x`
   --> src/gaulag.rs:273:24
    |
273 |     pub fn constant_fn(x: f64) -> f64 {
    |                        ^
    |
help: if this is intentional, prefix it with an underscore
    |
273 |     pub fn constant_fn(_x: f64) -> f64 {
    |                        +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
273 -     pub fn constant_fn(x: f64) -> f64 {
273 +     pub fn constant_fn(constants::CBRT_EPSILON: f64) -> f64 {
    |

warning: unused variable: `p1`
  --> src/gauleg.rs:67:14
   |
67 |         let (p1, pp) = legendre_polynomial(n, z);
   |              ^^
   |
help: if this is intentional, prefix it with an underscore
   |
67 |         let (_p1, pp) = legendre_polynomial(n, z);
   |              +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
   |
67 -         let (p1, pp) = legendre_polynomial(n, z);
67 +         let (constants::CBRT_EPSILON, pp) = legendre_polynomial(n, z);
   |

warning: unused variable: `p1`
   --> src/gauleg.rs:126:18
    |
126 |             let (p1, pp) = legendre_polynomial(n, z);
    |                  ^^
    |
help: if this is intentional, prefix it with an underscore
    |
126 |             let (_p1, pp) = legendre_polynomial(n, z);
    |                  +
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
126 -             let (p1, pp) = legendre_polynomial(n, z);
126 +             let (constants::CBRT_EPSILON, pp) = legendre_polynomial(n, z);
    |

warning: unused variable: `key`
   --> src/gauleg.rs:158:13
    |
158 |         let key = (n, x1.to_bits(), x2.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `key`
   --> src/gauleg.rs:173:13
    |
173 |         let key = (n, x1.to_bits(), x2.to_bits());
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: variable does not need to be mutable
  --> src/inc_beta_func.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: variable does not need to be mutable
  --> src/incomplete_gamma.rs:32:9
   |
32 |     let mut x = x - 1.0;
   |         ----^
   |         |
   |         help: remove this `mut`

warning: variable does not need to be mutable
   --> src/Jacobian_elliptical.rs:175:17
    |
175 |             let mut u_scaled = u * self.c;
    |                 ----^^^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: value assigned to `err` is never read
  --> src/linbcg.rs:57:13
   |
57 |     let mut err = 0.0;
   |             ^^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `zm1nrm` is never read
  --> src/linbcg.rs:85:13
   |
85 |     let mut zm1nrm = 0.0;
   |             ^^^^^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `current_result` is never read
   --> src/midsqu.rs:114:13
    |
114 |     let mut current_result = 0.0;
    |             ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:205:22
    |
205 |         let qk_vec = unsafe { _mm256_set1_pd(q[k]) };
    |                      ^^^^^^ unnecessary `unsafe` block
    |
    = note: `#[warn(unused_unsafe)]` (part of `#[warn(unused)]`) on by default

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:212:27
    |
212 |             let product = unsafe { _mm256_mul_pd(qk_vec, v_vec) };
    |                           ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
   --> src/polydiv.rs:213:26
    |
213 |             let result = unsafe { _mm256_sub_pd(r_vec, product) };
    |                          ^^^^^^ unnecessary `unsafe` block

warning: variable `sum` is assigned to, but never used
   --> src/qromo.rs:192:17
    |
192 |         let mut sum = 0.0;
    |                 ^^^
    |
    = note: consider using `_sum` instead
help: you might have meant to pattern match on the similarly named constant `CBRT_EPSILON`
    |
192 -         let mut sum = 0.0;
192 +         let mut constants::CBRT_EPSILON = 0.0;
    |

warning: value assigned to `iy` is never read
  --> src/random_1.rs:32:17
   |
32 |         let mut iy = 0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: value assigned to `iy` is never read
  --> src/random_2.rs:39:17
   |
39 |         let mut iy = 0;
   |                 ^^
   |
   = help: maybe it is overwritten before being read?

warning: variable does not need to be mutable
  --> src/random_2.rs:37:13
   |
37 |         let mut idum2 = idum1;
   |             ----^^^^^
   |             |
   |             help: remove this `mut`

warning: unused variable: `k`
  --> src/random_3.rs:39:17
   |
39 |             for k in 1..=4 {
   |                 ^
   |
help: if this is intentional, prefix it with an underscore
   |
39 |             for _k in 1..=4 {
   |                 +
help: you might have meant to pattern match on the similarly named constant `MAXIT`
   |
39 -             for k in 1..=4 {
39 +             for bessel_jy::MAXIT in 1..=4 {
   |

Some errors have detailed explanations: E0015, E0061, E0133, E0277, E0282, E0308, E0368, E0369, E0412...
For more information about an error, try `rustc --explain E0015`.
warning: `num_rs` (lib) generated 190 warnings
error: could not compile `num_rs` (lib) due to 133 previous errors; 190 warnings emitted
